{"ast":null,"code":"//@ts-check\nconst Graph = require('./Graph');\n/** A class encapsulating the functionality to find the smallest set of smallest rings in a graph. */\n\n\nclass SSSR {\n  /**\r\n   * Returns an array containing arrays, each representing a ring from the smallest set of smallest rings in the graph.\r\n   * \r\n   * @param {Graph} graph A Graph object.\r\n   * @param {Boolean} [experimental=false] Whether or not to use experimental SSSR.\r\n   * @returns {Array[]} An array containing arrays, each representing a ring from the smallest set of smallest rings in the group.\r\n   */\n  static getRings(graph, experimental = false) {\n    let adjacencyMatrix = graph.getComponentsAdjacencyMatrix();\n\n    if (adjacencyMatrix.length === 0) {\n      return null;\n    }\n\n    let connectedComponents = Graph.getConnectedComponents(adjacencyMatrix);\n    let rings = Array();\n\n    for (var i = 0; i < connectedComponents.length; i++) {\n      let connectedComponent = connectedComponents[i];\n      let ccAdjacencyMatrix = graph.getSubgraphAdjacencyMatrix([...connectedComponent]);\n      let arrBondCount = new Uint16Array(ccAdjacencyMatrix.length);\n      let arrRingCount = new Uint16Array(ccAdjacencyMatrix.length);\n\n      for (var j = 0; j < ccAdjacencyMatrix.length; j++) {\n        arrRingCount[j] = 0;\n        arrBondCount[j] = 0;\n\n        for (var k = 0; k < ccAdjacencyMatrix[j].length; k++) {\n          arrBondCount[j] += ccAdjacencyMatrix[j][k];\n        }\n      } // Get the edge number and the theoretical number of rings in SSSR\n\n\n      let nEdges = 0;\n\n      for (var j = 0; j < ccAdjacencyMatrix.length; j++) {\n        for (var k = j + 1; k < ccAdjacencyMatrix.length; k++) {\n          nEdges += ccAdjacencyMatrix[j][k];\n        }\n      }\n\n      let nSssr = nEdges - ccAdjacencyMatrix.length + 1; // console.log(nEdges, ccAdjacencyMatrix.length, nSssr);\n      // console.log(SSSR.getEdgeList(ccAdjacencyMatrix));\n      // console.log(ccAdjacencyMatrix);\n      // If all vertices have 3 incident edges, calculate with different formula (see Euler)\n\n      let allThree = true;\n\n      for (var j = 0; j < arrBondCount.length; j++) {\n        if (arrBondCount[j] !== 3) {\n          allThree = false;\n        }\n      }\n\n      if (allThree) {\n        nSssr = 2.0 + nEdges - ccAdjacencyMatrix.length;\n      } // All vertices are part of one ring if theres only one ring.\n\n\n      if (nSssr === 1) {\n        rings.push([...connectedComponent]);\n        continue;\n      }\n\n      if (experimental) {\n        nSssr = 999;\n      }\n\n      let {\n        d,\n        pe,\n        pe_prime\n      } = SSSR.getPathIncludedDistanceMatrices(ccAdjacencyMatrix);\n      let c = SSSR.getRingCandidates(d, pe, pe_prime);\n      let sssr = SSSR.getSSSR(c, d, ccAdjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nSssr);\n\n      for (var j = 0; j < sssr.length; j++) {\n        let ring = Array(sssr[j].size);\n        let index = 0;\n\n        for (let val of sssr[j]) {\n          // Get the original id of the vertex back\n          ring[index++] = connectedComponent[val];\n        }\n\n        rings.push(ring);\n      }\n    } // So, for some reason, this would return three rings for C1CCCC2CC1CCCC2, which is wrong\n    // As I don't have time to fix this properly, it will stay in. I'm sorry next person who works\n    // on it. At that point it might be best to reimplement the whole SSSR thing...\n\n\n    return rings;\n  }\n  /**\r\n   * Creates a printable string from a matrix (2D array).\r\n   * \r\n   * @param {Array[]} matrix A 2D array.\r\n   * @returns {String} A string representing the matrix.\r\n   */\n\n\n  static matrixToString(matrix) {\n    let str = '';\n\n    for (var i = 0; i < matrix.length; i++) {\n      for (var j = 0; j < matrix[i].length; j++) {\n        str += matrix[i][j] + ' ';\n      }\n\n      str += '\\n';\n    }\n\n    return str;\n  }\n  /**\r\n   * Returnes the two path-included distance matrices used to find the sssr.\r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Object} The path-included distance matrices. { p1, p2 }\r\n   */\n\n\n  static getPathIncludedDistanceMatrices(adjacencyMatrix) {\n    let length = adjacencyMatrix.length;\n    let d = Array(length);\n    let pe = Array(length);\n    let pe_prime = Array(length);\n    var l = 0;\n    var m = 0;\n    var n = 0;\n    var i = length;\n\n    while (i--) {\n      d[i] = Array(length);\n      pe[i] = Array(length);\n      pe_prime[i] = Array(length);\n      var j = length;\n\n      while (j--) {\n        d[i][j] = i === j || adjacencyMatrix[i][j] === 1 ? adjacencyMatrix[i][j] : Number.POSITIVE_INFINITY;\n\n        if (d[i][j] === 1) {\n          pe[i][j] = [[[i, j]]];\n        } else {\n          pe[i][j] = Array();\n        }\n\n        pe_prime[i][j] = Array();\n      }\n    }\n\n    var k = length;\n    var j;\n\n    while (k--) {\n      i = length;\n\n      while (i--) {\n        j = length;\n\n        while (j--) {\n          const previousPathLength = d[i][j];\n          const newPathLength = d[i][k] + d[k][j];\n\n          if (previousPathLength > newPathLength) {\n            var l, m, n;\n\n            if (previousPathLength === newPathLength + 1) {\n              pe_prime[i][j] = [pe[i][j].length];\n              l = pe[i][j].length;\n\n              while (l--) {\n                pe_prime[i][j][l] = [pe[i][j][l].length];\n                m = pe[i][j][l].length;\n\n                while (m--) {\n                  pe_prime[i][j][l][m] = [pe[i][j][l][m].length];\n                  n = pe[i][j][l][m].length;\n\n                  while (n--) {\n                    pe_prime[i][j][l][m][n] = [pe[i][j][l][m][0], pe[i][j][l][m][1]];\n                  }\n                }\n              }\n            } else {\n              pe_prime[i][j] = Array();\n            }\n\n            d[i][j] = newPathLength;\n            pe[i][j] = [[]];\n            l = pe[i][k][0].length;\n\n            while (l--) {\n              pe[i][j][0].push(pe[i][k][0][l]);\n            }\n\n            l = pe[k][j][0].length;\n\n            while (l--) {\n              pe[i][j][0].push(pe[k][j][0][l]);\n            }\n          } else if (previousPathLength === newPathLength) {\n            if (pe[i][k].length && pe[k][j].length) {\n              var l;\n\n              if (pe[i][j].length) {\n                let tmp = Array();\n                l = pe[i][k][0].length;\n\n                while (l--) {\n                  tmp.push(pe[i][k][0][l]);\n                }\n\n                l = pe[k][j][0].length;\n\n                while (l--) {\n                  tmp.push(pe[k][j][0][l]);\n                }\n\n                pe[i][j].push(tmp);\n              } else {\n                let tmp = Array();\n                l = pe[i][k][0].length;\n\n                while (l--) {\n                  tmp.push(pe[i][k][0][l]);\n                }\n\n                l = pe[k][j][0].length;\n\n                while (l--) {\n                  tmp.push(pe[k][j][0][l]);\n                }\n\n                pe[i][j][0] = tmp;\n              }\n            }\n          } else if (previousPathLength === newPathLength - 1) {\n            var l;\n\n            if (pe_prime[i][j].length) {\n              let tmp = Array();\n              l = pe[i][k][0].length;\n\n              while (l--) {\n                tmp.push(pe[i][k][0][l]);\n              }\n\n              l = pe[k][j][0].length;\n\n              while (l--) {\n                tmp.push(pe[k][j][0][l]);\n              }\n\n              pe_prime[i][j].push(tmp);\n            } else {\n              let tmp = Array();\n              l = pe[i][k][0].length;\n\n              while (l--) {\n                tmp.push(pe[i][k][0][l]);\n              }\n\n              l = pe[k][j][0].length;\n\n              while (l--) {\n                tmp.push(pe[k][j][0][l]);\n              }\n\n              pe_prime[i][j][0] = tmp;\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      d: d,\n      pe: pe,\n      pe_prime: pe_prime\n    };\n  }\n  /**\r\n   * Get the ring candidates from the path-included distance matrices.\r\n   * \r\n   * @param {Array[]} d The distance matrix.\r\n   * @param {Array[]} pe A matrix containing the shortest paths.\r\n   * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.\r\n   * @returns {Array[]} The ring candidates.\r\n   */\n\n\n  static getRingCandidates(d, pe, pe_prime) {\n    let length = d.length;\n    let candidates = Array();\n    let c = 0;\n\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length; j++) {\n        if (d[i][j] === 0 || pe[i][j].length === 1 && pe_prime[i][j] === 0) {\n          continue;\n        } else {\n          // c is the number of vertices in the cycle.\n          if (pe_prime[i][j].length !== 0) {\n            c = 2 * (d[i][j] + 0.5);\n          } else {\n            c = 2 * d[i][j];\n          }\n\n          if (c !== Infinity) {\n            candidates.push([c, pe[i][j], pe_prime[i][j]]);\n          }\n        }\n      }\n    } // Candidates have to be sorted by c\n\n\n    candidates.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n    return candidates;\n  }\n  /**\r\n   * Searches the candidates for the smallest set of smallest rings.\r\n   * \r\n   * @param {Array[]} c The candidates.\r\n   * @param {Array[]} d The distance matrix.\r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @param {Array[]} pe A matrix containing the shortest paths.\r\n   * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.\r\n   * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.\r\n   * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.\r\n   * @param {Number} nsssr The theoretical number of rings in the graph.\r\n   * @returns {Set[]} The smallest set of smallest rings.\r\n   */\n\n\n  static getSSSR(c, d, adjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nsssr) {\n    let cSssr = Array();\n    let allBonds = Array();\n\n    for (let i = 0; i < c.length; i++) {\n      if (c[i][0] % 2 !== 0) {\n        for (let j = 0; j < c[i][2].length; j++) {\n          let bonds = c[i][1][0].concat(c[i][2][j]); // Some bonds are added twice, resulting in [[u, v], [u, v]] instead of [u, v].\n          // TODO: This is a workaround, fix later. Probably should be a set rather than an array, however the computational overhead\n          //       is probably bigger compared to leaving it like this.\n\n          for (var k = 0; k < bonds.length; k++) {\n            if (bonds[k][0].constructor === Array) bonds[k] = bonds[k][0];\n          }\n\n          let atoms = SSSR.bondsToAtoms(bonds);\n\n          if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {\n            cSssr.push(atoms);\n            allBonds = allBonds.concat(bonds);\n          }\n\n          if (cSssr.length > nsssr) {\n            return cSssr;\n          }\n        }\n      } else {\n        for (let j = 0; j < c[i][1].length - 1; j++) {\n          let bonds = c[i][1][j].concat(c[i][1][j + 1]); // Some bonds are added twice, resulting in [[u, v], [u, v]] instead of [u, v].\n          // TODO: This is a workaround, fix later. Probably should be a set rather than an array, however the computational overhead\n          //       is probably bigger compared to leaving it like this.\n\n          for (var k = 0; k < bonds.length; k++) {\n            if (bonds[k][0].constructor === Array) bonds[k] = bonds[k][0];\n          }\n\n          let atoms = SSSR.bondsToAtoms(bonds);\n\n          if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {\n            cSssr.push(atoms);\n            allBonds = allBonds.concat(bonds);\n          }\n\n          if (cSssr.length > nsssr) {\n            return cSssr;\n          }\n        }\n      }\n    }\n\n    return cSssr;\n  }\n  /**\r\n   * Returns the number of edges in a graph defined by an adjacency matrix.\r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Number} The number of edges in the graph defined by the adjacency matrix.\r\n   */\n\n\n  static getEdgeCount(adjacencyMatrix) {\n    let edgeCount = 0;\n    let length = adjacencyMatrix.length;\n    var i = length - 1;\n\n    while (i--) {\n      var j = length;\n\n      while (j--) {\n        if (adjacencyMatrix[i][j] === 1) {\n          edgeCount++;\n        }\n      }\n    }\n\n    return edgeCount;\n  }\n  /**\r\n   * Returns an edge list constructed form an adjacency matrix.\r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Array[]} An edge list. E.g. [ [ 0, 1 ], ..., [ 16, 2 ] ]\r\n   */\n\n\n  static getEdgeList(adjacencyMatrix) {\n    let length = adjacencyMatrix.length;\n    let edgeList = Array();\n    var i = length - 1;\n\n    while (i--) {\n      var j = length;\n\n      while (j--) {\n        if (adjacencyMatrix[i][j] === 1) {\n          edgeList.push([i, j]);\n        }\n      }\n    }\n\n    return edgeList;\n  }\n  /**\r\n   * Return a set of vertex indices contained in an array of bonds.\r\n   * \r\n   * @param {Array} bonds An array of bonds. A bond is defined as [ sourceVertexId, targetVertexId ].\r\n   * @returns {Set<Number>} An array of vertices.\r\n   */\n\n\n  static bondsToAtoms(bonds) {\n    let atoms = new Set();\n    var i = bonds.length;\n\n    while (i--) {\n      atoms.add(bonds[i][0]);\n      atoms.add(bonds[i][1]);\n    }\n\n    return atoms;\n  }\n  /**\r\n  * Returns the number of bonds within a set of atoms.\r\n  * \r\n  * @param {Set<Number>} atoms An array of atom ids.\r\n  * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n  * @returns {Number} The number of bonds in a set of atoms.\r\n  */\n\n\n  static getBondCount(atoms, adjacencyMatrix) {\n    let count = 0;\n\n    for (let u of atoms) {\n      for (let v of atoms) {\n        if (u === v) {\n          continue;\n        }\n\n        count += adjacencyMatrix[u][v];\n      }\n    }\n\n    return count / 2;\n  }\n  /**\r\n   * Checks whether or not a given path already exists in an array of paths.\r\n   * \r\n   * @param {Set[]} pathSets An array of sets each representing a path.\r\n   * @param {Set<Number>} pathSet A set representing a path.\r\n   * @param {Array[]} bonds The bonds associated with the current path.\r\n   * @param {Array[]} allBonds All bonds currently associated with rings in the SSSR set.\r\n   * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.\r\n   * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.\r\n   * @returns {Boolean} A boolean indicating whether or not a give path is contained within a set.\r\n   */\n\n\n  static pathSetsContain(pathSets, pathSet, bonds, allBonds, arrBondCount, arrRingCount) {\n    var i = pathSets.length;\n\n    while (i--) {\n      if (SSSR.isSupersetOf(pathSet, pathSets[i])) {\n        return true;\n      }\n\n      if (pathSets[i].size !== pathSet.size) {\n        continue;\n      }\n\n      if (SSSR.areSetsEqual(pathSets[i], pathSet)) {\n        return true;\n      }\n    } // Check if the edges from the candidate are already all contained within the paths of the set of paths.\n    // TODO: For some reason, this does not replace the isSupersetOf method above -> why?\n\n\n    let count = 0;\n    let allContained = false;\n    i = bonds.length;\n\n    while (i--) {\n      var j = allBonds.length;\n\n      while (j--) {\n        if (bonds[i][0] === allBonds[j][0] && bonds[i][1] === allBonds[j][1] || bonds[i][1] === allBonds[j][0] && bonds[i][0] === allBonds[j][1]) {\n          count++;\n        }\n\n        if (count === bonds.length) {\n          allContained = true;\n        }\n      }\n    } // If all the bonds and thus vertices are already contained within other rings\n    // check if there's one vertex with ringCount < bondCount\n\n\n    let specialCase = false;\n\n    if (allContained) {\n      for (let element of pathSet) {\n        if (arrRingCount[element] < arrBondCount[element]) {\n          specialCase = true;\n          break;\n        }\n      }\n    }\n\n    if (allContained && !specialCase) {\n      return true;\n    } // Update the ring counts for the vertices\n\n\n    for (let element of pathSet) {\n      arrRingCount[element]++;\n    }\n\n    return false;\n  }\n  /**\r\n   * Checks whether or not two sets are equal (contain the same elements).\r\n   * \r\n   * @param {Set<Number>} setA A set.\r\n   * @param {Set<Number>} setB A set.\r\n   * @returns {Boolean} A boolean indicating whether or not the two sets are equal.\r\n   */\n\n\n  static areSetsEqual(setA, setB) {\n    if (setA.size !== setB.size) {\n      return false;\n    }\n\n    for (let element of setA) {\n      if (!setB.has(element)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * Checks whether or not a set (setA) is a superset of another set (setB).\r\n   * \r\n   * @param {Set<Number>} setA A set.\r\n   * @param {Set<Number>} setB A set.\r\n   * @returns {Boolean} A boolean indicating whether or not setB is a superset of setA.\r\n   */\n\n\n  static isSupersetOf(setA, setB) {\n    for (var element of setB) {\n      if (!setA.has(element)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = SSSR;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/smiles-drawer/src/SSSR.js"],"names":["Graph","require","SSSR","getRings","graph","experimental","adjacencyMatrix","getComponentsAdjacencyMatrix","length","connectedComponents","getConnectedComponents","rings","Array","i","connectedComponent","ccAdjacencyMatrix","getSubgraphAdjacencyMatrix","arrBondCount","Uint16Array","arrRingCount","j","k","nEdges","nSssr","allThree","push","d","pe","pe_prime","getPathIncludedDistanceMatrices","c","getRingCandidates","sssr","getSSSR","ring","size","index","val","matrixToString","matrix","str","l","m","n","Number","POSITIVE_INFINITY","previousPathLength","newPathLength","tmp","candidates","Infinity","sort","a","b","nsssr","cSssr","allBonds","bonds","concat","constructor","atoms","bondsToAtoms","getBondCount","pathSetsContain","getEdgeCount","edgeCount","getEdgeList","edgeList","Set","add","count","u","v","pathSets","pathSet","isSupersetOf","areSetsEqual","allContained","specialCase","element","setA","setB","has","module","exports"],"mappings":"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","sourcesContent":["//@ts-check\r\nconst Graph = require('./Graph')\r\n\r\n/** A class encapsulating the functionality to find the smallest set of smallest rings in a graph. */\r\nclass SSSR {\r\n    /**\r\n     * Returns an array containing arrays, each representing a ring from the smallest set of smallest rings in the graph.\r\n     * \r\n     * @param {Graph} graph A Graph object.\r\n     * @param {Boolean} [experimental=false] Whether or not to use experimental SSSR.\r\n     * @returns {Array[]} An array containing arrays, each representing a ring from the smallest set of smallest rings in the group.\r\n     */\r\n    static getRings(graph, experimental=false) {\r\n        let adjacencyMatrix = graph.getComponentsAdjacencyMatrix();\r\n        if (adjacencyMatrix.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        let connectedComponents = Graph.getConnectedComponents(adjacencyMatrix);\r\n        let rings = Array();\r\n\r\n        for (var i = 0; i < connectedComponents.length; i++) {\r\n            let connectedComponent = connectedComponents[i];\r\n            let ccAdjacencyMatrix = graph.getSubgraphAdjacencyMatrix([...connectedComponent]);\r\n\r\n            let arrBondCount = new Uint16Array(ccAdjacencyMatrix.length);\r\n            let arrRingCount = new Uint16Array(ccAdjacencyMatrix.length);\r\n\r\n            for (var j = 0; j < ccAdjacencyMatrix.length; j++) {\r\n                arrRingCount[j] = 0;\r\n                arrBondCount[j] = 0;\r\n\r\n                for (var k = 0; k < ccAdjacencyMatrix[j].length; k++) {\r\n                    arrBondCount[j] += ccAdjacencyMatrix[j][k];\r\n                }\r\n            }\r\n\r\n            // Get the edge number and the theoretical number of rings in SSSR\r\n            let nEdges = 0;\r\n\r\n            for (var j = 0; j < ccAdjacencyMatrix.length; j++) {\r\n                for (var k = j + 1; k < ccAdjacencyMatrix.length; k++) {\r\n                    nEdges += ccAdjacencyMatrix[j][k];\r\n                }\r\n            }\r\n\r\n            let nSssr = nEdges - ccAdjacencyMatrix.length + 1;\r\n\r\n            // console.log(nEdges, ccAdjacencyMatrix.length, nSssr);\r\n            // console.log(SSSR.getEdgeList(ccAdjacencyMatrix));\r\n            // console.log(ccAdjacencyMatrix);\r\n\r\n            // If all vertices have 3 incident edges, calculate with different formula (see Euler)\r\n            let allThree = true;\r\n            for (var j = 0; j < arrBondCount.length; j++) {\r\n                if (arrBondCount[j] !== 3) {\r\n                    allThree = false;\r\n                }\r\n            }\r\n\r\n            if (allThree) {\r\n                nSssr = 2.0 + nEdges - ccAdjacencyMatrix.length;\r\n            }\r\n\r\n            // All vertices are part of one ring if theres only one ring.\r\n            if (nSssr === 1) {\r\n                rings.push([...connectedComponent]);\r\n                continue;\r\n            }\r\n            \r\n            if (experimental) {\r\n                nSssr = 999;\r\n            }\r\n\r\n            let { d, pe, pe_prime } = SSSR.getPathIncludedDistanceMatrices(ccAdjacencyMatrix);\r\n            let c = SSSR.getRingCandidates(d, pe, pe_prime);\r\n            let sssr = SSSR.getSSSR(c, d, ccAdjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nSssr);\r\n\r\n            for (var j = 0; j < sssr.length; j++) {\r\n                let ring = Array(sssr[j].size);\r\n                let index = 0;\r\n\r\n                for (let val of sssr[j]) {\r\n                    // Get the original id of the vertex back\r\n                    ring[index++] = connectedComponent[val];\r\n                }\r\n\r\n                rings.push(ring);\r\n            }\r\n        }\r\n        \r\n\r\n        // So, for some reason, this would return three rings for C1CCCC2CC1CCCC2, which is wrong\r\n        // As I don't have time to fix this properly, it will stay in. I'm sorry next person who works\r\n        // on it. At that point it might be best to reimplement the whole SSSR thing...\r\n        return rings;\r\n    }\r\n\r\n    /**\r\n     * Creates a printable string from a matrix (2D array).\r\n     * \r\n     * @param {Array[]} matrix A 2D array.\r\n     * @returns {String} A string representing the matrix.\r\n     */\r\n    static matrixToString(matrix) {\r\n        let str = '';\r\n\r\n        for (var i = 0; i < matrix.length; i++) {\r\n            for (var j = 0; j < matrix[i].length; j++) {\r\n                str += matrix[i][j] + ' ';\r\n            }\r\n\r\n            str += '\\n';\r\n        }\r\n\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * Returnes the two path-included distance matrices used to find the sssr.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Object} The path-included distance matrices. { p1, p2 }\r\n     */\r\n    static getPathIncludedDistanceMatrices(adjacencyMatrix) {\r\n        let length = adjacencyMatrix.length;\r\n        let d = Array(length);\r\n        let pe = Array(length);\r\n        let pe_prime = Array(length);\r\n        var l = 0;\r\n        var m = 0;\r\n        var n = 0;\r\n\r\n        var i = length;\r\n        while (i--) {\r\n            d[i] = Array(length);\r\n            pe[i] = Array(length);\r\n            pe_prime[i] = Array(length);\r\n\r\n            var j = length;\r\n            while (j--) {\r\n                d[i][j] = (i === j || adjacencyMatrix[i][j] === 1) ? adjacencyMatrix[i][j] : Number.POSITIVE_INFINITY;\r\n\r\n                if (d[i][j] === 1) {\r\n                    pe[i][j] = [[[i, j]]];\r\n                } else {\r\n                    pe[i][j] = Array();\r\n                }\r\n\r\n                pe_prime[i][j] = Array();\r\n            }\r\n        }\r\n\r\n        var k = length;\r\n        var j;\r\n        while (k--) {\r\n            i = length;\r\n            while (i--) {\r\n                j = length;\r\n                while (j--) {\r\n                    const previousPathLength = d[i][j];\r\n                    const newPathLength = d[i][k] + d[k][j];\r\n\r\n                    if (previousPathLength > newPathLength) {\r\n                        var l, m, n;\r\n                        if (previousPathLength === newPathLength + 1) {\r\n                            pe_prime[i][j] = [pe[i][j].length];\r\n                            l = pe[i][j].length\r\n                            while (l--) {\r\n                                pe_prime[i][j][l] = [pe[i][j][l].length];\r\n                                m = pe[i][j][l].length\r\n                                while (m--) {\r\n                                    pe_prime[i][j][l][m] = [pe[i][j][l][m].length];\r\n                                    n = pe[i][j][l][m].length;\r\n                                    while (n--) {\r\n                                        pe_prime[i][j][l][m][n] = [pe[i][j][l][m][0], pe[i][j][l][m][1]];\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            pe_prime[i][j] = Array();\r\n                        }\r\n\r\n                        d[i][j] = newPathLength;\r\n\r\n                        pe[i][j] = [[]];\r\n\r\n                        l = pe[i][k][0].length;\r\n                        while (l--) {\r\n                            pe[i][j][0].push(pe[i][k][0][l]);\r\n                        }\r\n\r\n                        l = pe[k][j][0].length;\r\n                        while (l--) {\r\n                            pe[i][j][0].push(pe[k][j][0][l]);\r\n                        }\r\n                    } else if (previousPathLength === newPathLength) {\r\n                        if (pe[i][k].length && pe[k][j].length) {\r\n                            var l;\r\n                            if (pe[i][j].length) {\r\n                                let tmp = Array();\r\n\r\n                                l = pe[i][k][0].length;\r\n                                while (l--) {\r\n                                    tmp.push(pe[i][k][0][l]);\r\n                                }\r\n\r\n                                l = pe[k][j][0].length;\r\n                                while (l--) {\r\n                                    tmp.push(pe[k][j][0][l]);\r\n                                }\r\n\r\n                                pe[i][j].push(tmp);\r\n                            } else {\r\n                                let tmp = Array();\r\n                                l = pe[i][k][0].length;\r\n                                while (l--) {\r\n                                    tmp.push(pe[i][k][0][l]);\r\n                                }\r\n\r\n                                l = pe[k][j][0].length;\r\n                                while (l--) {\r\n                                    tmp.push(pe[k][j][0][l]);\r\n                                }\r\n\r\n                                pe[i][j][0] = tmp\r\n                            }\r\n                        }\r\n                    } else if (previousPathLength === newPathLength - 1) {\r\n                        var l;\r\n                        if (pe_prime[i][j].length) {\r\n                            let tmp = Array();\r\n\r\n                            l = pe[i][k][0].length;\r\n                            while (l--) {\r\n                                tmp.push(pe[i][k][0][l]);\r\n                            }\r\n\r\n                            l = pe[k][j][0].length;\r\n                            while (l--) {\r\n                                tmp.push(pe[k][j][0][l]);\r\n                            }\r\n\r\n                            pe_prime[i][j].push(tmp);\r\n                        } else {\r\n                            let tmp = Array();\r\n\r\n                            l = pe[i][k][0].length;\r\n                            while (l--) {\r\n                                tmp.push(pe[i][k][0][l]);\r\n                            }\r\n\r\n                            l = pe[k][j][0].length;\r\n                            while (l--) {\r\n                                tmp.push(pe[k][j][0][l]);\r\n                            }\r\n\r\n                            pe_prime[i][j][0] = tmp;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            d: d,\r\n            pe: pe,\r\n            pe_prime: pe_prime\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the ring candidates from the path-included distance matrices.\r\n     * \r\n     * @param {Array[]} d The distance matrix.\r\n     * @param {Array[]} pe A matrix containing the shortest paths.\r\n     * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.\r\n     * @returns {Array[]} The ring candidates.\r\n     */\r\n    static getRingCandidates(d, pe, pe_prime) {\r\n        let length = d.length;\r\n        let candidates = Array();\r\n        let c = 0;\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            for (let j = 0; j < length; j++) {\r\n                if (d[i][j] === 0 || (pe[i][j].length === 1 && pe_prime[i][j] === 0)) {\r\n                    continue;\r\n                } else {\r\n                    // c is the number of vertices in the cycle.\r\n                    if (pe_prime[i][j].length !== 0) {\r\n                        c = 2 * (d[i][j] + 0.5);\r\n                    } else {\r\n                        c = 2 * d[i][j];\r\n                    }\r\n\r\n                    if (c !== Infinity) {\r\n                        candidates.push([c, pe[i][j], pe_prime[i][j]]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Candidates have to be sorted by c\r\n        candidates.sort(function (a, b) {\r\n            return a[0] - b[0];\r\n        });\r\n\r\n        return candidates;\r\n    }\r\n\r\n    /**\r\n     * Searches the candidates for the smallest set of smallest rings.\r\n     * \r\n     * @param {Array[]} c The candidates.\r\n     * @param {Array[]} d The distance matrix.\r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @param {Array[]} pe A matrix containing the shortest paths.\r\n     * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.\r\n     * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.\r\n     * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.\r\n     * @param {Number} nsssr The theoretical number of rings in the graph.\r\n     * @returns {Set[]} The smallest set of smallest rings.\r\n     */\r\n    static getSSSR(c, d, adjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nsssr) {\r\n        let cSssr = Array();\r\n        let allBonds = Array();\r\n\r\n        for (let i = 0; i < c.length; i++) {\r\n            if (c[i][0] % 2 !== 0) {\r\n                for (let j = 0; j < c[i][2].length; j++) {\r\n                    let bonds = c[i][1][0].concat(c[i][2][j]);\r\n                    // Some bonds are added twice, resulting in [[u, v], [u, v]] instead of [u, v].\r\n                    // TODO: This is a workaround, fix later. Probably should be a set rather than an array, however the computational overhead\r\n                    //       is probably bigger compared to leaving it like this.\r\n                    for (var k = 0; k < bonds.length; k++) {\r\n                        if (bonds[k][0].constructor === Array) bonds[k] = bonds[k][0];\r\n                    }\r\n\r\n                    let atoms = SSSR.bondsToAtoms(bonds);\r\n\r\n                    if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {\r\n                        cSssr.push(atoms);\r\n                        allBonds = allBonds.concat(bonds);\r\n                    }\r\n\r\n                    if (cSssr.length > nsssr) {\r\n                        return cSssr;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let j = 0; j < c[i][1].length - 1; j++) {\r\n                    let bonds = c[i][1][j].concat(c[i][1][j + 1]);\r\n                    // Some bonds are added twice, resulting in [[u, v], [u, v]] instead of [u, v].\r\n                    // TODO: This is a workaround, fix later. Probably should be a set rather than an array, however the computational overhead\r\n                    //       is probably bigger compared to leaving it like this.\r\n                    for (var k = 0; k < bonds.length; k++) {\r\n                        if (bonds[k][0].constructor === Array) bonds[k] = bonds[k][0];\r\n                    }\r\n\r\n                    let atoms = SSSR.bondsToAtoms(bonds);\r\n\r\n                    if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {\r\n                        cSssr.push(atoms);\r\n                        allBonds = allBonds.concat(bonds);\r\n                    }\r\n\r\n                    if (cSssr.length > nsssr) {\r\n                        return cSssr;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return cSssr;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of edges in a graph defined by an adjacency matrix.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Number} The number of edges in the graph defined by the adjacency matrix.\r\n     */\r\n    static getEdgeCount(adjacencyMatrix) {\r\n        let edgeCount = 0;\r\n        let length = adjacencyMatrix.length;\r\n\r\n        var i = length - 1;\r\n        while (i--) {\r\n            var j = length;\r\n            while (j--) {\r\n                if (adjacencyMatrix[i][j] === 1) {\r\n                    edgeCount++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return edgeCount;\r\n    }\r\n\r\n    /**\r\n     * Returns an edge list constructed form an adjacency matrix.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Array[]} An edge list. E.g. [ [ 0, 1 ], ..., [ 16, 2 ] ]\r\n     */\r\n    static getEdgeList(adjacencyMatrix) {\r\n        let length = adjacencyMatrix.length;\r\n        let edgeList = Array();\r\n\r\n        var i = length - 1;\r\n        while (i--) {\r\n            var j = length;\r\n            while (j--) {\r\n                if (adjacencyMatrix[i][j] === 1) {\r\n                    edgeList.push([i, j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return edgeList;\r\n    }\r\n\r\n    /**\r\n     * Return a set of vertex indices contained in an array of bonds.\r\n     * \r\n     * @param {Array} bonds An array of bonds. A bond is defined as [ sourceVertexId, targetVertexId ].\r\n     * @returns {Set<Number>} An array of vertices.\r\n     */\r\n    static bondsToAtoms(bonds) {\r\n        let atoms = new Set();\r\n\r\n        var i = bonds.length;\r\n        while (i--) {\r\n            atoms.add(bonds[i][0]);\r\n            atoms.add(bonds[i][1]);\r\n        }\r\n        return atoms;\r\n    }\r\n\r\n    /**\r\n    * Returns the number of bonds within a set of atoms.\r\n    * \r\n    * @param {Set<Number>} atoms An array of atom ids.\r\n    * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n    * @returns {Number} The number of bonds in a set of atoms.\r\n    */\r\n    static getBondCount(atoms, adjacencyMatrix) {\r\n        let count = 0;\r\n        for (let u of atoms) {\r\n            for (let v of atoms) {\r\n                if (u === v) {\r\n                    continue;\r\n                }\r\n                count += adjacencyMatrix[u][v]\r\n            }\r\n        }\r\n\r\n        return count / 2;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not a given path already exists in an array of paths.\r\n     * \r\n     * @param {Set[]} pathSets An array of sets each representing a path.\r\n     * @param {Set<Number>} pathSet A set representing a path.\r\n     * @param {Array[]} bonds The bonds associated with the current path.\r\n     * @param {Array[]} allBonds All bonds currently associated with rings in the SSSR set.\r\n     * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.\r\n     * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.\r\n     * @returns {Boolean} A boolean indicating whether or not a give path is contained within a set.\r\n     */\r\n    static pathSetsContain(pathSets, pathSet, bonds, allBonds, arrBondCount, arrRingCount) {\r\n        var i = pathSets.length;\r\n        while (i--) {\r\n            if (SSSR.isSupersetOf(pathSet, pathSets[i])) {\r\n                return true;\r\n            }\r\n\r\n            if (pathSets[i].size !== pathSet.size) {\r\n                continue;\r\n            }\r\n\r\n            if (SSSR.areSetsEqual(pathSets[i], pathSet)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // Check if the edges from the candidate are already all contained within the paths of the set of paths.\r\n        // TODO: For some reason, this does not replace the isSupersetOf method above -> why?\r\n        let count = 0;\r\n        let allContained = false;\r\n        i = bonds.length;\r\n        while (i--) {\r\n            var j = allBonds.length;\r\n            while (j--) {\r\n                if (bonds[i][0] === allBonds[j][0] && bonds[i][1] === allBonds[j][1] ||\r\n                    bonds[i][1] === allBonds[j][0] && bonds[i][0] === allBonds[j][1]) {\r\n                    count++;\r\n                }\r\n\r\n                if (count === bonds.length) {\r\n                    allContained = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // If all the bonds and thus vertices are already contained within other rings\r\n        // check if there's one vertex with ringCount < bondCount\r\n        let specialCase = false;\r\n        if (allContained) {\r\n            for (let element of pathSet) {\r\n                if (arrRingCount[element] < arrBondCount[element]) {\r\n                    specialCase = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (allContained && !specialCase) {\r\n            return true;\r\n        }\r\n\r\n        // Update the ring counts for the vertices\r\n        for (let element of pathSet) {\r\n            arrRingCount[element]++;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not two sets are equal (contain the same elements).\r\n     * \r\n     * @param {Set<Number>} setA A set.\r\n     * @param {Set<Number>} setB A set.\r\n     * @returns {Boolean} A boolean indicating whether or not the two sets are equal.\r\n     */\r\n    static areSetsEqual(setA, setB) {\r\n        if (setA.size !== setB.size) {\r\n            return false;\r\n        }\r\n\r\n        for (let element of setA) {\r\n            if (!setB.has(element)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not a set (setA) is a superset of another set (setB).\r\n     * \r\n     * @param {Set<Number>} setA A set.\r\n     * @param {Set<Number>} setB A set.\r\n     * @returns {Boolean} A boolean indicating whether or not setB is a superset of setA.\r\n     */\r\n    static isSupersetOf(setA, setB) {\r\n        for (var element of setB) {\r\n            if (!setA.has(element)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nmodule.exports = SSSR;"]},"metadata":{},"sourceType":"script"}