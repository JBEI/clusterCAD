{"ast":null,"code":"//@ts-check\nconst Vertex = require('./Vertex');\n\nconst Ring = require('./Ring');\n/** \r\n * A class representing a ring connection.\r\n * \r\n * @property {Number} id The id of this ring connection.\r\n * @property {Number} firstRingId A ring id.\r\n * @property {Number} secondRingId A ring id.\r\n * @property {Set<Number>} vertices A set containing the vertex ids participating in the ring connection.\r\n */\n\n\nclass RingConnection {\n  /**\r\n   * The constructor for the class RingConnection.\r\n   *\r\n   * @param {Ring} firstRing A ring.\r\n   * @param {Ring} secondRing A ring.\r\n   */\n  constructor(firstRing, secondRing) {\n    this.id = null;\n    this.firstRingId = firstRing.id;\n    this.secondRingId = secondRing.id;\n    this.vertices = new Set();\n\n    for (var m = 0; m < firstRing.members.length; m++) {\n      let c = firstRing.members[m];\n\n      for (let n = 0; n < secondRing.members.length; n++) {\n        let d = secondRing.members[n];\n\n        if (c === d) {\n          this.addVertex(c);\n        }\n      }\n    }\n  }\n  /**\r\n   * Adding a vertex to the ring connection.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   */\n\n\n  addVertex(vertexId) {\n    this.vertices.add(vertexId);\n  }\n  /**\r\n   * Update the ring id of this ring connection that is not the ring id supplied as the second argument.\r\n   *\r\n   * @param {Number} ringId A ring id. The new ring id to be set.\r\n   * @param {Number} otherRingId A ring id. The id that is NOT to be updated.\r\n   */\n\n\n  updateOther(ringId, otherRingId) {\n    if (this.firstRingId === otherRingId) {\n      this.secondRingId = ringId;\n    } else {\n      this.firstRingId = ringId;\n    }\n  }\n  /**\r\n   * Returns a boolean indicating whether or not a ring with a given id is participating in this ring connection.\r\n   * \r\n   * @param {Number} ringId A ring id.\r\n   * @returns {Boolean} A boolean indicating whether or not a ring with a given id participates in this ring connection.\r\n   */\n\n\n  containsRing(ringId) {\n    return this.firstRingId === ringId || this.secondRingId === ringId;\n  }\n  /**\r\n   * Checks whether or not this ring connection is a bridge in a bridged ring.\r\n   *\r\n   * @param {Vertex[]} vertices The array of vertices associated with the current molecule.\r\n   * @returns {Boolean} A boolean indicating whether or not this ring connection is a bridge.\r\n   */\n\n\n  isBridge(vertices) {\n    if (this.vertices.size > 2) {\n      return true;\n    }\n\n    for (let vertexId of this.vertices) {\n      if (vertices[vertexId].value.rings.length > 2) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Checks whether or not two rings are connected by a bridged bond.\r\n   *\r\n   * @static\r\n   * @param {RingConnection[]} ringConnections An array of ring connections containing the ring connections associated with the current molecule.\r\n   * @param {Vertex[]} vertices An array of vertices containing the vertices associated with the current molecule.\r\n   * @param {Number} firstRingId A ring id.\r\n   * @param {Number} secondRingId A ring id.\r\n   * @returns {Boolean} A boolean indicating whether or not two rings ar connected by a bridged bond.\r\n   */\n\n\n  static isBridge(ringConnections, vertices, firstRingId, secondRingId) {\n    let ringConnection = null;\n\n    for (let i = 0; i < ringConnections.length; i++) {\n      ringConnection = ringConnections[i];\n\n      if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId || ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {\n        return ringConnection.isBridge(vertices);\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Retruns the neighbouring rings of a given ring.\r\n   *\r\n   * @static\r\n   * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.\r\n   * @param {Number} ringId A ring id.\r\n   * @returns {Number[]} An array of ring ids of neighbouring rings.\r\n   */\n\n\n  static getNeighbours(ringConnections, ringId) {\n    let neighbours = [];\n\n    for (let i = 0; i < ringConnections.length; i++) {\n      let ringConnection = ringConnections[i];\n\n      if (ringConnection.firstRingId === ringId) {\n        neighbours.push(ringConnection.secondRingId);\n      } else if (ringConnection.secondRingId === ringId) {\n        neighbours.push(ringConnection.firstRingId);\n      }\n    }\n\n    return neighbours;\n  }\n  /**\r\n   * Returns an array of vertex ids associated with a given ring connection.\r\n   *\r\n   * @static\r\n   * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.\r\n   * @param {Number} firstRingId A ring id.\r\n   * @param {Number} secondRingId A ring id.\r\n   * @returns {Number[]} An array of vertex ids associated with the ring connection.\r\n   */\n\n\n  static getVertices(ringConnections, firstRingId, secondRingId) {\n    for (let i = 0; i < ringConnections.length; i++) {\n      let ringConnection = ringConnections[i];\n\n      if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId || ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {\n        return [...ringConnection.vertices];\n      }\n    }\n  }\n\n}\n\nmodule.exports = RingConnection;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/smiles-drawer/src/RingConnection.js"],"names":["Vertex","require","Ring","RingConnection","constructor","firstRing","secondRing","id","firstRingId","secondRingId","vertices","Set","m","members","length","c","n","d","addVertex","vertexId","add","updateOther","ringId","otherRingId","containsRing","isBridge","size","value","rings","ringConnections","ringConnection","i","getNeighbours","neighbours","push","getVertices","module","exports"],"mappings":"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","sourcesContent":["//@ts-check\r\nconst Vertex = require('./Vertex')\r\nconst Ring = require('./Ring')\r\n\r\n/** \r\n * A class representing a ring connection.\r\n * \r\n * @property {Number} id The id of this ring connection.\r\n * @property {Number} firstRingId A ring id.\r\n * @property {Number} secondRingId A ring id.\r\n * @property {Set<Number>} vertices A set containing the vertex ids participating in the ring connection.\r\n */\r\nclass RingConnection {\r\n    /**\r\n     * The constructor for the class RingConnection.\r\n     *\r\n     * @param {Ring} firstRing A ring.\r\n     * @param {Ring} secondRing A ring.\r\n     */\r\n    constructor(firstRing, secondRing) {\r\n        this.id = null;\r\n        this.firstRingId = firstRing.id;\r\n        this.secondRingId = secondRing.id;\r\n        this.vertices = new Set();\r\n\r\n        for (var m = 0; m < firstRing.members.length; m++) {\r\n            let c = firstRing.members[m];\r\n\r\n            for (let n = 0; n < secondRing.members.length; n++) {\r\n                let d = secondRing.members[n];\r\n\r\n                if (c === d) {\r\n                    this.addVertex(c);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adding a vertex to the ring connection.\r\n     *\r\n     * @param {Number} vertexId A vertex id.\r\n     */\r\n    addVertex(vertexId) {\r\n        this.vertices.add(vertexId);\r\n    }\r\n\r\n    /**\r\n     * Update the ring id of this ring connection that is not the ring id supplied as the second argument.\r\n     *\r\n     * @param {Number} ringId A ring id. The new ring id to be set.\r\n     * @param {Number} otherRingId A ring id. The id that is NOT to be updated.\r\n     */\r\n    updateOther(ringId, otherRingId) {\r\n        if (this.firstRingId === otherRingId) {\r\n            this.secondRingId = ringId;\r\n        } else {\r\n            this.firstRingId = ringId;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean indicating whether or not a ring with a given id is participating in this ring connection.\r\n     * \r\n     * @param {Number} ringId A ring id.\r\n     * @returns {Boolean} A boolean indicating whether or not a ring with a given id participates in this ring connection.\r\n     */\r\n    containsRing(ringId) {\r\n        return this.firstRingId === ringId || this.secondRingId === ringId;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not this ring connection is a bridge in a bridged ring.\r\n     *\r\n     * @param {Vertex[]} vertices The array of vertices associated with the current molecule.\r\n     * @returns {Boolean} A boolean indicating whether or not this ring connection is a bridge.\r\n     */\r\n    isBridge(vertices) {\r\n      if (this.vertices.size > 2) {\r\n          return true;\r\n      }\r\n\r\n      for (let vertexId of this.vertices) {\r\n          if(vertices[vertexId].value.rings.length > 2) {\r\n              return true;\r\n          }\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not two rings are connected by a bridged bond.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing the ring connections associated with the current molecule.\r\n     * @param {Vertex[]} vertices An array of vertices containing the vertices associated with the current molecule.\r\n     * @param {Number} firstRingId A ring id.\r\n     * @param {Number} secondRingId A ring id.\r\n     * @returns {Boolean} A boolean indicating whether or not two rings ar connected by a bridged bond.\r\n     */\r\n    static isBridge(ringConnections, vertices, firstRingId, secondRingId) {\r\n      let ringConnection = null;\r\n      \r\n      for (let i = 0; i < ringConnections.length; i++) {\r\n          ringConnection = ringConnections[i];\r\n\r\n          if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId ||\r\n              ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {\r\n              return ringConnection.isBridge(vertices);\r\n          }\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Retruns the neighbouring rings of a given ring.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.\r\n     * @param {Number} ringId A ring id.\r\n     * @returns {Number[]} An array of ring ids of neighbouring rings.\r\n     */\r\n    static getNeighbours(ringConnections, ringId) {\r\n        let neighbours = [];\r\n\r\n        for (let i = 0; i < ringConnections.length; i++) {\r\n            let ringConnection = ringConnections[i];\r\n            \r\n            if (ringConnection.firstRingId === ringId) {\r\n                neighbours.push(ringConnection.secondRingId);\r\n            } else if (ringConnection.secondRingId === ringId) {\r\n                neighbours.push(ringConnection.firstRingId);\r\n            }\r\n        }\r\n\r\n        return neighbours;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of vertex ids associated with a given ring connection.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.\r\n     * @param {Number} firstRingId A ring id.\r\n     * @param {Number} secondRingId A ring id.\r\n     * @returns {Number[]} An array of vertex ids associated with the ring connection.\r\n     */\r\n    static getVertices(ringConnections, firstRingId, secondRingId) {\r\n        for (let i = 0; i < ringConnections.length; i++) {\r\n            let ringConnection = ringConnections[i];\r\n            if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId ||\r\n                ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {\r\n                return [...ringConnection.vertices];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = RingConnection"]},"metadata":{},"sourceType":"script"}