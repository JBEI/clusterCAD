{"ast":null,"code":"//@ts-check\nconst MathHelper = require('./MathHelper');\n\nconst ArrayHelper = require('./ArrayHelper');\n\nconst Vector2 = require('./Vector2');\n\nconst Atom = require('./Atom');\n/** \r\n * A class representing a vertex.\r\n * \r\n * @property {Number} id The id of this vertex.\r\n * @property {Atom} value The atom associated with this vertex.\r\n * @property {Vector2} position The position of this vertex.\r\n * @property {Vector2} previousPosition The position of the previous vertex.\r\n * @property {Number|null} parentVertexId The id of the previous vertex.\r\n * @property {Number[]} children The ids of the children of this vertex.\r\n * @property {Number[]} spanningTreeChildren The ids of the children of this vertex as defined in the spanning tree defined by the SMILES.\r\n * @property {Number[]} edges The ids of edges associated with this vertex.\r\n * @property {Boolean} positioned A boolean indicating whether or not this vertex has been positioned.\r\n * @property {Number} angle The angle of this vertex.\r\n * @property {Number} dir The direction of this vertex.\r\n * @property {Number} neighbourCount The number of neighbouring vertices.\r\n * @property {Number[]} neighbours The vertex ids of neighbouring vertices.\r\n * @property {String[]} neighbouringElements The element symbols associated with neighbouring vertices.\r\n * @property {Boolean} forcePositioned A boolean indicating whether or not this vertex was positioned using a force-based approach.\r\n */\n\n\nclass Vertex {\n  /**\r\n   * The constructor for the class Vertex.\r\n   *\r\n   * @param {Atom} value The value associated with this vertex.\r\n   * @param {Number} [x=0] The initial x coordinate of the positional vector of this vertex.\r\n   * @param {Number} [y=0] The initial y coordinate of the positional vector of this vertex.\r\n   */\n  constructor(value, x = 0, y = 0) {\n    this.id = null;\n    this.value = value;\n    this.position = new Vector2(x ? x : 0, y ? y : 0);\n    this.previousPosition = new Vector2(0, 0);\n    this.parentVertexId = null;\n    this.children = Array();\n    this.spanningTreeChildren = Array();\n    this.edges = Array();\n    this.positioned = false;\n    this.angle = null;\n    this.dir = 1.0;\n    this.neighbourCount = 0;\n    this.neighbours = Array();\n    this.neighbouringElements = Array();\n    this.forcePositioned = false;\n  }\n  /**\r\n   * Set the 2D coordinates of the vertex.\r\n   * \r\n   * @param {Number} x The x component of the coordinates.\r\n   * @param {Number} y The y component of the coordinates.\r\n   * \r\n   */\n\n\n  setPosition(x, y) {\n    this.position.x = x;\n    this.position.y = y;\n  }\n  /**\r\n   * Set the 2D coordinates of the vertex from a Vector2.\r\n   * \r\n   * @param {Vector2} v A 2D vector.\r\n   * \r\n   */\n\n\n  setPositionFromVector(v) {\n    this.position.x = v.x;\n    this.position.y = v.y;\n  }\n  /**\r\n   * Add a child vertex id to this vertex.\r\n   * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.\r\n   */\n\n\n  addChild(vertexId) {\n    this.children.push(vertexId);\n    this.neighbours.push(vertexId);\n    this.neighbourCount++;\n  }\n  /**\r\n   * Add a child vertex id to this vertex as the second child of the neighbours array,\r\n   * except this vertex is the first vertex of the SMILE string, then it is added as the first.\r\n   * This is used to get the correct ordering of neighbours for parity calculations.\r\n   * If a hydrogen is implicitly attached to the chiral center, insert as the third child.\r\n   * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.\r\n   * @param {Number} ringbondIndex The index of the ringbond.\r\n   */\n\n\n  addRingbondChild(vertexId, ringbondIndex) {\n    this.children.push(vertexId);\n\n    if (this.value.bracket) {\n      let index = 1;\n\n      if (this.id === 0 && this.value.bracket.hcount === 0) {\n        index = 0;\n      }\n\n      if (this.value.bracket.hcount === 1 && ringbondIndex === 0) {\n        index = 2;\n      }\n\n      if (this.value.bracket.hcount === 1 && ringbondIndex === 1) {\n        if (this.neighbours.length < 3) {\n          index = 2;\n        } else {\n          index = 3;\n        }\n      }\n\n      if (this.value.bracket.hcount === null && ringbondIndex === 0) {\n        index = 1;\n      }\n\n      if (this.value.bracket.hcount === null && ringbondIndex === 1) {\n        if (this.neighbours.length < 3) {\n          index = 1;\n        } else {\n          index = 2;\n        }\n      }\n\n      this.neighbours.splice(index, 0, vertexId);\n    } else {\n      this.neighbours.push(vertexId);\n    }\n\n    this.neighbourCount++;\n  }\n  /**\r\n   * Set the vertex id of the parent.\r\n   * \r\n   * @param {Number} parentVertexId The parents vertex id.\r\n   */\n\n\n  setParentVertexId(parentVertexId) {\n    this.neighbourCount++;\n    this.parentVertexId = parentVertexId;\n    this.neighbours.push(parentVertexId);\n  }\n  /**\r\n   * Returns true if this vertex is terminal (has no parent or child vertices), otherwise returns false. Always returns true if associated value has property hasAttachedPseudoElements set to true.\r\n   *\r\n   * @returns {Boolean} A boolean indicating whether or not this vertex is terminal.\r\n   */\n\n\n  isTerminal() {\n    if (this.value.hasAttachedPseudoElements) {\n      return true;\n    }\n\n    return this.parentVertexId === null && this.children.length < 2 || this.children.length === 0;\n  }\n  /**\r\n   * Clones this vertex and returns the clone.\r\n   *\r\n   * @returns {Vertex} A clone of this vertex.\r\n   */\n\n\n  clone() {\n    let clone = new Vertex(this.value, this.position.x, this.position.y);\n    clone.id = this.id;\n    clone.previousPosition = new Vector2(this.previousPosition.x, this.previousPosition.y);\n    clone.parentVertexId = this.parentVertexId;\n    clone.children = ArrayHelper.clone(this.children);\n    clone.spanningTreeChildren = ArrayHelper.clone(this.spanningTreeChildren);\n    clone.edges = ArrayHelper.clone(this.edges);\n    clone.positioned = this.positioned;\n    clone.angle = this.angle;\n    clone.forcePositioned = this.forcePositioned;\n    return clone;\n  }\n  /**\r\n   * Returns true if this vertex and the supplied vertex both have the same id, else returns false.\r\n   *\r\n   * @param {Vertex} vertex The vertex to check.\r\n   * @returns {Boolean} A boolean indicating whether or not the two vertices have the same id.\r\n   */\n\n\n  equals(vertex) {\n    return this.id === vertex.id;\n  }\n  /**\r\n   * Returns the angle of this vertexes positional vector. If a reference vector is supplied in relations to this vector, else in relations to the coordinate system.\r\n   *\r\n   * @param {Vector2} [referenceVector=null] - The reference vector.\r\n   * @param {Boolean} [returnAsDegrees=false] - If true, returns angle in degrees, else in radians.\r\n   * @returns {Number} The angle of this vertex.\r\n   */\n\n\n  getAngle(referenceVector = null, returnAsDegrees = false) {\n    let u = null;\n\n    if (!referenceVector) {\n      u = Vector2.subtract(this.position, this.previousPosition);\n    } else {\n      u = Vector2.subtract(this.position, referenceVector);\n    }\n\n    if (returnAsDegrees) {\n      return MathHelper.toDeg(u.angle());\n    }\n\n    return u.angle();\n  }\n  /**\r\n   * Returns the suggested text direction when text is added at the position of this vertex.\r\n   *\r\n   * @param {Vertex[]} vertices The array of vertices for the current molecule.\r\n   * @returns {String} The suggested direction of the text.\r\n   */\n\n\n  getTextDirection(vertices) {\n    let neighbours = this.getDrawnNeighbours(vertices);\n    let angles = Array();\n\n    for (let i = 0; i < neighbours.length; i++) {\n      angles.push(this.getAngle(vertices[neighbours[i]].position));\n    }\n\n    let textAngle = MathHelper.meanAngle(angles); // Round to 0, 90, 180 or 270 degree\n\n    let halfPi = Math.PI / 2.0;\n    textAngle = Math.round(Math.round(textAngle / halfPi) * halfPi);\n\n    if (textAngle === 2) {\n      return 'down';\n    } else if (textAngle === -2) {\n      return 'up';\n    } else if (textAngle === 0 || textAngle === -0) {\n      return 'right'; // is checking for -0 necessary?\n    } else if (textAngle === 3 || textAngle === -3) {\n      return 'left';\n    } else {\n      return 'down'; // default to down\n    }\n  }\n  /**\r\n   * Returns an array of ids of neighbouring vertices.\r\n   *\r\n   * @param {Number} [vertexId=null] If a value is supplied, the vertex with this id is excluded from the returned indices.\r\n   * @returns {Number[]} An array containing the ids of neighbouring vertices.\r\n   */\n\n\n  getNeighbours(vertexId = null) {\n    if (vertexId === null) {\n      return this.neighbours.slice();\n    }\n\n    let arr = Array();\n\n    for (let i = 0; i < this.neighbours.length; i++) {\n      if (this.neighbours[i] !== vertexId) {\n        arr.push(this.neighbours[i]);\n      }\n    }\n\n    return arr;\n  }\n  /**\r\n   * Returns an array of ids of neighbouring vertices that will be drawn (vertex.value.isDrawn === true).\r\n   * \r\n   * @param {Vertex[]} vertices An array containing the vertices associated with the current molecule.\r\n   * @returns {Number[]} An array containing the ids of neighbouring vertices that will be drawn.\r\n   */\n\n\n  getDrawnNeighbours(vertices) {\n    let arr = Array();\n\n    for (let i = 0; i < this.neighbours.length; i++) {\n      if (vertices[this.neighbours[i]].value.isDrawn) {\n        arr.push(this.neighbours[i]);\n      }\n    }\n\n    return arr;\n  }\n  /**\r\n   * Returns the number of neighbours of this vertex.\r\n   *\r\n   * @returns {Number} The number of neighbours.\r\n   */\n\n\n  getNeighbourCount() {\n    return this.neighbourCount;\n  }\n  /**\r\n   * Returns a list of ids of vertices neighbouring this one in the original spanning tree, excluding the ringbond connections.\r\n   *\r\n   * @param {Number} [vertexId=null] If supplied, the vertex with this id is excluded from the array returned.\r\n   * @returns {Number[]} An array containing the ids of the neighbouring vertices.\r\n   */\n\n\n  getSpanningTreeNeighbours(vertexId = null) {\n    let neighbours = Array();\n\n    for (let i = 0; i < this.spanningTreeChildren.length; i++) {\n      if (vertexId === undefined || vertexId != this.spanningTreeChildren[i]) {\n        neighbours.push(this.spanningTreeChildren[i]);\n      }\n    }\n\n    if (this.parentVertexId != null) {\n      if (vertexId === undefined || vertexId != this.parentVertexId) {\n        neighbours.push(this.parentVertexId);\n      }\n    }\n\n    return neighbours;\n  }\n  /**\r\n   * Gets the next vertex in the ring in opposide direction to the supplied vertex id.\r\n   *\r\n   * @param {Vertex[]} vertices The array of vertices for the current molecule.\r\n   * @param {Number} ringId The id of the ring containing this vertex.\r\n   * @param {Number} previousVertexId The id of the previous vertex. The next vertex will be opposite from the vertex with this id as seen from this vertex.\r\n   * @returns {Number} The id of the next vertex in the ring.\r\n   */\n\n\n  getNextInRing(vertices, ringId, previousVertexId) {\n    let neighbours = this.getNeighbours();\n\n    for (let i = 0; i < neighbours.length; i++) {\n      if (ArrayHelper.contains(vertices[neighbours[i]].value.rings, {\n        value: ringId\n      }) && neighbours[i] != previousVertexId) {\n        return neighbours[i];\n      }\n    }\n\n    return null;\n  }\n\n}\n\nmodule.exports = Vertex;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/smiles-drawer/src/Vertex.js"],"names":["MathHelper","require","ArrayHelper","Vector2","Atom","Vertex","constructor","value","x","y","id","position","previousPosition","parentVertexId","children","Array","spanningTreeChildren","edges","positioned","angle","dir","neighbourCount","neighbours","neighbouringElements","forcePositioned","setPosition","setPositionFromVector","v","addChild","vertexId","push","addRingbondChild","ringbondIndex","bracket","index","hcount","length","splice","setParentVertexId","isTerminal","hasAttachedPseudoElements","clone","equals","vertex","getAngle","referenceVector","returnAsDegrees","u","subtract","toDeg","getTextDirection","vertices","getDrawnNeighbours","angles","i","textAngle","meanAngle","halfPi","Math","PI","round","getNeighbours","slice","arr","isDrawn","getNeighbourCount","getSpanningTreeNeighbours","undefined","getNextInRing","ringId","previousVertexId","contains","rings","module","exports"],"mappings":"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","sourcesContent":["//@ts-check\r\nconst MathHelper = require('./MathHelper')\r\nconst ArrayHelper = require('./ArrayHelper')\r\nconst Vector2 = require('./Vector2')\r\nconst Atom = require('./Atom')\r\n\r\n/** \r\n * A class representing a vertex.\r\n * \r\n * @property {Number} id The id of this vertex.\r\n * @property {Atom} value The atom associated with this vertex.\r\n * @property {Vector2} position The position of this vertex.\r\n * @property {Vector2} previousPosition The position of the previous vertex.\r\n * @property {Number|null} parentVertexId The id of the previous vertex.\r\n * @property {Number[]} children The ids of the children of this vertex.\r\n * @property {Number[]} spanningTreeChildren The ids of the children of this vertex as defined in the spanning tree defined by the SMILES.\r\n * @property {Number[]} edges The ids of edges associated with this vertex.\r\n * @property {Boolean} positioned A boolean indicating whether or not this vertex has been positioned.\r\n * @property {Number} angle The angle of this vertex.\r\n * @property {Number} dir The direction of this vertex.\r\n * @property {Number} neighbourCount The number of neighbouring vertices.\r\n * @property {Number[]} neighbours The vertex ids of neighbouring vertices.\r\n * @property {String[]} neighbouringElements The element symbols associated with neighbouring vertices.\r\n * @property {Boolean} forcePositioned A boolean indicating whether or not this vertex was positioned using a force-based approach.\r\n */\r\n\r\nclass Vertex {\r\n  /**\r\n   * The constructor for the class Vertex.\r\n   *\r\n   * @param {Atom} value The value associated with this vertex.\r\n   * @param {Number} [x=0] The initial x coordinate of the positional vector of this vertex.\r\n   * @param {Number} [y=0] The initial y coordinate of the positional vector of this vertex.\r\n   */\r\n  constructor(value, x = 0, y = 0) {\r\n    this.id = null;\r\n    this.value = value;\r\n    this.position = new Vector2(x ? x : 0, y ? y : 0);\r\n    this.previousPosition = new Vector2(0, 0);\r\n    this.parentVertexId = null;\r\n    this.children = Array();\r\n    this.spanningTreeChildren = Array();\r\n    this.edges = Array();\r\n    this.positioned = false;\r\n    this.angle = null;\r\n    this.dir = 1.0;\r\n    this.neighbourCount = 0;\r\n    this.neighbours = Array();\r\n    this.neighbouringElements = Array();\r\n    this.forcePositioned = false;\r\n  }\r\n\r\n  /**\r\n   * Set the 2D coordinates of the vertex.\r\n   * \r\n   * @param {Number} x The x component of the coordinates.\r\n   * @param {Number} y The y component of the coordinates.\r\n   * \r\n   */\r\n  setPosition(x, y) {\r\n    this.position.x = x;\r\n    this.position.y = y;\r\n  }\r\n\r\n  /**\r\n   * Set the 2D coordinates of the vertex from a Vector2.\r\n   * \r\n   * @param {Vector2} v A 2D vector.\r\n   * \r\n   */\r\n  setPositionFromVector(v) {\r\n    this.position.x = v.x;\r\n    this.position.y = v.y;\r\n  }\r\n\r\n  /**\r\n   * Add a child vertex id to this vertex.\r\n   * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.\r\n   */\r\n  addChild(vertexId) {\r\n    this.children.push(vertexId);\r\n    this.neighbours.push(vertexId);\r\n\r\n    this.neighbourCount++;\r\n  }\r\n\r\n  /**\r\n   * Add a child vertex id to this vertex as the second child of the neighbours array,\r\n   * except this vertex is the first vertex of the SMILE string, then it is added as the first.\r\n   * This is used to get the correct ordering of neighbours for parity calculations.\r\n   * If a hydrogen is implicitly attached to the chiral center, insert as the third child.\r\n   * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.\r\n   * @param {Number} ringbondIndex The index of the ringbond.\r\n   */\r\n  addRingbondChild(vertexId, ringbondIndex) {\r\n    this.children.push(vertexId);\r\n\r\n    if (this.value.bracket) {\r\n      let index = 1;\r\n\r\n      if (this.id === 0 && this.value.bracket.hcount === 0) {\r\n        index = 0;\r\n      }\r\n      \r\n      if (this.value.bracket.hcount === 1 && ringbondIndex === 0) {\r\n        index = 2;\r\n      }\r\n\r\n      if (this.value.bracket.hcount === 1 && ringbondIndex === 1) {\r\n        if (this.neighbours.length < 3) {\r\n          index = 2;\r\n        } else {\r\n          index = 3;\r\n        }\r\n      }\r\n\r\n      if (this.value.bracket.hcount === null && ringbondIndex === 0) {\r\n        index = 1;\r\n      }\r\n\r\n      if (this.value.bracket.hcount === null && ringbondIndex === 1) {\r\n        if (this.neighbours.length < 3) {\r\n          index = 1;\r\n        } else {\r\n          index = 2;\r\n        }\r\n      }\r\n      \r\n      this.neighbours.splice(index, 0, vertexId);\r\n    } else {\r\n      this.neighbours.push(vertexId);\r\n    }\r\n\r\n    this.neighbourCount++;\r\n  }\r\n\r\n  /**\r\n   * Set the vertex id of the parent.\r\n   * \r\n   * @param {Number} parentVertexId The parents vertex id.\r\n   */\r\n  setParentVertexId(parentVertexId) {\r\n    this.neighbourCount++;\r\n    this.parentVertexId = parentVertexId;\r\n    this.neighbours.push(parentVertexId);\r\n  }\r\n\r\n  /**\r\n   * Returns true if this vertex is terminal (has no parent or child vertices), otherwise returns false. Always returns true if associated value has property hasAttachedPseudoElements set to true.\r\n   *\r\n   * @returns {Boolean} A boolean indicating whether or not this vertex is terminal.\r\n   */\r\n  isTerminal() {\r\n    if (this.value.hasAttachedPseudoElements) {\r\n      return true;\r\n    }\r\n\r\n    return (this.parentVertexId === null && this.children.length < 2) || this.children.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Clones this vertex and returns the clone.\r\n   *\r\n   * @returns {Vertex} A clone of this vertex.\r\n   */\r\n  clone() {\r\n    let clone = new Vertex(this.value, this.position.x, this.position.y);\r\n    clone.id = this.id;\r\n    clone.previousPosition = new Vector2(this.previousPosition.x, this.previousPosition.y);\r\n    clone.parentVertexId = this.parentVertexId;\r\n    clone.children = ArrayHelper.clone(this.children);\r\n    clone.spanningTreeChildren = ArrayHelper.clone(this.spanningTreeChildren);\r\n    clone.edges = ArrayHelper.clone(this.edges);\r\n    clone.positioned = this.positioned;\r\n    clone.angle = this.angle;\r\n    clone.forcePositioned = this.forcePositioned;\r\n    return clone;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this vertex and the supplied vertex both have the same id, else returns false.\r\n   *\r\n   * @param {Vertex} vertex The vertex to check.\r\n   * @returns {Boolean} A boolean indicating whether or not the two vertices have the same id.\r\n   */\r\n  equals(vertex) {\r\n    return this.id === vertex.id;\r\n  }\r\n\r\n  /**\r\n   * Returns the angle of this vertexes positional vector. If a reference vector is supplied in relations to this vector, else in relations to the coordinate system.\r\n   *\r\n   * @param {Vector2} [referenceVector=null] - The reference vector.\r\n   * @param {Boolean} [returnAsDegrees=false] - If true, returns angle in degrees, else in radians.\r\n   * @returns {Number} The angle of this vertex.\r\n   */\r\n  getAngle(referenceVector = null, returnAsDegrees = false) {\r\n    let u = null;\r\n\r\n    if (!referenceVector) {\r\n      u = Vector2.subtract(this.position, this.previousPosition);\r\n    } else {\r\n      u = Vector2.subtract(this.position, referenceVector);\r\n    }\r\n\r\n    if (returnAsDegrees) {\r\n      return MathHelper.toDeg(u.angle());\r\n    }\r\n\r\n    return u.angle();\r\n  }\r\n\r\n  /**\r\n   * Returns the suggested text direction when text is added at the position of this vertex.\r\n   *\r\n   * @param {Vertex[]} vertices The array of vertices for the current molecule.\r\n   * @returns {String} The suggested direction of the text.\r\n   */\r\n  getTextDirection(vertices) {\r\n    let neighbours = this.getDrawnNeighbours(vertices);\r\n    let angles = Array();\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      angles.push(this.getAngle(vertices[neighbours[i]].position));\r\n    }\r\n\r\n    let textAngle = MathHelper.meanAngle(angles);\r\n\r\n    // Round to 0, 90, 180 or 270 degree\r\n    let halfPi = Math.PI / 2.0;\r\n    textAngle = Math.round(Math.round(textAngle / halfPi) * halfPi);\r\n\r\n    if (textAngle === 2) {\r\n      return 'down';\r\n    } else if (textAngle === -2) {\r\n      return 'up';\r\n    } else if (textAngle === 0 || textAngle === -0) {\r\n      return 'right'; // is checking for -0 necessary?\r\n    } else if (textAngle === 3 || textAngle === -3) {\r\n      return 'left';\r\n    } else {\r\n      return 'down'; // default to down\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an array of ids of neighbouring vertices.\r\n   *\r\n   * @param {Number} [vertexId=null] If a value is supplied, the vertex with this id is excluded from the returned indices.\r\n   * @returns {Number[]} An array containing the ids of neighbouring vertices.\r\n   */\r\n  getNeighbours(vertexId = null) {\r\n    if (vertexId === null) {\r\n      return this.neighbours.slice();\r\n    }\r\n\r\n    let arr = Array();\r\n\r\n    for (let i = 0; i < this.neighbours.length; i++) {\r\n      if (this.neighbours[i] !== vertexId) {\r\n        arr.push(this.neighbours[i]);\r\n      }\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of ids of neighbouring vertices that will be drawn (vertex.value.isDrawn === true).\r\n   * \r\n   * @param {Vertex[]} vertices An array containing the vertices associated with the current molecule.\r\n   * @returns {Number[]} An array containing the ids of neighbouring vertices that will be drawn.\r\n   */\r\n  getDrawnNeighbours(vertices) {\r\n    let arr = Array();\r\n\r\n    for (let i = 0; i < this.neighbours.length; i++) {\r\n      if (vertices[this.neighbours[i]].value.isDrawn) {\r\n        arr.push(this.neighbours[i]);\r\n      }\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of neighbours of this vertex.\r\n   *\r\n   * @returns {Number} The number of neighbours.\r\n   */\r\n  getNeighbourCount() {\r\n    return this.neighbourCount;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of ids of vertices neighbouring this one in the original spanning tree, excluding the ringbond connections.\r\n   *\r\n   * @param {Number} [vertexId=null] If supplied, the vertex with this id is excluded from the array returned.\r\n   * @returns {Number[]} An array containing the ids of the neighbouring vertices.\r\n   */\r\n  getSpanningTreeNeighbours(vertexId = null) {\r\n    let neighbours = Array();\r\n\r\n    for (let i = 0; i < this.spanningTreeChildren.length; i++) {\r\n      if (vertexId === undefined || vertexId != this.spanningTreeChildren[i]) {\r\n        neighbours.push(this.spanningTreeChildren[i]);\r\n      }\r\n    }\r\n\r\n    if (this.parentVertexId != null) {\r\n      if (vertexId === undefined || vertexId != this.parentVertexId) {\r\n        neighbours.push(this.parentVertexId);\r\n      }\r\n    }\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  /**\r\n   * Gets the next vertex in the ring in opposide direction to the supplied vertex id.\r\n   *\r\n   * @param {Vertex[]} vertices The array of vertices for the current molecule.\r\n   * @param {Number} ringId The id of the ring containing this vertex.\r\n   * @param {Number} previousVertexId The id of the previous vertex. The next vertex will be opposite from the vertex with this id as seen from this vertex.\r\n   * @returns {Number} The id of the next vertex in the ring.\r\n   */\r\n  getNextInRing(vertices, ringId, previousVertexId) {\r\n    let neighbours = this.getNeighbours();\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (ArrayHelper.contains(vertices[neighbours[i]].value.rings, {\r\n          value: ringId\r\n        }) &&\r\n        neighbours[i] != previousVertexId) {\r\n        return neighbours[i];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nmodule.exports = Vertex;"]},"metadata":{},"sourceType":"script"}