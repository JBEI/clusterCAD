{"ast":null,"code":"var _classCallCheck = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n//@ts-check\nvar MathHelper = require('./MathHelper');\n\nvar ArrayHelper = require('./ArrayHelper');\n\nvar Vector2 = require('./Vector2');\n\nvar Atom = require('./Atom');\n/** \r\n * A class representing a vertex.\r\n * \r\n * @property {Number} id The id of this vertex.\r\n * @property {Atom} value The atom associated with this vertex.\r\n * @property {Vector2} position The position of this vertex.\r\n * @property {Vector2} previousPosition The position of the previous vertex.\r\n * @property {Number|null} parentVertexId The id of the previous vertex.\r\n * @property {Number[]} children The ids of the children of this vertex.\r\n * @property {Number[]} spanningTreeChildren The ids of the children of this vertex as defined in the spanning tree defined by the SMILES.\r\n * @property {Number[]} edges The ids of edges associated with this vertex.\r\n * @property {Boolean} positioned A boolean indicating whether or not this vertex has been positioned.\r\n * @property {Number} angle The angle of this vertex.\r\n * @property {Number} dir The direction of this vertex.\r\n * @property {Number} neighbourCount The number of neighbouring vertices.\r\n * @property {Number[]} neighbours The vertex ids of neighbouring vertices.\r\n * @property {String[]} neighbouringElements The element symbols associated with neighbouring vertices.\r\n * @property {Boolean} forcePositioned A boolean indicating whether or not this vertex was positioned using a force-based approach.\r\n */\n\n\nvar Vertex = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\r\n   * The constructor for the class Vertex.\r\n   *\r\n   * @param {Atom} value The value associated with this vertex.\r\n   * @param {Number} [x=0] The initial x coordinate of the positional vector of this vertex.\r\n   * @param {Number} [y=0] The initial y coordinate of the positional vector of this vertex.\r\n   */\n  function Vertex(value) {\n    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Vertex);\n\n    this.id = null;\n    this.value = value;\n    this.position = new Vector2(x ? x : 0, y ? y : 0);\n    this.previousPosition = new Vector2(0, 0);\n    this.parentVertexId = null;\n    this.children = Array();\n    this.spanningTreeChildren = Array();\n    this.edges = Array();\n    this.positioned = false;\n    this.angle = null;\n    this.dir = 1.0;\n    this.neighbourCount = 0;\n    this.neighbours = Array();\n    this.neighbouringElements = Array();\n    this.forcePositioned = false;\n  }\n  /**\r\n   * Set the 2D coordinates of the vertex.\r\n   * \r\n   * @param {Number} x The x component of the coordinates.\r\n   * @param {Number} y The y component of the coordinates.\r\n   * \r\n   */\n\n\n  _createClass(Vertex, [{\n    key: \"setPosition\",\n    value: function setPosition(x, y) {\n      this.position.x = x;\n      this.position.y = y;\n    }\n    /**\r\n     * Set the 2D coordinates of the vertex from a Vector2.\r\n     * \r\n     * @param {Vector2} v A 2D vector.\r\n     * \r\n     */\n\n  }, {\n    key: \"setPositionFromVector\",\n    value: function setPositionFromVector(v) {\n      this.position.x = v.x;\n      this.position.y = v.y;\n    }\n    /**\r\n     * Add a child vertex id to this vertex.\r\n     * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.\r\n     */\n\n  }, {\n    key: \"addChild\",\n    value: function addChild(vertexId) {\n      this.children.push(vertexId);\n      this.neighbours.push(vertexId);\n      this.neighbourCount++;\n    }\n    /**\r\n     * Add a child vertex id to this vertex as the second child of the neighbours array,\r\n     * except this vertex is the first vertex of the SMILE string, then it is added as the first.\r\n     * This is used to get the correct ordering of neighbours for parity calculations.\r\n     * If a hydrogen is implicitly attached to the chiral center, insert as the third child.\r\n     * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.\r\n     * @param {Number} ringbondIndex The index of the ringbond.\r\n     */\n\n  }, {\n    key: \"addRingbondChild\",\n    value: function addRingbondChild(vertexId, ringbondIndex) {\n      this.children.push(vertexId);\n\n      if (this.value.bracket) {\n        var index = 1;\n\n        if (this.id === 0 && this.value.bracket.hcount === 0) {\n          index = 0;\n        }\n\n        if (this.value.bracket.hcount === 1 && ringbondIndex === 0) {\n          index = 2;\n        }\n\n        if (this.value.bracket.hcount === 1 && ringbondIndex === 1) {\n          if (this.neighbours.length < 3) {\n            index = 2;\n          } else {\n            index = 3;\n          }\n        }\n\n        if (this.value.bracket.hcount === null && ringbondIndex === 0) {\n          index = 1;\n        }\n\n        if (this.value.bracket.hcount === null && ringbondIndex === 1) {\n          if (this.neighbours.length < 3) {\n            index = 1;\n          } else {\n            index = 2;\n          }\n        }\n\n        this.neighbours.splice(index, 0, vertexId);\n      } else {\n        this.neighbours.push(vertexId);\n      }\n\n      this.neighbourCount++;\n    }\n    /**\r\n     * Set the vertex id of the parent.\r\n     * \r\n     * @param {Number} parentVertexId The parents vertex id.\r\n     */\n\n  }, {\n    key: \"setParentVertexId\",\n    value: function setParentVertexId(parentVertexId) {\n      this.neighbourCount++;\n      this.parentVertexId = parentVertexId;\n      this.neighbours.push(parentVertexId);\n    }\n    /**\r\n     * Returns true if this vertex is terminal (has no parent or child vertices), otherwise returns false. Always returns true if associated value has property hasAttachedPseudoElements set to true.\r\n     *\r\n     * @returns {Boolean} A boolean indicating whether or not this vertex is terminal.\r\n     */\n\n  }, {\n    key: \"isTerminal\",\n    value: function isTerminal() {\n      if (this.value.hasAttachedPseudoElements) {\n        return true;\n      }\n\n      return this.parentVertexId === null && this.children.length < 2 || this.children.length === 0;\n    }\n    /**\r\n     * Clones this vertex and returns the clone.\r\n     *\r\n     * @returns {Vertex} A clone of this vertex.\r\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = new Vertex(this.value, this.position.x, this.position.y);\n      clone.id = this.id;\n      clone.previousPosition = new Vector2(this.previousPosition.x, this.previousPosition.y);\n      clone.parentVertexId = this.parentVertexId;\n      clone.children = ArrayHelper.clone(this.children);\n      clone.spanningTreeChildren = ArrayHelper.clone(this.spanningTreeChildren);\n      clone.edges = ArrayHelper.clone(this.edges);\n      clone.positioned = this.positioned;\n      clone.angle = this.angle;\n      clone.forcePositioned = this.forcePositioned;\n      return clone;\n    }\n    /**\r\n     * Returns true if this vertex and the supplied vertex both have the same id, else returns false.\r\n     *\r\n     * @param {Vertex} vertex The vertex to check.\r\n     * @returns {Boolean} A boolean indicating whether or not the two vertices have the same id.\r\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(vertex) {\n      return this.id === vertex.id;\n    }\n    /**\r\n     * Returns the angle of this vertexes positional vector. If a reference vector is supplied in relations to this vector, else in relations to the coordinate system.\r\n     *\r\n     * @param {Vector2} [referenceVector=null] - The reference vector.\r\n     * @param {Boolean} [returnAsDegrees=false] - If true, returns angle in degrees, else in radians.\r\n     * @returns {Number} The angle of this vertex.\r\n     */\n\n  }, {\n    key: \"getAngle\",\n    value: function getAngle() {\n      var referenceVector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var returnAsDegrees = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var u = null;\n\n      if (!referenceVector) {\n        u = Vector2.subtract(this.position, this.previousPosition);\n      } else {\n        u = Vector2.subtract(this.position, referenceVector);\n      }\n\n      if (returnAsDegrees) {\n        return MathHelper.toDeg(u.angle());\n      }\n\n      return u.angle();\n    }\n    /**\r\n     * Returns the suggested text direction when text is added at the position of this vertex.\r\n     *\r\n     * @param {Vertex[]} vertices The array of vertices for the current molecule.\r\n     * @returns {String} The suggested direction of the text.\r\n     */\n\n  }, {\n    key: \"getTextDirection\",\n    value: function getTextDirection(vertices) {\n      var neighbours = this.getDrawnNeighbours(vertices);\n      var angles = Array();\n\n      for (var i = 0; i < neighbours.length; i++) {\n        angles.push(this.getAngle(vertices[neighbours[i]].position));\n      }\n\n      var textAngle = MathHelper.meanAngle(angles); // Round to 0, 90, 180 or 270 degree\n\n      var halfPi = Math.PI / 2.0;\n      textAngle = Math.round(Math.round(textAngle / halfPi) * halfPi);\n\n      if (textAngle === 2) {\n        return 'down';\n      } else if (textAngle === -2) {\n        return 'up';\n      } else if (textAngle === 0 || textAngle === -0) {\n        return 'right'; // is checking for -0 necessary?\n      } else if (textAngle === 3 || textAngle === -3) {\n        return 'left';\n      } else {\n        return 'down'; // default to down\n      }\n    }\n    /**\r\n     * Returns an array of ids of neighbouring vertices.\r\n     *\r\n     * @param {Number} [vertexId=null] If a value is supplied, the vertex with this id is excluded from the returned indices.\r\n     * @returns {Number[]} An array containing the ids of neighbouring vertices.\r\n     */\n\n  }, {\n    key: \"getNeighbours\",\n    value: function getNeighbours() {\n      var vertexId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (vertexId === null) {\n        return this.neighbours.slice();\n      }\n\n      var arr = Array();\n\n      for (var i = 0; i < this.neighbours.length; i++) {\n        if (this.neighbours[i] !== vertexId) {\n          arr.push(this.neighbours[i]);\n        }\n      }\n\n      return arr;\n    }\n    /**\r\n     * Returns an array of ids of neighbouring vertices that will be drawn (vertex.value.isDrawn === true).\r\n     * \r\n     * @param {Vertex[]} vertices An array containing the vertices associated with the current molecule.\r\n     * @returns {Number[]} An array containing the ids of neighbouring vertices that will be drawn.\r\n     */\n\n  }, {\n    key: \"getDrawnNeighbours\",\n    value: function getDrawnNeighbours(vertices) {\n      var arr = Array();\n\n      for (var i = 0; i < this.neighbours.length; i++) {\n        if (vertices[this.neighbours[i]].value.isDrawn) {\n          arr.push(this.neighbours[i]);\n        }\n      }\n\n      return arr;\n    }\n    /**\r\n     * Returns the number of neighbours of this vertex.\r\n     *\r\n     * @returns {Number} The number of neighbours.\r\n     */\n\n  }, {\n    key: \"getNeighbourCount\",\n    value: function getNeighbourCount() {\n      return this.neighbourCount;\n    }\n    /**\r\n     * Returns a list of ids of vertices neighbouring this one in the original spanning tree, excluding the ringbond connections.\r\n     *\r\n     * @param {Number} [vertexId=null] If supplied, the vertex with this id is excluded from the array returned.\r\n     * @returns {Number[]} An array containing the ids of the neighbouring vertices.\r\n     */\n\n  }, {\n    key: \"getSpanningTreeNeighbours\",\n    value: function getSpanningTreeNeighbours() {\n      var vertexId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var neighbours = Array();\n\n      for (var i = 0; i < this.spanningTreeChildren.length; i++) {\n        if (vertexId === undefined || vertexId != this.spanningTreeChildren[i]) {\n          neighbours.push(this.spanningTreeChildren[i]);\n        }\n      }\n\n      if (this.parentVertexId != null) {\n        if (vertexId === undefined || vertexId != this.parentVertexId) {\n          neighbours.push(this.parentVertexId);\n        }\n      }\n\n      return neighbours;\n    }\n    /**\r\n     * Gets the next vertex in the ring in opposide direction to the supplied vertex id.\r\n     *\r\n     * @param {Vertex[]} vertices The array of vertices for the current molecule.\r\n     * @param {Number} ringId The id of the ring containing this vertex.\r\n     * @param {Number} previousVertexId The id of the previous vertex. The next vertex will be opposite from the vertex with this id as seen from this vertex.\r\n     * @returns {Number} The id of the next vertex in the ring.\r\n     */\n\n  }, {\n    key: \"getNextInRing\",\n    value: function getNextInRing(vertices, ringId, previousVertexId) {\n      var neighbours = this.getNeighbours();\n\n      for (var i = 0; i < neighbours.length; i++) {\n        if (ArrayHelper.contains(vertices[neighbours[i]].value.rings, {\n          value: ringId\n        }) && neighbours[i] != previousVertexId) {\n          return neighbours[i];\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return Vertex;\n}();\n\nmodule.exports = Vertex;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/smiles-drawer/src/Vertex.js"],"names":["MathHelper","require","ArrayHelper","Vector2","Atom","Vertex","value","x","y","id","position","previousPosition","parentVertexId","children","Array","spanningTreeChildren","edges","positioned","angle","dir","neighbourCount","neighbours","neighbouringElements","forcePositioned","v","vertexId","push","ringbondIndex","bracket","index","hcount","length","splice","hasAttachedPseudoElements","clone","vertex","referenceVector","returnAsDegrees","u","subtract","toDeg","vertices","getDrawnNeighbours","angles","i","getAngle","textAngle","meanAngle","halfPi","Math","PI","round","slice","arr","isDrawn","undefined","ringId","previousVertexId","getNeighbours","contains","rings","module","exports"],"mappings":"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","sourcesContent":["//@ts-check\r\nconst MathHelper = require('./MathHelper')\r\nconst ArrayHelper = require('./ArrayHelper')\r\nconst Vector2 = require('./Vector2')\r\nconst Atom = require('./Atom')\r\n\r\n/** \r\n * A class representing a vertex.\r\n * \r\n * @property {Number} id The id of this vertex.\r\n * @property {Atom} value The atom associated with this vertex.\r\n * @property {Vector2} position The position of this vertex.\r\n * @property {Vector2} previousPosition The position of the previous vertex.\r\n * @property {Number|null} parentVertexId The id of the previous vertex.\r\n * @property {Number[]} children The ids of the children of this vertex.\r\n * @property {Number[]} spanningTreeChildren The ids of the children of this vertex as defined in the spanning tree defined by the SMILES.\r\n * @property {Number[]} edges The ids of edges associated with this vertex.\r\n * @property {Boolean} positioned A boolean indicating whether or not this vertex has been positioned.\r\n * @property {Number} angle The angle of this vertex.\r\n * @property {Number} dir The direction of this vertex.\r\n * @property {Number} neighbourCount The number of neighbouring vertices.\r\n * @property {Number[]} neighbours The vertex ids of neighbouring vertices.\r\n * @property {String[]} neighbouringElements The element symbols associated with neighbouring vertices.\r\n * @property {Boolean} forcePositioned A boolean indicating whether or not this vertex was positioned using a force-based approach.\r\n */\r\n\r\nclass Vertex {\r\n  /**\r\n   * The constructor for the class Vertex.\r\n   *\r\n   * @param {Atom} value The value associated with this vertex.\r\n   * @param {Number} [x=0] The initial x coordinate of the positional vector of this vertex.\r\n   * @param {Number} [y=0] The initial y coordinate of the positional vector of this vertex.\r\n   */\r\n  constructor(value, x = 0, y = 0) {\r\n    this.id = null;\r\n    this.value = value;\r\n    this.position = new Vector2(x ? x : 0, y ? y : 0);\r\n    this.previousPosition = new Vector2(0, 0);\r\n    this.parentVertexId = null;\r\n    this.children = Array();\r\n    this.spanningTreeChildren = Array();\r\n    this.edges = Array();\r\n    this.positioned = false;\r\n    this.angle = null;\r\n    this.dir = 1.0;\r\n    this.neighbourCount = 0;\r\n    this.neighbours = Array();\r\n    this.neighbouringElements = Array();\r\n    this.forcePositioned = false;\r\n  }\r\n\r\n  /**\r\n   * Set the 2D coordinates of the vertex.\r\n   * \r\n   * @param {Number} x The x component of the coordinates.\r\n   * @param {Number} y The y component of the coordinates.\r\n   * \r\n   */\r\n  setPosition(x, y) {\r\n    this.position.x = x;\r\n    this.position.y = y;\r\n  }\r\n\r\n  /**\r\n   * Set the 2D coordinates of the vertex from a Vector2.\r\n   * \r\n   * @param {Vector2} v A 2D vector.\r\n   * \r\n   */\r\n  setPositionFromVector(v) {\r\n    this.position.x = v.x;\r\n    this.position.y = v.y;\r\n  }\r\n\r\n  /**\r\n   * Add a child vertex id to this vertex.\r\n   * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.\r\n   */\r\n  addChild(vertexId) {\r\n    this.children.push(vertexId);\r\n    this.neighbours.push(vertexId);\r\n\r\n    this.neighbourCount++;\r\n  }\r\n\r\n  /**\r\n   * Add a child vertex id to this vertex as the second child of the neighbours array,\r\n   * except this vertex is the first vertex of the SMILE string, then it is added as the first.\r\n   * This is used to get the correct ordering of neighbours for parity calculations.\r\n   * If a hydrogen is implicitly attached to the chiral center, insert as the third child.\r\n   * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.\r\n   * @param {Number} ringbondIndex The index of the ringbond.\r\n   */\r\n  addRingbondChild(vertexId, ringbondIndex) {\r\n    this.children.push(vertexId);\r\n\r\n    if (this.value.bracket) {\r\n      let index = 1;\r\n\r\n      if (this.id === 0 && this.value.bracket.hcount === 0) {\r\n        index = 0;\r\n      }\r\n      \r\n      if (this.value.bracket.hcount === 1 && ringbondIndex === 0) {\r\n        index = 2;\r\n      }\r\n\r\n      if (this.value.bracket.hcount === 1 && ringbondIndex === 1) {\r\n        if (this.neighbours.length < 3) {\r\n          index = 2;\r\n        } else {\r\n          index = 3;\r\n        }\r\n      }\r\n\r\n      if (this.value.bracket.hcount === null && ringbondIndex === 0) {\r\n        index = 1;\r\n      }\r\n\r\n      if (this.value.bracket.hcount === null && ringbondIndex === 1) {\r\n        if (this.neighbours.length < 3) {\r\n          index = 1;\r\n        } else {\r\n          index = 2;\r\n        }\r\n      }\r\n      \r\n      this.neighbours.splice(index, 0, vertexId);\r\n    } else {\r\n      this.neighbours.push(vertexId);\r\n    }\r\n\r\n    this.neighbourCount++;\r\n  }\r\n\r\n  /**\r\n   * Set the vertex id of the parent.\r\n   * \r\n   * @param {Number} parentVertexId The parents vertex id.\r\n   */\r\n  setParentVertexId(parentVertexId) {\r\n    this.neighbourCount++;\r\n    this.parentVertexId = parentVertexId;\r\n    this.neighbours.push(parentVertexId);\r\n  }\r\n\r\n  /**\r\n   * Returns true if this vertex is terminal (has no parent or child vertices), otherwise returns false. Always returns true if associated value has property hasAttachedPseudoElements set to true.\r\n   *\r\n   * @returns {Boolean} A boolean indicating whether or not this vertex is terminal.\r\n   */\r\n  isTerminal() {\r\n    if (this.value.hasAttachedPseudoElements) {\r\n      return true;\r\n    }\r\n\r\n    return (this.parentVertexId === null && this.children.length < 2) || this.children.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Clones this vertex and returns the clone.\r\n   *\r\n   * @returns {Vertex} A clone of this vertex.\r\n   */\r\n  clone() {\r\n    let clone = new Vertex(this.value, this.position.x, this.position.y);\r\n    clone.id = this.id;\r\n    clone.previousPosition = new Vector2(this.previousPosition.x, this.previousPosition.y);\r\n    clone.parentVertexId = this.parentVertexId;\r\n    clone.children = ArrayHelper.clone(this.children);\r\n    clone.spanningTreeChildren = ArrayHelper.clone(this.spanningTreeChildren);\r\n    clone.edges = ArrayHelper.clone(this.edges);\r\n    clone.positioned = this.positioned;\r\n    clone.angle = this.angle;\r\n    clone.forcePositioned = this.forcePositioned;\r\n    return clone;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this vertex and the supplied vertex both have the same id, else returns false.\r\n   *\r\n   * @param {Vertex} vertex The vertex to check.\r\n   * @returns {Boolean} A boolean indicating whether or not the two vertices have the same id.\r\n   */\r\n  equals(vertex) {\r\n    return this.id === vertex.id;\r\n  }\r\n\r\n  /**\r\n   * Returns the angle of this vertexes positional vector. If a reference vector is supplied in relations to this vector, else in relations to the coordinate system.\r\n   *\r\n   * @param {Vector2} [referenceVector=null] - The reference vector.\r\n   * @param {Boolean} [returnAsDegrees=false] - If true, returns angle in degrees, else in radians.\r\n   * @returns {Number} The angle of this vertex.\r\n   */\r\n  getAngle(referenceVector = null, returnAsDegrees = false) {\r\n    let u = null;\r\n\r\n    if (!referenceVector) {\r\n      u = Vector2.subtract(this.position, this.previousPosition);\r\n    } else {\r\n      u = Vector2.subtract(this.position, referenceVector);\r\n    }\r\n\r\n    if (returnAsDegrees) {\r\n      return MathHelper.toDeg(u.angle());\r\n    }\r\n\r\n    return u.angle();\r\n  }\r\n\r\n  /**\r\n   * Returns the suggested text direction when text is added at the position of this vertex.\r\n   *\r\n   * @param {Vertex[]} vertices The array of vertices for the current molecule.\r\n   * @returns {String} The suggested direction of the text.\r\n   */\r\n  getTextDirection(vertices) {\r\n    let neighbours = this.getDrawnNeighbours(vertices);\r\n    let angles = Array();\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      angles.push(this.getAngle(vertices[neighbours[i]].position));\r\n    }\r\n\r\n    let textAngle = MathHelper.meanAngle(angles);\r\n\r\n    // Round to 0, 90, 180 or 270 degree\r\n    let halfPi = Math.PI / 2.0;\r\n    textAngle = Math.round(Math.round(textAngle / halfPi) * halfPi);\r\n\r\n    if (textAngle === 2) {\r\n      return 'down';\r\n    } else if (textAngle === -2) {\r\n      return 'up';\r\n    } else if (textAngle === 0 || textAngle === -0) {\r\n      return 'right'; // is checking for -0 necessary?\r\n    } else if (textAngle === 3 || textAngle === -3) {\r\n      return 'left';\r\n    } else {\r\n      return 'down'; // default to down\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns an array of ids of neighbouring vertices.\r\n   *\r\n   * @param {Number} [vertexId=null] If a value is supplied, the vertex with this id is excluded from the returned indices.\r\n   * @returns {Number[]} An array containing the ids of neighbouring vertices.\r\n   */\r\n  getNeighbours(vertexId = null) {\r\n    if (vertexId === null) {\r\n      return this.neighbours.slice();\r\n    }\r\n\r\n    let arr = Array();\r\n\r\n    for (let i = 0; i < this.neighbours.length; i++) {\r\n      if (this.neighbours[i] !== vertexId) {\r\n        arr.push(this.neighbours[i]);\r\n      }\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of ids of neighbouring vertices that will be drawn (vertex.value.isDrawn === true).\r\n   * \r\n   * @param {Vertex[]} vertices An array containing the vertices associated with the current molecule.\r\n   * @returns {Number[]} An array containing the ids of neighbouring vertices that will be drawn.\r\n   */\r\n  getDrawnNeighbours(vertices) {\r\n    let arr = Array();\r\n\r\n    for (let i = 0; i < this.neighbours.length; i++) {\r\n      if (vertices[this.neighbours[i]].value.isDrawn) {\r\n        arr.push(this.neighbours[i]);\r\n      }\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of neighbours of this vertex.\r\n   *\r\n   * @returns {Number} The number of neighbours.\r\n   */\r\n  getNeighbourCount() {\r\n    return this.neighbourCount;\r\n  }\r\n\r\n  /**\r\n   * Returns a list of ids of vertices neighbouring this one in the original spanning tree, excluding the ringbond connections.\r\n   *\r\n   * @param {Number} [vertexId=null] If supplied, the vertex with this id is excluded from the array returned.\r\n   * @returns {Number[]} An array containing the ids of the neighbouring vertices.\r\n   */\r\n  getSpanningTreeNeighbours(vertexId = null) {\r\n    let neighbours = Array();\r\n\r\n    for (let i = 0; i < this.spanningTreeChildren.length; i++) {\r\n      if (vertexId === undefined || vertexId != this.spanningTreeChildren[i]) {\r\n        neighbours.push(this.spanningTreeChildren[i]);\r\n      }\r\n    }\r\n\r\n    if (this.parentVertexId != null) {\r\n      if (vertexId === undefined || vertexId != this.parentVertexId) {\r\n        neighbours.push(this.parentVertexId);\r\n      }\r\n    }\r\n\r\n    return neighbours;\r\n  }\r\n\r\n  /**\r\n   * Gets the next vertex in the ring in opposide direction to the supplied vertex id.\r\n   *\r\n   * @param {Vertex[]} vertices The array of vertices for the current molecule.\r\n   * @param {Number} ringId The id of the ring containing this vertex.\r\n   * @param {Number} previousVertexId The id of the previous vertex. The next vertex will be opposite from the vertex with this id as seen from this vertex.\r\n   * @returns {Number} The id of the next vertex in the ring.\r\n   */\r\n  getNextInRing(vertices, ringId, previousVertexId) {\r\n    let neighbours = this.getNeighbours();\r\n\r\n    for (let i = 0; i < neighbours.length; i++) {\r\n      if (ArrayHelper.contains(vertices[neighbours[i]].value.rings, {\r\n          value: ringId\r\n        }) &&\r\n        neighbours[i] != previousVertexId) {\r\n        return neighbours[i];\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nmodule.exports = Vertex;"]},"metadata":{},"sourceType":"script"}