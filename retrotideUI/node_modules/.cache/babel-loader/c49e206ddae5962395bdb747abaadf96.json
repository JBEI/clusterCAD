{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n//@ts-check\nvar Graph = require('./Graph');\n/** A class encapsulating the functionality to find the smallest set of smallest rings in a graph. */\n\n\nvar SSSR = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function SSSR() {\n    _classCallCheck(this, SSSR);\n  }\n\n  _createClass(SSSR, null, [{\n    key: \"getRings\",\n    value:\n    /**\r\n     * Returns an array containing arrays, each representing a ring from the smallest set of smallest rings in the graph.\r\n     * \r\n     * @param {Graph} graph A Graph object.\r\n     * @param {Boolean} [experimental=false] Whether or not to use experimental SSSR.\r\n     * @returns {Array[]} An array containing arrays, each representing a ring from the smallest set of smallest rings in the group.\r\n     */\n    function getRings(graph) {\n      var experimental = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var adjacencyMatrix = graph.getComponentsAdjacencyMatrix();\n\n      if (adjacencyMatrix.length === 0) {\n        return null;\n      }\n\n      var connectedComponents = Graph.getConnectedComponents(adjacencyMatrix);\n      var rings = Array();\n\n      for (var i = 0; i < connectedComponents.length; i++) {\n        var connectedComponent = connectedComponents[i];\n        var ccAdjacencyMatrix = graph.getSubgraphAdjacencyMatrix(_toConsumableArray(connectedComponent));\n        var arrBondCount = new Uint16Array(ccAdjacencyMatrix.length);\n        var arrRingCount = new Uint16Array(ccAdjacencyMatrix.length);\n\n        for (var j = 0; j < ccAdjacencyMatrix.length; j++) {\n          arrRingCount[j] = 0;\n          arrBondCount[j] = 0;\n\n          for (var k = 0; k < ccAdjacencyMatrix[j].length; k++) {\n            arrBondCount[j] += ccAdjacencyMatrix[j][k];\n          }\n        } // Get the edge number and the theoretical number of rings in SSSR\n\n\n        var nEdges = 0;\n\n        for (var j = 0; j < ccAdjacencyMatrix.length; j++) {\n          for (var k = j + 1; k < ccAdjacencyMatrix.length; k++) {\n            nEdges += ccAdjacencyMatrix[j][k];\n          }\n        }\n\n        var nSssr = nEdges - ccAdjacencyMatrix.length + 1; // console.log(nEdges, ccAdjacencyMatrix.length, nSssr);\n        // console.log(SSSR.getEdgeList(ccAdjacencyMatrix));\n        // console.log(ccAdjacencyMatrix);\n        // If all vertices have 3 incident edges, calculate with different formula (see Euler)\n\n        var allThree = true;\n\n        for (var j = 0; j < arrBondCount.length; j++) {\n          if (arrBondCount[j] !== 3) {\n            allThree = false;\n          }\n        }\n\n        if (allThree) {\n          nSssr = 2.0 + nEdges - ccAdjacencyMatrix.length;\n        } // All vertices are part of one ring if theres only one ring.\n\n\n        if (nSssr === 1) {\n          rings.push(_toConsumableArray(connectedComponent));\n          continue;\n        }\n\n        if (experimental) {\n          nSssr = 999;\n        }\n\n        var _SSSR$getPathIncluded = SSSR.getPathIncludedDistanceMatrices(ccAdjacencyMatrix),\n            d = _SSSR$getPathIncluded.d,\n            pe = _SSSR$getPathIncluded.pe,\n            pe_prime = _SSSR$getPathIncluded.pe_prime;\n\n        var c = SSSR.getRingCandidates(d, pe, pe_prime);\n        var sssr = SSSR.getSSSR(c, d, ccAdjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nSssr);\n\n        for (var j = 0; j < sssr.length; j++) {\n          var ring = Array(sssr[j].size);\n          var index = 0;\n\n          var _iterator = _createForOfIteratorHelper(sssr[j]),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var val = _step.value;\n              // Get the original id of the vertex back\n              ring[index++] = connectedComponent[val];\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          rings.push(ring);\n        }\n      } // So, for some reason, this would return three rings for C1CCCC2CC1CCCC2, which is wrong\n      // As I don't have time to fix this properly, it will stay in. I'm sorry next person who works\n      // on it. At that point it might be best to reimplement the whole SSSR thing...\n\n\n      return rings;\n    }\n    /**\r\n     * Creates a printable string from a matrix (2D array).\r\n     * \r\n     * @param {Array[]} matrix A 2D array.\r\n     * @returns {String} A string representing the matrix.\r\n     */\n\n  }, {\n    key: \"matrixToString\",\n    value: function matrixToString(matrix) {\n      var str = '';\n\n      for (var i = 0; i < matrix.length; i++) {\n        for (var j = 0; j < matrix[i].length; j++) {\n          str += matrix[i][j] + ' ';\n        }\n\n        str += '\\n';\n      }\n\n      return str;\n    }\n    /**\r\n     * Returnes the two path-included distance matrices used to find the sssr.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Object} The path-included distance matrices. { p1, p2 }\r\n     */\n\n  }, {\n    key: \"getPathIncludedDistanceMatrices\",\n    value: function getPathIncludedDistanceMatrices(adjacencyMatrix) {\n      var length = adjacencyMatrix.length;\n      var d = Array(length);\n      var pe = Array(length);\n      var pe_prime = Array(length);\n      var l = 0;\n      var m = 0;\n      var n = 0;\n      var i = length;\n\n      while (i--) {\n        d[i] = Array(length);\n        pe[i] = Array(length);\n        pe_prime[i] = Array(length);\n        var j = length;\n\n        while (j--) {\n          d[i][j] = i === j || adjacencyMatrix[i][j] === 1 ? adjacencyMatrix[i][j] : Number.POSITIVE_INFINITY;\n\n          if (d[i][j] === 1) {\n            pe[i][j] = [[[i, j]]];\n          } else {\n            pe[i][j] = Array();\n          }\n\n          pe_prime[i][j] = Array();\n        }\n      }\n\n      var k = length;\n      var j;\n\n      while (k--) {\n        i = length;\n\n        while (i--) {\n          j = length;\n\n          while (j--) {\n            var previousPathLength = d[i][j];\n            var newPathLength = d[i][k] + d[k][j];\n\n            if (previousPathLength > newPathLength) {\n              var l, m, n;\n\n              if (previousPathLength === newPathLength + 1) {\n                pe_prime[i][j] = [pe[i][j].length];\n                l = pe[i][j].length;\n\n                while (l--) {\n                  pe_prime[i][j][l] = [pe[i][j][l].length];\n                  m = pe[i][j][l].length;\n\n                  while (m--) {\n                    pe_prime[i][j][l][m] = [pe[i][j][l][m].length];\n                    n = pe[i][j][l][m].length;\n\n                    while (n--) {\n                      pe_prime[i][j][l][m][n] = [pe[i][j][l][m][0], pe[i][j][l][m][1]];\n                    }\n                  }\n                }\n              } else {\n                pe_prime[i][j] = Array();\n              }\n\n              d[i][j] = newPathLength;\n              pe[i][j] = [[]];\n              l = pe[i][k][0].length;\n\n              while (l--) {\n                pe[i][j][0].push(pe[i][k][0][l]);\n              }\n\n              l = pe[k][j][0].length;\n\n              while (l--) {\n                pe[i][j][0].push(pe[k][j][0][l]);\n              }\n            } else if (previousPathLength === newPathLength) {\n              if (pe[i][k].length && pe[k][j].length) {\n                var l;\n\n                if (pe[i][j].length) {\n                  var tmp = Array();\n                  l = pe[i][k][0].length;\n\n                  while (l--) {\n                    tmp.push(pe[i][k][0][l]);\n                  }\n\n                  l = pe[k][j][0].length;\n\n                  while (l--) {\n                    tmp.push(pe[k][j][0][l]);\n                  }\n\n                  pe[i][j].push(tmp);\n                } else {\n                  var _tmp = Array();\n\n                  l = pe[i][k][0].length;\n\n                  while (l--) {\n                    _tmp.push(pe[i][k][0][l]);\n                  }\n\n                  l = pe[k][j][0].length;\n\n                  while (l--) {\n                    _tmp.push(pe[k][j][0][l]);\n                  }\n\n                  pe[i][j][0] = _tmp;\n                }\n              }\n            } else if (previousPathLength === newPathLength - 1) {\n              var l;\n\n              if (pe_prime[i][j].length) {\n                var _tmp2 = Array();\n\n                l = pe[i][k][0].length;\n\n                while (l--) {\n                  _tmp2.push(pe[i][k][0][l]);\n                }\n\n                l = pe[k][j][0].length;\n\n                while (l--) {\n                  _tmp2.push(pe[k][j][0][l]);\n                }\n\n                pe_prime[i][j].push(_tmp2);\n              } else {\n                var _tmp3 = Array();\n\n                l = pe[i][k][0].length;\n\n                while (l--) {\n                  _tmp3.push(pe[i][k][0][l]);\n                }\n\n                l = pe[k][j][0].length;\n\n                while (l--) {\n                  _tmp3.push(pe[k][j][0][l]);\n                }\n\n                pe_prime[i][j][0] = _tmp3;\n              }\n            }\n          }\n        }\n      }\n\n      return {\n        d: d,\n        pe: pe,\n        pe_prime: pe_prime\n      };\n    }\n    /**\r\n     * Get the ring candidates from the path-included distance matrices.\r\n     * \r\n     * @param {Array[]} d The distance matrix.\r\n     * @param {Array[]} pe A matrix containing the shortest paths.\r\n     * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.\r\n     * @returns {Array[]} The ring candidates.\r\n     */\n\n  }, {\n    key: \"getRingCandidates\",\n    value: function getRingCandidates(d, pe, pe_prime) {\n      var length = d.length;\n      var candidates = Array();\n      var c = 0;\n\n      for (var i = 0; i < length; i++) {\n        for (var j = 0; j < length; j++) {\n          if (d[i][j] === 0 || pe[i][j].length === 1 && pe_prime[i][j] === 0) {\n            continue;\n          } else {\n            // c is the number of vertices in the cycle.\n            if (pe_prime[i][j].length !== 0) {\n              c = 2 * (d[i][j] + 0.5);\n            } else {\n              c = 2 * d[i][j];\n            }\n\n            if (c !== Infinity) {\n              candidates.push([c, pe[i][j], pe_prime[i][j]]);\n            }\n          }\n        }\n      } // Candidates have to be sorted by c\n\n\n      candidates.sort(function (a, b) {\n        return a[0] - b[0];\n      });\n      return candidates;\n    }\n    /**\r\n     * Searches the candidates for the smallest set of smallest rings.\r\n     * \r\n     * @param {Array[]} c The candidates.\r\n     * @param {Array[]} d The distance matrix.\r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @param {Array[]} pe A matrix containing the shortest paths.\r\n     * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.\r\n     * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.\r\n     * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.\r\n     * @param {Number} nsssr The theoretical number of rings in the graph.\r\n     * @returns {Set[]} The smallest set of smallest rings.\r\n     */\n\n  }, {\n    key: \"getSSSR\",\n    value: function getSSSR(c, d, adjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nsssr) {\n      var cSssr = Array();\n      var allBonds = Array();\n\n      for (var i = 0; i < c.length; i++) {\n        if (c[i][0] % 2 !== 0) {\n          for (var j = 0; j < c[i][2].length; j++) {\n            var bonds = c[i][1][0].concat(c[i][2][j]); // Some bonds are added twice, resulting in [[u, v], [u, v]] instead of [u, v].\n            // TODO: This is a workaround, fix later. Probably should be a set rather than an array, however the computational overhead\n            //       is probably bigger compared to leaving it like this.\n\n            for (var k = 0; k < bonds.length; k++) {\n              if (bonds[k][0].constructor === Array) bonds[k] = bonds[k][0];\n            }\n\n            var atoms = SSSR.bondsToAtoms(bonds);\n\n            if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {\n              cSssr.push(atoms);\n              allBonds = allBonds.concat(bonds);\n            }\n\n            if (cSssr.length > nsssr) {\n              return cSssr;\n            }\n          }\n        } else {\n          for (var _j = 0; _j < c[i][1].length - 1; _j++) {\n            var _bonds = c[i][1][_j].concat(c[i][1][_j + 1]); // Some bonds are added twice, resulting in [[u, v], [u, v]] instead of [u, v].\n            // TODO: This is a workaround, fix later. Probably should be a set rather than an array, however the computational overhead\n            //       is probably bigger compared to leaving it like this.\n\n\n            for (var k = 0; k < _bonds.length; k++) {\n              if (_bonds[k][0].constructor === Array) _bonds[k] = _bonds[k][0];\n            }\n\n            var _atoms = SSSR.bondsToAtoms(_bonds);\n\n            if (SSSR.getBondCount(_atoms, adjacencyMatrix) === _atoms.size && !SSSR.pathSetsContain(cSssr, _atoms, _bonds, allBonds, arrBondCount, arrRingCount)) {\n              cSssr.push(_atoms);\n              allBonds = allBonds.concat(_bonds);\n            }\n\n            if (cSssr.length > nsssr) {\n              return cSssr;\n            }\n          }\n        }\n      }\n\n      return cSssr;\n    }\n    /**\r\n     * Returns the number of edges in a graph defined by an adjacency matrix.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Number} The number of edges in the graph defined by the adjacency matrix.\r\n     */\n\n  }, {\n    key: \"getEdgeCount\",\n    value: function getEdgeCount(adjacencyMatrix) {\n      var edgeCount = 0;\n      var length = adjacencyMatrix.length;\n      var i = length - 1;\n\n      while (i--) {\n        var j = length;\n\n        while (j--) {\n          if (adjacencyMatrix[i][j] === 1) {\n            edgeCount++;\n          }\n        }\n      }\n\n      return edgeCount;\n    }\n    /**\r\n     * Returns an edge list constructed form an adjacency matrix.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Array[]} An edge list. E.g. [ [ 0, 1 ], ..., [ 16, 2 ] ]\r\n     */\n\n  }, {\n    key: \"getEdgeList\",\n    value: function getEdgeList(adjacencyMatrix) {\n      var length = adjacencyMatrix.length;\n      var edgeList = Array();\n      var i = length - 1;\n\n      while (i--) {\n        var j = length;\n\n        while (j--) {\n          if (adjacencyMatrix[i][j] === 1) {\n            edgeList.push([i, j]);\n          }\n        }\n      }\n\n      return edgeList;\n    }\n    /**\r\n     * Return a set of vertex indices contained in an array of bonds.\r\n     * \r\n     * @param {Array} bonds An array of bonds. A bond is defined as [ sourceVertexId, targetVertexId ].\r\n     * @returns {Set<Number>} An array of vertices.\r\n     */\n\n  }, {\n    key: \"bondsToAtoms\",\n    value: function bondsToAtoms(bonds) {\n      var atoms = new Set();\n      var i = bonds.length;\n\n      while (i--) {\n        atoms.add(bonds[i][0]);\n        atoms.add(bonds[i][1]);\n      }\n\n      return atoms;\n    }\n    /**\r\n    * Returns the number of bonds within a set of atoms.\r\n    * \r\n    * @param {Set<Number>} atoms An array of atom ids.\r\n    * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n    * @returns {Number} The number of bonds in a set of atoms.\r\n    */\n\n  }, {\n    key: \"getBondCount\",\n    value: function getBondCount(atoms, adjacencyMatrix) {\n      var count = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(atoms),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var u = _step2.value;\n\n          var _iterator3 = _createForOfIteratorHelper(atoms),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var v = _step3.value;\n\n              if (u === v) {\n                continue;\n              }\n\n              count += adjacencyMatrix[u][v];\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return count / 2;\n    }\n    /**\r\n     * Checks whether or not a given path already exists in an array of paths.\r\n     * \r\n     * @param {Set[]} pathSets An array of sets each representing a path.\r\n     * @param {Set<Number>} pathSet A set representing a path.\r\n     * @param {Array[]} bonds The bonds associated with the current path.\r\n     * @param {Array[]} allBonds All bonds currently associated with rings in the SSSR set.\r\n     * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.\r\n     * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.\r\n     * @returns {Boolean} A boolean indicating whether or not a give path is contained within a set.\r\n     */\n\n  }, {\n    key: \"pathSetsContain\",\n    value: function pathSetsContain(pathSets, pathSet, bonds, allBonds, arrBondCount, arrRingCount) {\n      var i = pathSets.length;\n\n      while (i--) {\n        if (SSSR.isSupersetOf(pathSet, pathSets[i])) {\n          return true;\n        }\n\n        if (pathSets[i].size !== pathSet.size) {\n          continue;\n        }\n\n        if (SSSR.areSetsEqual(pathSets[i], pathSet)) {\n          return true;\n        }\n      } // Check if the edges from the candidate are already all contained within the paths of the set of paths.\n      // TODO: For some reason, this does not replace the isSupersetOf method above -> why?\n\n\n      var count = 0;\n      var allContained = false;\n      i = bonds.length;\n\n      while (i--) {\n        var j = allBonds.length;\n\n        while (j--) {\n          if (bonds[i][0] === allBonds[j][0] && bonds[i][1] === allBonds[j][1] || bonds[i][1] === allBonds[j][0] && bonds[i][0] === allBonds[j][1]) {\n            count++;\n          }\n\n          if (count === bonds.length) {\n            allContained = true;\n          }\n        }\n      } // If all the bonds and thus vertices are already contained within other rings\n      // check if there's one vertex with ringCount < bondCount\n\n\n      var specialCase = false;\n\n      if (allContained) {\n        var _iterator4 = _createForOfIteratorHelper(pathSet),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var element = _step4.value;\n\n            if (arrRingCount[element] < arrBondCount[element]) {\n              specialCase = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      if (allContained && !specialCase) {\n        return true;\n      } // Update the ring counts for the vertices\n\n\n      var _iterator5 = _createForOfIteratorHelper(pathSet),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _element = _step5.value;\n          arrRingCount[_element]++;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks whether or not two sets are equal (contain the same elements).\r\n     * \r\n     * @param {Set<Number>} setA A set.\r\n     * @param {Set<Number>} setB A set.\r\n     * @returns {Boolean} A boolean indicating whether or not the two sets are equal.\r\n     */\n\n  }, {\n    key: \"areSetsEqual\",\n    value: function areSetsEqual(setA, setB) {\n      if (setA.size !== setB.size) {\n        return false;\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(setA),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var element = _step6.value;\n\n          if (!setB.has(element)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return true;\n    }\n    /**\r\n     * Checks whether or not a set (setA) is a superset of another set (setB).\r\n     * \r\n     * @param {Set<Number>} setA A set.\r\n     * @param {Set<Number>} setB A set.\r\n     * @returns {Boolean} A boolean indicating whether or not setB is a superset of setA.\r\n     */\n\n  }, {\n    key: \"isSupersetOf\",\n    value: function isSupersetOf(setA, setB) {\n      var _iterator7 = _createForOfIteratorHelper(setB),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var element = _step7.value;\n\n          if (!setA.has(element)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return true;\n    }\n  }]);\n\n  return SSSR;\n}();\n\nmodule.exports = SSSR;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/smiles-drawer/src/SSSR.js"],"names":["Graph","require","SSSR","graph","experimental","adjacencyMatrix","getComponentsAdjacencyMatrix","length","connectedComponents","getConnectedComponents","rings","Array","i","connectedComponent","ccAdjacencyMatrix","getSubgraphAdjacencyMatrix","arrBondCount","Uint16Array","arrRingCount","j","k","nEdges","nSssr","allThree","push","getPathIncludedDistanceMatrices","d","pe","pe_prime","c","getRingCandidates","sssr","getSSSR","ring","size","index","val","matrix","str","l","m","n","Number","POSITIVE_INFINITY","previousPathLength","newPathLength","tmp","candidates","Infinity","sort","a","b","nsssr","cSssr","allBonds","bonds","concat","constructor","atoms","bondsToAtoms","getBondCount","pathSetsContain","edgeCount","edgeList","Set","add","count","u","v","pathSets","pathSet","isSupersetOf","areSetsEqual","allContained","specialCase","element","setA","setB","has","module","exports"],"mappings":"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","sourcesContent":["//@ts-check\r\nconst Graph = require('./Graph')\r\n\r\n/** A class encapsulating the functionality to find the smallest set of smallest rings in a graph. */\r\nclass SSSR {\r\n    /**\r\n     * Returns an array containing arrays, each representing a ring from the smallest set of smallest rings in the graph.\r\n     * \r\n     * @param {Graph} graph A Graph object.\r\n     * @param {Boolean} [experimental=false] Whether or not to use experimental SSSR.\r\n     * @returns {Array[]} An array containing arrays, each representing a ring from the smallest set of smallest rings in the group.\r\n     */\r\n    static getRings(graph, experimental=false) {\r\n        let adjacencyMatrix = graph.getComponentsAdjacencyMatrix();\r\n        if (adjacencyMatrix.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        let connectedComponents = Graph.getConnectedComponents(adjacencyMatrix);\r\n        let rings = Array();\r\n\r\n        for (var i = 0; i < connectedComponents.length; i++) {\r\n            let connectedComponent = connectedComponents[i];\r\n            let ccAdjacencyMatrix = graph.getSubgraphAdjacencyMatrix([...connectedComponent]);\r\n\r\n            let arrBondCount = new Uint16Array(ccAdjacencyMatrix.length);\r\n            let arrRingCount = new Uint16Array(ccAdjacencyMatrix.length);\r\n\r\n            for (var j = 0; j < ccAdjacencyMatrix.length; j++) {\r\n                arrRingCount[j] = 0;\r\n                arrBondCount[j] = 0;\r\n\r\n                for (var k = 0; k < ccAdjacencyMatrix[j].length; k++) {\r\n                    arrBondCount[j] += ccAdjacencyMatrix[j][k];\r\n                }\r\n            }\r\n\r\n            // Get the edge number and the theoretical number of rings in SSSR\r\n            let nEdges = 0;\r\n\r\n            for (var j = 0; j < ccAdjacencyMatrix.length; j++) {\r\n                for (var k = j + 1; k < ccAdjacencyMatrix.length; k++) {\r\n                    nEdges += ccAdjacencyMatrix[j][k];\r\n                }\r\n            }\r\n\r\n            let nSssr = nEdges - ccAdjacencyMatrix.length + 1;\r\n\r\n            // console.log(nEdges, ccAdjacencyMatrix.length, nSssr);\r\n            // console.log(SSSR.getEdgeList(ccAdjacencyMatrix));\r\n            // console.log(ccAdjacencyMatrix);\r\n\r\n            // If all vertices have 3 incident edges, calculate with different formula (see Euler)\r\n            let allThree = true;\r\n            for (var j = 0; j < arrBondCount.length; j++) {\r\n                if (arrBondCount[j] !== 3) {\r\n                    allThree = false;\r\n                }\r\n            }\r\n\r\n            if (allThree) {\r\n                nSssr = 2.0 + nEdges - ccAdjacencyMatrix.length;\r\n            }\r\n\r\n            // All vertices are part of one ring if theres only one ring.\r\n            if (nSssr === 1) {\r\n                rings.push([...connectedComponent]);\r\n                continue;\r\n            }\r\n            \r\n            if (experimental) {\r\n                nSssr = 999;\r\n            }\r\n\r\n            let { d, pe, pe_prime } = SSSR.getPathIncludedDistanceMatrices(ccAdjacencyMatrix);\r\n            let c = SSSR.getRingCandidates(d, pe, pe_prime);\r\n            let sssr = SSSR.getSSSR(c, d, ccAdjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nSssr);\r\n\r\n            for (var j = 0; j < sssr.length; j++) {\r\n                let ring = Array(sssr[j].size);\r\n                let index = 0;\r\n\r\n                for (let val of sssr[j]) {\r\n                    // Get the original id of the vertex back\r\n                    ring[index++] = connectedComponent[val];\r\n                }\r\n\r\n                rings.push(ring);\r\n            }\r\n        }\r\n        \r\n\r\n        // So, for some reason, this would return three rings for C1CCCC2CC1CCCC2, which is wrong\r\n        // As I don't have time to fix this properly, it will stay in. I'm sorry next person who works\r\n        // on it. At that point it might be best to reimplement the whole SSSR thing...\r\n        return rings;\r\n    }\r\n\r\n    /**\r\n     * Creates a printable string from a matrix (2D array).\r\n     * \r\n     * @param {Array[]} matrix A 2D array.\r\n     * @returns {String} A string representing the matrix.\r\n     */\r\n    static matrixToString(matrix) {\r\n        let str = '';\r\n\r\n        for (var i = 0; i < matrix.length; i++) {\r\n            for (var j = 0; j < matrix[i].length; j++) {\r\n                str += matrix[i][j] + ' ';\r\n            }\r\n\r\n            str += '\\n';\r\n        }\r\n\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * Returnes the two path-included distance matrices used to find the sssr.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Object} The path-included distance matrices. { p1, p2 }\r\n     */\r\n    static getPathIncludedDistanceMatrices(adjacencyMatrix) {\r\n        let length = adjacencyMatrix.length;\r\n        let d = Array(length);\r\n        let pe = Array(length);\r\n        let pe_prime = Array(length);\r\n        var l = 0;\r\n        var m = 0;\r\n        var n = 0;\r\n\r\n        var i = length;\r\n        while (i--) {\r\n            d[i] = Array(length);\r\n            pe[i] = Array(length);\r\n            pe_prime[i] = Array(length);\r\n\r\n            var j = length;\r\n            while (j--) {\r\n                d[i][j] = (i === j || adjacencyMatrix[i][j] === 1) ? adjacencyMatrix[i][j] : Number.POSITIVE_INFINITY;\r\n\r\n                if (d[i][j] === 1) {\r\n                    pe[i][j] = [[[i, j]]];\r\n                } else {\r\n                    pe[i][j] = Array();\r\n                }\r\n\r\n                pe_prime[i][j] = Array();\r\n            }\r\n        }\r\n\r\n        var k = length;\r\n        var j;\r\n        while (k--) {\r\n            i = length;\r\n            while (i--) {\r\n                j = length;\r\n                while (j--) {\r\n                    const previousPathLength = d[i][j];\r\n                    const newPathLength = d[i][k] + d[k][j];\r\n\r\n                    if (previousPathLength > newPathLength) {\r\n                        var l, m, n;\r\n                        if (previousPathLength === newPathLength + 1) {\r\n                            pe_prime[i][j] = [pe[i][j].length];\r\n                            l = pe[i][j].length\r\n                            while (l--) {\r\n                                pe_prime[i][j][l] = [pe[i][j][l].length];\r\n                                m = pe[i][j][l].length\r\n                                while (m--) {\r\n                                    pe_prime[i][j][l][m] = [pe[i][j][l][m].length];\r\n                                    n = pe[i][j][l][m].length;\r\n                                    while (n--) {\r\n                                        pe_prime[i][j][l][m][n] = [pe[i][j][l][m][0], pe[i][j][l][m][1]];\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            pe_prime[i][j] = Array();\r\n                        }\r\n\r\n                        d[i][j] = newPathLength;\r\n\r\n                        pe[i][j] = [[]];\r\n\r\n                        l = pe[i][k][0].length;\r\n                        while (l--) {\r\n                            pe[i][j][0].push(pe[i][k][0][l]);\r\n                        }\r\n\r\n                        l = pe[k][j][0].length;\r\n                        while (l--) {\r\n                            pe[i][j][0].push(pe[k][j][0][l]);\r\n                        }\r\n                    } else if (previousPathLength === newPathLength) {\r\n                        if (pe[i][k].length && pe[k][j].length) {\r\n                            var l;\r\n                            if (pe[i][j].length) {\r\n                                let tmp = Array();\r\n\r\n                                l = pe[i][k][0].length;\r\n                                while (l--) {\r\n                                    tmp.push(pe[i][k][0][l]);\r\n                                }\r\n\r\n                                l = pe[k][j][0].length;\r\n                                while (l--) {\r\n                                    tmp.push(pe[k][j][0][l]);\r\n                                }\r\n\r\n                                pe[i][j].push(tmp);\r\n                            } else {\r\n                                let tmp = Array();\r\n                                l = pe[i][k][0].length;\r\n                                while (l--) {\r\n                                    tmp.push(pe[i][k][0][l]);\r\n                                }\r\n\r\n                                l = pe[k][j][0].length;\r\n                                while (l--) {\r\n                                    tmp.push(pe[k][j][0][l]);\r\n                                }\r\n\r\n                                pe[i][j][0] = tmp\r\n                            }\r\n                        }\r\n                    } else if (previousPathLength === newPathLength - 1) {\r\n                        var l;\r\n                        if (pe_prime[i][j].length) {\r\n                            let tmp = Array();\r\n\r\n                            l = pe[i][k][0].length;\r\n                            while (l--) {\r\n                                tmp.push(pe[i][k][0][l]);\r\n                            }\r\n\r\n                            l = pe[k][j][0].length;\r\n                            while (l--) {\r\n                                tmp.push(pe[k][j][0][l]);\r\n                            }\r\n\r\n                            pe_prime[i][j].push(tmp);\r\n                        } else {\r\n                            let tmp = Array();\r\n\r\n                            l = pe[i][k][0].length;\r\n                            while (l--) {\r\n                                tmp.push(pe[i][k][0][l]);\r\n                            }\r\n\r\n                            l = pe[k][j][0].length;\r\n                            while (l--) {\r\n                                tmp.push(pe[k][j][0][l]);\r\n                            }\r\n\r\n                            pe_prime[i][j][0] = tmp;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            d: d,\r\n            pe: pe,\r\n            pe_prime: pe_prime\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the ring candidates from the path-included distance matrices.\r\n     * \r\n     * @param {Array[]} d The distance matrix.\r\n     * @param {Array[]} pe A matrix containing the shortest paths.\r\n     * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.\r\n     * @returns {Array[]} The ring candidates.\r\n     */\r\n    static getRingCandidates(d, pe, pe_prime) {\r\n        let length = d.length;\r\n        let candidates = Array();\r\n        let c = 0;\r\n\r\n        for (let i = 0; i < length; i++) {\r\n            for (let j = 0; j < length; j++) {\r\n                if (d[i][j] === 0 || (pe[i][j].length === 1 && pe_prime[i][j] === 0)) {\r\n                    continue;\r\n                } else {\r\n                    // c is the number of vertices in the cycle.\r\n                    if (pe_prime[i][j].length !== 0) {\r\n                        c = 2 * (d[i][j] + 0.5);\r\n                    } else {\r\n                        c = 2 * d[i][j];\r\n                    }\r\n\r\n                    if (c !== Infinity) {\r\n                        candidates.push([c, pe[i][j], pe_prime[i][j]]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Candidates have to be sorted by c\r\n        candidates.sort(function (a, b) {\r\n            return a[0] - b[0];\r\n        });\r\n\r\n        return candidates;\r\n    }\r\n\r\n    /**\r\n     * Searches the candidates for the smallest set of smallest rings.\r\n     * \r\n     * @param {Array[]} c The candidates.\r\n     * @param {Array[]} d The distance matrix.\r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @param {Array[]} pe A matrix containing the shortest paths.\r\n     * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.\r\n     * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.\r\n     * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.\r\n     * @param {Number} nsssr The theoretical number of rings in the graph.\r\n     * @returns {Set[]} The smallest set of smallest rings.\r\n     */\r\n    static getSSSR(c, d, adjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nsssr) {\r\n        let cSssr = Array();\r\n        let allBonds = Array();\r\n\r\n        for (let i = 0; i < c.length; i++) {\r\n            if (c[i][0] % 2 !== 0) {\r\n                for (let j = 0; j < c[i][2].length; j++) {\r\n                    let bonds = c[i][1][0].concat(c[i][2][j]);\r\n                    // Some bonds are added twice, resulting in [[u, v], [u, v]] instead of [u, v].\r\n                    // TODO: This is a workaround, fix later. Probably should be a set rather than an array, however the computational overhead\r\n                    //       is probably bigger compared to leaving it like this.\r\n                    for (var k = 0; k < bonds.length; k++) {\r\n                        if (bonds[k][0].constructor === Array) bonds[k] = bonds[k][0];\r\n                    }\r\n\r\n                    let atoms = SSSR.bondsToAtoms(bonds);\r\n\r\n                    if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {\r\n                        cSssr.push(atoms);\r\n                        allBonds = allBonds.concat(bonds);\r\n                    }\r\n\r\n                    if (cSssr.length > nsssr) {\r\n                        return cSssr;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let j = 0; j < c[i][1].length - 1; j++) {\r\n                    let bonds = c[i][1][j].concat(c[i][1][j + 1]);\r\n                    // Some bonds are added twice, resulting in [[u, v], [u, v]] instead of [u, v].\r\n                    // TODO: This is a workaround, fix later. Probably should be a set rather than an array, however the computational overhead\r\n                    //       is probably bigger compared to leaving it like this.\r\n                    for (var k = 0; k < bonds.length; k++) {\r\n                        if (bonds[k][0].constructor === Array) bonds[k] = bonds[k][0];\r\n                    }\r\n\r\n                    let atoms = SSSR.bondsToAtoms(bonds);\r\n\r\n                    if (SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !SSSR.pathSetsContain(cSssr, atoms, bonds, allBonds, arrBondCount, arrRingCount)) {\r\n                        cSssr.push(atoms);\r\n                        allBonds = allBonds.concat(bonds);\r\n                    }\r\n\r\n                    if (cSssr.length > nsssr) {\r\n                        return cSssr;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return cSssr;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of edges in a graph defined by an adjacency matrix.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Number} The number of edges in the graph defined by the adjacency matrix.\r\n     */\r\n    static getEdgeCount(adjacencyMatrix) {\r\n        let edgeCount = 0;\r\n        let length = adjacencyMatrix.length;\r\n\r\n        var i = length - 1;\r\n        while (i--) {\r\n            var j = length;\r\n            while (j--) {\r\n                if (adjacencyMatrix[i][j] === 1) {\r\n                    edgeCount++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return edgeCount;\r\n    }\r\n\r\n    /**\r\n     * Returns an edge list constructed form an adjacency matrix.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Array[]} An edge list. E.g. [ [ 0, 1 ], ..., [ 16, 2 ] ]\r\n     */\r\n    static getEdgeList(adjacencyMatrix) {\r\n        let length = adjacencyMatrix.length;\r\n        let edgeList = Array();\r\n\r\n        var i = length - 1;\r\n        while (i--) {\r\n            var j = length;\r\n            while (j--) {\r\n                if (adjacencyMatrix[i][j] === 1) {\r\n                    edgeList.push([i, j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return edgeList;\r\n    }\r\n\r\n    /**\r\n     * Return a set of vertex indices contained in an array of bonds.\r\n     * \r\n     * @param {Array} bonds An array of bonds. A bond is defined as [ sourceVertexId, targetVertexId ].\r\n     * @returns {Set<Number>} An array of vertices.\r\n     */\r\n    static bondsToAtoms(bonds) {\r\n        let atoms = new Set();\r\n\r\n        var i = bonds.length;\r\n        while (i--) {\r\n            atoms.add(bonds[i][0]);\r\n            atoms.add(bonds[i][1]);\r\n        }\r\n        return atoms;\r\n    }\r\n\r\n    /**\r\n    * Returns the number of bonds within a set of atoms.\r\n    * \r\n    * @param {Set<Number>} atoms An array of atom ids.\r\n    * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n    * @returns {Number} The number of bonds in a set of atoms.\r\n    */\r\n    static getBondCount(atoms, adjacencyMatrix) {\r\n        let count = 0;\r\n        for (let u of atoms) {\r\n            for (let v of atoms) {\r\n                if (u === v) {\r\n                    continue;\r\n                }\r\n                count += adjacencyMatrix[u][v]\r\n            }\r\n        }\r\n\r\n        return count / 2;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not a given path already exists in an array of paths.\r\n     * \r\n     * @param {Set[]} pathSets An array of sets each representing a path.\r\n     * @param {Set<Number>} pathSet A set representing a path.\r\n     * @param {Array[]} bonds The bonds associated with the current path.\r\n     * @param {Array[]} allBonds All bonds currently associated with rings in the SSSR set.\r\n     * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.\r\n     * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.\r\n     * @returns {Boolean} A boolean indicating whether or not a give path is contained within a set.\r\n     */\r\n    static pathSetsContain(pathSets, pathSet, bonds, allBonds, arrBondCount, arrRingCount) {\r\n        var i = pathSets.length;\r\n        while (i--) {\r\n            if (SSSR.isSupersetOf(pathSet, pathSets[i])) {\r\n                return true;\r\n            }\r\n\r\n            if (pathSets[i].size !== pathSet.size) {\r\n                continue;\r\n            }\r\n\r\n            if (SSSR.areSetsEqual(pathSets[i], pathSet)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // Check if the edges from the candidate are already all contained within the paths of the set of paths.\r\n        // TODO: For some reason, this does not replace the isSupersetOf method above -> why?\r\n        let count = 0;\r\n        let allContained = false;\r\n        i = bonds.length;\r\n        while (i--) {\r\n            var j = allBonds.length;\r\n            while (j--) {\r\n                if (bonds[i][0] === allBonds[j][0] && bonds[i][1] === allBonds[j][1] ||\r\n                    bonds[i][1] === allBonds[j][0] && bonds[i][0] === allBonds[j][1]) {\r\n                    count++;\r\n                }\r\n\r\n                if (count === bonds.length) {\r\n                    allContained = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // If all the bonds and thus vertices are already contained within other rings\r\n        // check if there's one vertex with ringCount < bondCount\r\n        let specialCase = false;\r\n        if (allContained) {\r\n            for (let element of pathSet) {\r\n                if (arrRingCount[element] < arrBondCount[element]) {\r\n                    specialCase = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (allContained && !specialCase) {\r\n            return true;\r\n        }\r\n\r\n        // Update the ring counts for the vertices\r\n        for (let element of pathSet) {\r\n            arrRingCount[element]++;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not two sets are equal (contain the same elements).\r\n     * \r\n     * @param {Set<Number>} setA A set.\r\n     * @param {Set<Number>} setB A set.\r\n     * @returns {Boolean} A boolean indicating whether or not the two sets are equal.\r\n     */\r\n    static areSetsEqual(setA, setB) {\r\n        if (setA.size !== setB.size) {\r\n            return false;\r\n        }\r\n\r\n        for (let element of setA) {\r\n            if (!setB.has(element)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not a set (setA) is a superset of another set (setB).\r\n     * \r\n     * @param {Set<Number>} setA A set.\r\n     * @param {Set<Number>} setB A set.\r\n     * @returns {Boolean} A boolean indicating whether or not setB is a superset of setA.\r\n     */\r\n    static isSupersetOf(setA, setB) {\r\n        for (var element of setB) {\r\n            if (!setA.has(element)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nmodule.exports = SSSR;"]},"metadata":{},"sourceType":"script"}