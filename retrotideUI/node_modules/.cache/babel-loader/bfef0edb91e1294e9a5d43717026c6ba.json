{"ast":null,"code":"var _toConsumableArray = require(\"/Users/sarahlafrance/LBNL/clusterCAD/static/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/sarahlafrance/LBNL/clusterCAD/static/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/sarahlafrance/LBNL/clusterCAD/static/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sarahlafrance/LBNL/clusterCAD/static/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n//@ts-check\nvar Vertex = require('./Vertex');\n\nvar Ring = require('./Ring');\n/** \r\n * A class representing a ring connection.\r\n * \r\n * @property {Number} id The id of this ring connection.\r\n * @property {Number} firstRingId A ring id.\r\n * @property {Number} secondRingId A ring id.\r\n * @property {Set<Number>} vertices A set containing the vertex ids participating in the ring connection.\r\n */\n\n\nvar RingConnection = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\r\n   * The constructor for the class RingConnection.\r\n   *\r\n   * @param {Ring} firstRing A ring.\r\n   * @param {Ring} secondRing A ring.\r\n   */\n  function RingConnection(firstRing, secondRing) {\n    _classCallCheck(this, RingConnection);\n\n    this.id = null;\n    this.firstRingId = firstRing.id;\n    this.secondRingId = secondRing.id;\n    this.vertices = new Set();\n\n    for (var m = 0; m < firstRing.members.length; m++) {\n      var c = firstRing.members[m];\n\n      for (var n = 0; n < secondRing.members.length; n++) {\n        var d = secondRing.members[n];\n\n        if (c === d) {\n          this.addVertex(c);\n        }\n      }\n    }\n  }\n  /**\r\n   * Adding a vertex to the ring connection.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   */\n\n\n  _createClass(RingConnection, [{\n    key: \"addVertex\",\n    value: function addVertex(vertexId) {\n      this.vertices.add(vertexId);\n    }\n    /**\r\n     * Update the ring id of this ring connection that is not the ring id supplied as the second argument.\r\n     *\r\n     * @param {Number} ringId A ring id. The new ring id to be set.\r\n     * @param {Number} otherRingId A ring id. The id that is NOT to be updated.\r\n     */\n\n  }, {\n    key: \"updateOther\",\n    value: function updateOther(ringId, otherRingId) {\n      if (this.firstRingId === otherRingId) {\n        this.secondRingId = ringId;\n      } else {\n        this.firstRingId = ringId;\n      }\n    }\n    /**\r\n     * Returns a boolean indicating whether or not a ring with a given id is participating in this ring connection.\r\n     * \r\n     * @param {Number} ringId A ring id.\r\n     * @returns {Boolean} A boolean indicating whether or not a ring with a given id participates in this ring connection.\r\n     */\n\n  }, {\n    key: \"containsRing\",\n    value: function containsRing(ringId) {\n      return this.firstRingId === ringId || this.secondRingId === ringId;\n    }\n    /**\r\n     * Checks whether or not this ring connection is a bridge in a bridged ring.\r\n     *\r\n     * @param {Vertex[]} vertices The array of vertices associated with the current molecule.\r\n     * @returns {Boolean} A boolean indicating whether or not this ring connection is a bridge.\r\n     */\n\n  }, {\n    key: \"isBridge\",\n    value: function isBridge(vertices) {\n      if (this.vertices.size > 2) {\n        return true;\n      }\n\n      var _iterator = _createForOfIteratorHelper(this.vertices),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var vertexId = _step.value;\n\n          if (vertices[vertexId].value.rings.length > 2) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks whether or not two rings are connected by a bridged bond.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing the ring connections associated with the current molecule.\r\n     * @param {Vertex[]} vertices An array of vertices containing the vertices associated with the current molecule.\r\n     * @param {Number} firstRingId A ring id.\r\n     * @param {Number} secondRingId A ring id.\r\n     * @returns {Boolean} A boolean indicating whether or not two rings ar connected by a bridged bond.\r\n     */\n\n  }], [{\n    key: \"isBridge\",\n    value: function isBridge(ringConnections, vertices, firstRingId, secondRingId) {\n      var ringConnection = null;\n\n      for (var i = 0; i < ringConnections.length; i++) {\n        ringConnection = ringConnections[i];\n\n        if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId || ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {\n          return ringConnection.isBridge(vertices);\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Retruns the neighbouring rings of a given ring.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.\r\n     * @param {Number} ringId A ring id.\r\n     * @returns {Number[]} An array of ring ids of neighbouring rings.\r\n     */\n\n  }, {\n    key: \"getNeighbours\",\n    value: function getNeighbours(ringConnections, ringId) {\n      var neighbours = [];\n\n      for (var i = 0; i < ringConnections.length; i++) {\n        var ringConnection = ringConnections[i];\n\n        if (ringConnection.firstRingId === ringId) {\n          neighbours.push(ringConnection.secondRingId);\n        } else if (ringConnection.secondRingId === ringId) {\n          neighbours.push(ringConnection.firstRingId);\n        }\n      }\n\n      return neighbours;\n    }\n    /**\r\n     * Returns an array of vertex ids associated with a given ring connection.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.\r\n     * @param {Number} firstRingId A ring id.\r\n     * @param {Number} secondRingId A ring id.\r\n     * @returns {Number[]} An array of vertex ids associated with the ring connection.\r\n     */\n\n  }, {\n    key: \"getVertices\",\n    value: function getVertices(ringConnections, firstRingId, secondRingId) {\n      for (var i = 0; i < ringConnections.length; i++) {\n        var ringConnection = ringConnections[i];\n\n        if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId || ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {\n          return _toConsumableArray(ringConnection.vertices);\n        }\n      }\n    }\n  }]);\n\n  return RingConnection;\n}();\n\nmodule.exports = RingConnection;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/static/retrotideUI/node_modules/smiles-drawer/src/RingConnection.js"],"names":["Vertex","require","Ring","RingConnection","firstRing","secondRing","id","firstRingId","secondRingId","vertices","Set","m","members","length","c","n","d","addVertex","vertexId","add","ringId","otherRingId","size","value","rings","ringConnections","ringConnection","i","isBridge","neighbours","push","module","exports"],"mappings":"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","sourcesContent":["//@ts-check\r\nconst Vertex = require('./Vertex')\r\nconst Ring = require('./Ring')\r\n\r\n/** \r\n * A class representing a ring connection.\r\n * \r\n * @property {Number} id The id of this ring connection.\r\n * @property {Number} firstRingId A ring id.\r\n * @property {Number} secondRingId A ring id.\r\n * @property {Set<Number>} vertices A set containing the vertex ids participating in the ring connection.\r\n */\r\nclass RingConnection {\r\n    /**\r\n     * The constructor for the class RingConnection.\r\n     *\r\n     * @param {Ring} firstRing A ring.\r\n     * @param {Ring} secondRing A ring.\r\n     */\r\n    constructor(firstRing, secondRing) {\r\n        this.id = null;\r\n        this.firstRingId = firstRing.id;\r\n        this.secondRingId = secondRing.id;\r\n        this.vertices = new Set();\r\n\r\n        for (var m = 0; m < firstRing.members.length; m++) {\r\n            let c = firstRing.members[m];\r\n\r\n            for (let n = 0; n < secondRing.members.length; n++) {\r\n                let d = secondRing.members[n];\r\n\r\n                if (c === d) {\r\n                    this.addVertex(c);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adding a vertex to the ring connection.\r\n     *\r\n     * @param {Number} vertexId A vertex id.\r\n     */\r\n    addVertex(vertexId) {\r\n        this.vertices.add(vertexId);\r\n    }\r\n\r\n    /**\r\n     * Update the ring id of this ring connection that is not the ring id supplied as the second argument.\r\n     *\r\n     * @param {Number} ringId A ring id. The new ring id to be set.\r\n     * @param {Number} otherRingId A ring id. The id that is NOT to be updated.\r\n     */\r\n    updateOther(ringId, otherRingId) {\r\n        if (this.firstRingId === otherRingId) {\r\n            this.secondRingId = ringId;\r\n        } else {\r\n            this.firstRingId = ringId;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean indicating whether or not a ring with a given id is participating in this ring connection.\r\n     * \r\n     * @param {Number} ringId A ring id.\r\n     * @returns {Boolean} A boolean indicating whether or not a ring with a given id participates in this ring connection.\r\n     */\r\n    containsRing(ringId) {\r\n        return this.firstRingId === ringId || this.secondRingId === ringId;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not this ring connection is a bridge in a bridged ring.\r\n     *\r\n     * @param {Vertex[]} vertices The array of vertices associated with the current molecule.\r\n     * @returns {Boolean} A boolean indicating whether or not this ring connection is a bridge.\r\n     */\r\n    isBridge(vertices) {\r\n      if (this.vertices.size > 2) {\r\n          return true;\r\n      }\r\n\r\n      for (let vertexId of this.vertices) {\r\n          if(vertices[vertexId].value.rings.length > 2) {\r\n              return true;\r\n          }\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Checks whether or not two rings are connected by a bridged bond.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing the ring connections associated with the current molecule.\r\n     * @param {Vertex[]} vertices An array of vertices containing the vertices associated with the current molecule.\r\n     * @param {Number} firstRingId A ring id.\r\n     * @param {Number} secondRingId A ring id.\r\n     * @returns {Boolean} A boolean indicating whether or not two rings ar connected by a bridged bond.\r\n     */\r\n    static isBridge(ringConnections, vertices, firstRingId, secondRingId) {\r\n      let ringConnection = null;\r\n      \r\n      for (let i = 0; i < ringConnections.length; i++) {\r\n          ringConnection = ringConnections[i];\r\n\r\n          if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId ||\r\n              ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {\r\n              return ringConnection.isBridge(vertices);\r\n          }\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    /**\r\n     * Retruns the neighbouring rings of a given ring.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.\r\n     * @param {Number} ringId A ring id.\r\n     * @returns {Number[]} An array of ring ids of neighbouring rings.\r\n     */\r\n    static getNeighbours(ringConnections, ringId) {\r\n        let neighbours = [];\r\n\r\n        for (let i = 0; i < ringConnections.length; i++) {\r\n            let ringConnection = ringConnections[i];\r\n            \r\n            if (ringConnection.firstRingId === ringId) {\r\n                neighbours.push(ringConnection.secondRingId);\r\n            } else if (ringConnection.secondRingId === ringId) {\r\n                neighbours.push(ringConnection.firstRingId);\r\n            }\r\n        }\r\n\r\n        return neighbours;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of vertex ids associated with a given ring connection.\r\n     *\r\n     * @static\r\n     * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.\r\n     * @param {Number} firstRingId A ring id.\r\n     * @param {Number} secondRingId A ring id.\r\n     * @returns {Number[]} An array of vertex ids associated with the ring connection.\r\n     */\r\n    static getVertices(ringConnections, firstRingId, secondRingId) {\r\n        for (let i = 0; i < ringConnections.length; i++) {\r\n            let ringConnection = ringConnections[i];\r\n            if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId ||\r\n                ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {\r\n                return [...ringConnection.vertices];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = RingConnection"]},"metadata":{},"sourceType":"script"}