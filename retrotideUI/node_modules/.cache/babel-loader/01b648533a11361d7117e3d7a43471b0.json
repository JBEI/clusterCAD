{"ast":null,"code":"//@ts-check\nconst MathHelper = require('./MathHelper');\n\nconst Vector2 = require('./Vector2');\n\nconst Vertex = require('./Vertex');\n\nconst Edge = require('./Edge');\n\nconst Ring = require('./Ring');\n\nconst Atom = require('./Atom');\n/** \r\n * A class representing the molecular graph. \r\n * \r\n * @property {Vertex[]} vertices The vertices of the graph.\r\n * @property {Edge[]} edges The edges of this graph.\r\n * @property {Object} vertexIdsToEdgeId A map mapping vertex ids to the edge between the two vertices. The key is defined as vertexAId + '_' + vertexBId.\r\n * @property {Boolean} isometric A boolean indicating whether or not the SMILES associated with this graph is isometric.\r\n */\n\n\nclass Graph {\n  /**\r\n   * The constructor of the class Graph.\r\n   * \r\n   * @param {Object} parseTree A SMILES parse tree.\r\n   * @param {Boolean} [isomeric=false] A boolean specifying whether or not the SMILES is isomeric.\r\n   */\n  constructor(parseTree, isomeric = false) {\n    this.vertices = Array();\n    this.edges = Array();\n    this.vertexIdsToEdgeId = {};\n    this.isomeric = isomeric; // Used for the bridge detection algorithm\n\n    this._time = 0;\n\n    this._init(parseTree);\n  }\n  /**\r\n   * PRIVATE FUNCTION. Initializing the graph from the parse tree.\r\n   *\r\n   * @param {Object} node The current node in the parse tree.\r\n   * @param {Number} parentVertexId=null The id of the previous vertex.\r\n   * @param {Boolean} isBranch=false Whether or not the bond leading to this vertex is a branch bond. Branches are represented by parentheses in smiles (e.g. CC(O)C).\r\n   */\n\n\n  _init(node, order = 0, parentVertexId = null, isBranch = false) {\n    // Create a new vertex object\n    let atom = new Atom(node.atom.element ? node.atom.element : node.atom, node.bond);\n    atom.branchBond = node.branchBond;\n    atom.ringbonds = node.ringbonds;\n    atom.bracket = node.atom.element ? node.atom : null;\n    let vertex = new Vertex(atom);\n    let parentVertex = this.vertices[parentVertexId];\n    this.addVertex(vertex); // Add the id of this node to the parent as child\n\n    if (parentVertexId !== null) {\n      vertex.setParentVertexId(parentVertexId);\n      vertex.value.addNeighbouringElement(parentVertex.value.element);\n      parentVertex.addChild(vertex.id);\n      parentVertex.value.addNeighbouringElement(atom.element); // In addition create a spanningTreeChildren property, which later will\n      // not contain the children added through ringbonds\n\n      parentVertex.spanningTreeChildren.push(vertex.id); // Add edge between this node and its parent\n\n      let edge = new Edge(parentVertexId, vertex.id, 1);\n      let vertexId = null;\n\n      if (isBranch) {\n        edge.setBondType(vertex.value.branchBond || '-');\n        vertexId = vertex.id;\n        edge.setBondType(vertex.value.branchBond || '-');\n        vertexId = vertex.id;\n      } else {\n        edge.setBondType(parentVertex.value.bondType || '-');\n        vertexId = parentVertex.id;\n      }\n\n      let edgeId = this.addEdge(edge);\n    }\n\n    let offset = node.ringbondCount + 1;\n\n    if (atom.bracket) {\n      offset += atom.bracket.hcount;\n    }\n\n    let stereoHydrogens = 0;\n\n    if (atom.bracket && atom.bracket.chirality) {\n      atom.isStereoCenter = true;\n      stereoHydrogens = atom.bracket.hcount;\n\n      for (var i = 0; i < stereoHydrogens; i++) {\n        this._init({\n          atom: 'H',\n          isBracket: 'false',\n          branches: Array(),\n          branchCount: 0,\n          ringbonds: Array(),\n          ringbondCount: false,\n          next: null,\n          hasNext: false,\n          bond: '-'\n        }, i, vertex.id, true);\n      }\n    }\n\n    for (var i = 0; i < node.branchCount; i++) {\n      this._init(node.branches[i], i + offset, vertex.id, true);\n    }\n\n    if (node.hasNext) {\n      this._init(node.next, node.branchCount + offset, vertex.id);\n    }\n  }\n  /**\r\n   * Clears all the elements in this graph (edges and vertices).\r\n   */\n\n\n  clear() {\n    this.vertices = Array();\n    this.edges = Array();\n    this.vertexIdsToEdgeId = {};\n  }\n  /**\r\n   * Add a vertex to the graph.\r\n   *\r\n   * @param {Vertex} vertex A new vertex.\r\n   * @returns {Number} The vertex id of the new vertex.\r\n   */\n\n\n  addVertex(vertex) {\n    vertex.id = this.vertices.length;\n    this.vertices.push(vertex);\n    return vertex.id;\n  }\n  /**\r\n   * Add an edge to the graph.\r\n   *\r\n   * @param {Edge} edge A new edge.\r\n   * @returns {Number} The edge id of the new edge.\r\n   */\n\n\n  addEdge(edge) {\n    let source = this.vertices[edge.sourceId];\n    let target = this.vertices[edge.targetId];\n    edge.id = this.edges.length;\n    this.edges.push(edge);\n    this.vertexIdsToEdgeId[edge.sourceId + '_' + edge.targetId] = edge.id;\n    this.vertexIdsToEdgeId[edge.targetId + '_' + edge.sourceId] = edge.id;\n    edge.isPartOfAromaticRing = source.value.isPartOfAromaticRing && target.value.isPartOfAromaticRing;\n    source.value.bondCount += edge.weight;\n    target.value.bondCount += edge.weight;\n    source.edges.push(edge.id);\n    target.edges.push(edge.id);\n    return edge.id;\n  }\n  /**\r\n   * Returns the edge between two given vertices.\r\n   *\r\n   * @param {Number} vertexIdA A vertex id.\r\n   * @param {Number} vertexIdB A vertex id.\r\n   * @returns {(Edge|null)} The edge or, if no edge can be found, null.\r\n   */\n\n\n  getEdge(vertexIdA, vertexIdB) {\n    let edgeId = this.vertexIdsToEdgeId[vertexIdA + '_' + vertexIdB];\n    return edgeId === undefined ? null : this.edges[edgeId];\n  }\n  /**\r\n   * Returns the ids of edges connected to a vertex.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @returns {Number[]} An array containing the ids of edges connected to the vertex.\r\n   */\n\n\n  getEdges(vertexId) {\n    let edgeIds = Array();\n    let vertex = this.vertices[vertexId];\n\n    for (var i = 0; i < vertex.neighbours.length; i++) {\n      edgeIds.push(this.vertexIdsToEdgeId[vertexId + '_' + vertex.neighbours[i]]);\n    }\n\n    return edgeIds;\n  }\n  /**\r\n   * Check whether or not two vertices are connected by an edge.\r\n   *\r\n   * @param {Number} vertexIdA A vertex id.\r\n   * @param {Number} vertexIdB A vertex id.\r\n   * @returns {Boolean} A boolean indicating whether or not two vertices are connected by an edge.\r\n   */\n\n\n  hasEdge(vertexIdA, vertexIdB) {\n    return this.vertexIdsToEdgeId[vertexIdA + '_' + vertexIdB] !== undefined;\n  }\n  /**\r\n   * Returns an array containing the vertex ids of this graph.\r\n   * \r\n   * @returns {Number[]} An array containing all vertex ids of this graph.\r\n   */\n\n\n  getVertexList() {\n    let arr = [this.vertices.length];\n\n    for (var i = 0; i < this.vertices.length; i++) {\n      arr[i] = this.vertices[i].id;\n    }\n\n    return arr;\n  }\n  /**\r\n   * Returns an array containing source, target arrays of this graphs edges.\r\n   * \r\n   * @returns {Array[]} An array containing source, target arrays of this graphs edges. Example: [ [ 2, 5 ], [ 6, 9 ] ].\r\n   */\n\n\n  getEdgeList() {\n    let arr = Array(this.edges.length);\n\n    for (var i = 0; i < this.edges.length; i++) {\n      arr[i] = [this.edges[i].sourceId, this.edges[i].targetId];\n    }\n\n    return arr;\n  }\n  /**\r\n   * Get the adjacency matrix of the graph.\r\n   * \r\n   * @returns {Array[]} The adjancency matrix of the molecular graph.\r\n   */\n\n\n  getAdjacencyMatrix() {\n    let length = this.vertices.length;\n    let adjacencyMatrix = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      adjacencyMatrix[i] = new Array(length);\n      adjacencyMatrix[i].fill(0);\n    }\n\n    for (var i = 0; i < this.edges.length; i++) {\n      let edge = this.edges[i];\n      adjacencyMatrix[edge.sourceId][edge.targetId] = 1;\n      adjacencyMatrix[edge.targetId][edge.sourceId] = 1;\n    }\n\n    return adjacencyMatrix;\n  }\n  /**\r\n   * Get the adjacency matrix of the graph with all bridges removed (thus the components). Thus the remaining vertices are all part of ring systems.\r\n   * \r\n   * @returns {Array[]} The adjancency matrix of the molecular graph with all bridges removed.\r\n   */\n\n\n  getComponentsAdjacencyMatrix() {\n    let length = this.vertices.length;\n    let adjacencyMatrix = Array(length);\n    let bridges = this.getBridges();\n\n    for (var i = 0; i < length; i++) {\n      adjacencyMatrix[i] = new Array(length);\n      adjacencyMatrix[i].fill(0);\n    }\n\n    for (var i = 0; i < this.edges.length; i++) {\n      let edge = this.edges[i];\n      adjacencyMatrix[edge.sourceId][edge.targetId] = 1;\n      adjacencyMatrix[edge.targetId][edge.sourceId] = 1;\n    }\n\n    for (var i = 0; i < bridges.length; i++) {\n      adjacencyMatrix[bridges[i][0]][bridges[i][1]] = 0;\n      adjacencyMatrix[bridges[i][1]][bridges[i][0]] = 0;\n    }\n\n    return adjacencyMatrix;\n  }\n  /**\r\n   * Get the adjacency matrix of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The adjancency matrix of the subgraph.\r\n   */\n\n\n  getSubgraphAdjacencyMatrix(vertexIds) {\n    let length = vertexIds.length;\n    let adjacencyMatrix = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      adjacencyMatrix[i] = new Array(length);\n      adjacencyMatrix[i].fill(0);\n\n      for (var j = 0; j < length; j++) {\n        if (i === j) {\n          continue;\n        }\n\n        if (this.hasEdge(vertexIds[i], vertexIds[j])) {\n          adjacencyMatrix[i][j] = 1;\n        }\n      }\n    }\n\n    return adjacencyMatrix;\n  }\n  /**\r\n   * Get the distance matrix of the graph.\r\n   * \r\n   * @returns {Array[]} The distance matrix of the graph.\r\n   */\n\n\n  getDistanceMatrix() {\n    let length = this.vertices.length;\n    let adja = this.getAdjacencyMatrix();\n    let dist = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      dist[i] = Array(length);\n      dist[i].fill(Infinity);\n    }\n\n    for (var i = 0; i < length; i++) {\n      for (var j = 0; j < length; j++) {\n        if (adja[i][j] === 1) {\n          dist[i][j] = 1;\n        }\n      }\n    }\n\n    for (var k = 0; k < length; k++) {\n      for (var i = 0; i < length; i++) {\n        for (var j = 0; j < length; j++) {\n          if (dist[i][j] > dist[i][k] + dist[k][j]) {\n            dist[i][j] = dist[i][k] + dist[k][j];\n          }\n        }\n      }\n    }\n\n    return dist;\n  }\n  /**\r\n   * Get the distance matrix of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The distance matrix of the subgraph.\r\n   */\n\n\n  getSubgraphDistanceMatrix(vertexIds) {\n    let length = vertexIds.length;\n    let adja = this.getSubgraphAdjacencyMatrix(vertexIds);\n    let dist = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      dist[i] = Array(length);\n      dist[i].fill(Infinity);\n    }\n\n    for (var i = 0; i < length; i++) {\n      for (var j = 0; j < length; j++) {\n        if (adja[i][j] === 1) {\n          dist[i][j] = 1;\n        }\n      }\n    }\n\n    for (var k = 0; k < length; k++) {\n      for (var i = 0; i < length; i++) {\n        for (var j = 0; j < length; j++) {\n          if (dist[i][j] > dist[i][k] + dist[k][j]) {\n            dist[i][j] = dist[i][k] + dist[k][j];\n          }\n        }\n      }\n    }\n\n    return dist;\n  }\n  /**\r\n   * Get the adjacency list of the graph.\r\n   * \r\n   * @returns {Array[]} The adjancency list of the graph.\r\n   */\n\n\n  getAdjacencyList() {\n    let length = this.vertices.length;\n    let adjacencyList = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      adjacencyList[i] = [];\n\n      for (var j = 0; j < length; j++) {\n        if (i === j) {\n          continue;\n        }\n\n        if (this.hasEdge(this.vertices[i].id, this.vertices[j].id)) {\n          adjacencyList[i].push(j);\n        }\n      }\n    }\n\n    return adjacencyList;\n  }\n  /**\r\n   * Get the adjacency list of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The adjancency list of the subgraph.\r\n   */\n\n\n  getSubgraphAdjacencyList(vertexIds) {\n    let length = vertexIds.length;\n    let adjacencyList = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      adjacencyList[i] = Array();\n\n      for (var j = 0; j < length; j++) {\n        if (i === j) {\n          continue;\n        }\n\n        if (this.hasEdge(vertexIds[i], vertexIds[j])) {\n          adjacencyList[i].push(j);\n        }\n      }\n    }\n\n    return adjacencyList;\n  }\n  /**\r\n   * Returns an array containing the edge ids of bridges. A bridge splits the graph into multiple components when removed.\r\n   * \r\n   * @returns {Number[]} An array containing the edge ids of the bridges.\r\n   */\n\n\n  getBridges() {\n    let length = this.vertices.length;\n    let visited = new Array(length);\n    let disc = new Array(length);\n    let low = new Array(length);\n    let parent = new Array(length);\n    let adj = this.getAdjacencyList();\n    let outBridges = Array();\n    visited.fill(false);\n    parent.fill(null);\n    this._time = 0;\n\n    for (var i = 0; i < length; i++) {\n      if (!visited[i]) {\n        this._bridgeDfs(i, visited, disc, low, parent, adj, outBridges);\n      }\n    }\n\n    return outBridges;\n  }\n  /**\r\n   * Traverses the graph in breadth-first order.\r\n   * \r\n   * @param {Number} startVertexId The id of the starting vertex.\r\n   * @param {Function} callback The callback function to be called on every vertex.\r\n   */\n\n\n  traverseBF(startVertexId, callback) {\n    let length = this.vertices.length;\n    let visited = new Array(length);\n    visited.fill(false);\n    var queue = [startVertexId];\n\n    while (queue.length > 0) {\n      // JavaScripts shift() is O(n) ... bad JavaScript, bad!\n      let u = queue.shift();\n      let vertex = this.vertices[u];\n      callback(vertex);\n\n      for (var i = 0; i < vertex.neighbours.length; i++) {\n        let v = vertex.neighbours[i];\n\n        if (!visited[v]) {\n          visited[v] = true;\n          queue.push(v);\n        }\n      }\n    }\n  }\n  /**\r\n   * Get the depth of a subtree in the direction opposite to the vertex specified as the parent vertex.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @param {Number} parentVertexId The id of a neighbouring vertex.\r\n   * @returns {Number} The depth of the sub-tree.\r\n   */\n\n\n  getTreeDepth(vertexId, parentVertexId) {\n    if (vertexId === null || parentVertexId === null) {\n      return 0;\n    }\n\n    let neighbours = this.vertices[vertexId].getSpanningTreeNeighbours(parentVertexId);\n    let max = 0;\n\n    for (var i = 0; i < neighbours.length; i++) {\n      let childId = neighbours[i];\n      let d = this.getTreeDepth(childId, vertexId);\n\n      if (d > max) {\n        max = d;\n      }\n    }\n\n    return max + 1;\n  }\n  /**\r\n   * Traverse a sub-tree in the graph.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @param {Number} parentVertexId A neighbouring vertex.\r\n   * @param {Function} callback The callback function that is called with each visited as an argument.\r\n   * @param {Number} [maxDepth=999999] The maximum depth of the recursion.\r\n   * @param {Boolean} [ignoreFirst=false] Whether or not to ignore the starting vertex supplied as vertexId in the callback.\r\n   * @param {Number} [depth=1] The current depth in the tree.\r\n   * @param {Uint8Array} [visited=null] An array holding a flag on whether or not a node has been visited.\r\n   */\n\n\n  traverseTree(vertexId, parentVertexId, callback, maxDepth = 999999, ignoreFirst = false, depth = 1, visited = null) {\n    if (visited === null) {\n      visited = new Uint8Array(this.vertices.length);\n    }\n\n    if (depth > maxDepth + 1 || visited[vertexId] === 1) {\n      return;\n    }\n\n    visited[vertexId] = 1;\n    let vertex = this.vertices[vertexId];\n    let neighbours = vertex.getNeighbours(parentVertexId);\n\n    if (!ignoreFirst || depth > 1) {\n      callback(vertex);\n    }\n\n    for (var i = 0; i < neighbours.length; i++) {\n      this.traverseTree(neighbours[i], vertexId, callback, maxDepth, ignoreFirst, depth + 1, visited);\n    }\n  }\n  /**\r\n   * Positiones the (sub)graph using Kamada and Kawais algorithm for drawing general undirected graphs. https://pdfs.semanticscholar.org/b8d3/bca50ccc573c5cb99f7d201e8acce6618f04.pdf\r\n   * There are undocumented layout parameters. They are undocumented for a reason, so be very careful.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing vertexIds to be placed using the force based layout.\r\n   * @param {Vector2} center The center of the layout.\r\n   * @param {Number} startVertexId A vertex id. Should be the starting vertex - e.g. the first to be positioned and connected to a previously place vertex.\r\n   * @param {Ring} ring The bridged ring associated with this force-based layout.\r\n   */\n\n\n  kkLayout(vertexIds, center, startVertexId, ring, bondLength, threshold = 0.1, innerThreshold = 0.1, maxIteration = 2000, maxInnerIteration = 50, maxEnergy = 1e9) {\n    let edgeStrength = bondLength; // Add vertices that are directly connected to the ring\n\n    var i = vertexIds.length;\n\n    while (i--) {\n      let vertex = this.vertices[vertexIds[i]];\n      var j = vertex.neighbours.length;\n    }\n\n    let matDist = this.getSubgraphDistanceMatrix(vertexIds);\n    let length = vertexIds.length; // Initialize the positions. Place all vertices on a ring around the center\n\n    let radius = MathHelper.polyCircumradius(500, length);\n    let angle = MathHelper.centralAngle(length);\n    let a = 0.0;\n    let arrPositionX = new Float32Array(length);\n    let arrPositionY = new Float32Array(length);\n    let arrPositioned = Array(length);\n    i = length;\n\n    while (i--) {\n      let vertex = this.vertices[vertexIds[i]];\n\n      if (!vertex.positioned) {\n        arrPositionX[i] = center.x + Math.cos(a) * radius;\n        arrPositionY[i] = center.y + Math.sin(a) * radius;\n      } else {\n        arrPositionX[i] = vertex.position.x;\n        arrPositionY[i] = vertex.position.y;\n      }\n\n      arrPositioned[i] = vertex.positioned;\n      a += angle;\n    } // Create the matrix containing the lengths\n\n\n    let matLength = Array(length);\n    i = length;\n\n    while (i--) {\n      matLength[i] = new Array(length);\n      var j = length;\n\n      while (j--) {\n        matLength[i][j] = bondLength * matDist[i][j];\n      }\n    } // Create the matrix containing the spring strenghts\n\n\n    let matStrength = Array(length);\n    i = length;\n\n    while (i--) {\n      matStrength[i] = Array(length);\n      var j = length;\n\n      while (j--) {\n        matStrength[i][j] = edgeStrength * Math.pow(matDist[i][j], -2.0);\n      }\n    } // Create the matrix containing the energies\n\n\n    let matEnergy = Array(length);\n    let arrEnergySumX = new Float32Array(length);\n    let arrEnergySumY = new Float32Array(length);\n    i = length;\n\n    while (i--) {\n      matEnergy[i] = Array(length);\n    }\n\n    i = length;\n    let ux, uy, dEx, dEy, vx, vy, denom;\n\n    while (i--) {\n      ux = arrPositionX[i];\n      uy = arrPositionY[i];\n      dEx = 0.0;\n      dEy = 0.0;\n      let j = length;\n\n      while (j--) {\n        if (i === j) {\n          continue;\n        }\n\n        vx = arrPositionX[j];\n        vy = arrPositionY[j];\n        denom = 1.0 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));\n        matEnergy[i][j] = [matStrength[i][j] * (ux - vx - matLength[i][j] * (ux - vx) * denom), matStrength[i][j] * (uy - vy - matLength[i][j] * (uy - vy) * denom)];\n        matEnergy[j][i] = matEnergy[i][j];\n        dEx += matEnergy[i][j][0];\n        dEy += matEnergy[i][j][1];\n      }\n\n      arrEnergySumX[i] = dEx;\n      arrEnergySumY[i] = dEy;\n    } // Utility functions, maybe inline them later\n\n\n    let energy = function (index) {\n      return [arrEnergySumX[index] * arrEnergySumX[index] + arrEnergySumY[index] * arrEnergySumY[index], arrEnergySumX[index], arrEnergySumY[index]];\n    };\n\n    let highestEnergy = function () {\n      let maxEnergy = 0.0;\n      let maxEnergyId = 0;\n      let maxDEX = 0.0;\n      let maxDEY = 0.0;\n      i = length;\n\n      while (i--) {\n        let [delta, dEX, dEY] = energy(i);\n\n        if (delta > maxEnergy && arrPositioned[i] === false) {\n          maxEnergy = delta;\n          maxEnergyId = i;\n          maxDEX = dEX;\n          maxDEY = dEY;\n        }\n      }\n\n      return [maxEnergyId, maxEnergy, maxDEX, maxDEY];\n    };\n\n    let update = function (index, dEX, dEY) {\n      let dxx = 0.0;\n      let dyy = 0.0;\n      let dxy = 0.0;\n      let ux = arrPositionX[index];\n      let uy = arrPositionY[index];\n      let arrL = matLength[index];\n      let arrK = matStrength[index];\n      i = length;\n\n      while (i--) {\n        if (i === index) {\n          continue;\n        }\n\n        let vx = arrPositionX[i];\n        let vy = arrPositionY[i];\n        let l = arrL[i];\n        let k = arrK[i];\n        let m = (ux - vx) * (ux - vx);\n        let denom = 1.0 / Math.pow(m + (uy - vy) * (uy - vy), 1.5);\n        dxx += k * (1 - l * (uy - vy) * (uy - vy) * denom);\n        dyy += k * (1 - l * m * denom);\n        dxy += k * (l * (ux - vx) * (uy - vy) * denom);\n      } // Prevent division by zero\n\n\n      if (dxx === 0) {\n        dxx = 0.1;\n      }\n\n      if (dyy === 0) {\n        dyy = 0.1;\n      }\n\n      if (dxy === 0) {\n        dxy = 0.1;\n      }\n\n      let dy = dEX / dxx + dEY / dxy;\n      dy /= dxy / dxx - dyy / dxy; // had to split this onto two lines because the syntax highlighter went crazy.\n\n      let dx = -(dxy * dy + dEX) / dxx;\n      arrPositionX[index] += dx;\n      arrPositionY[index] += dy; // Update the energies\n\n      let arrE = matEnergy[index];\n      dEX = 0.0;\n      dEY = 0.0;\n      ux = arrPositionX[index];\n      uy = arrPositionY[index];\n      let vx, vy, prevEx, prevEy, denom;\n      i = length;\n\n      while (i--) {\n        if (index === i) {\n          continue;\n        }\n\n        vx = arrPositionX[i];\n        vy = arrPositionY[i]; // Store old energies\n\n        prevEx = arrE[i][0];\n        prevEy = arrE[i][1];\n        denom = 1.0 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));\n        dx = arrK[i] * (ux - vx - arrL[i] * (ux - vx) * denom);\n        dy = arrK[i] * (uy - vy - arrL[i] * (uy - vy) * denom);\n        arrE[i] = [dx, dy];\n        dEX += dx;\n        dEY += dy;\n        arrEnergySumX[i] += dx - prevEx;\n        arrEnergySumY[i] += dy - prevEy;\n      }\n\n      arrEnergySumX[index] = dEX;\n      arrEnergySumY[index] = dEY;\n    }; // Setting up variables for the while loops\n\n\n    let maxEnergyId = 0;\n    let dEX = 0.0;\n    let dEY = 0.0;\n    let delta = 0.0;\n    let iteration = 0;\n    let innerIteration = 0;\n\n    while (maxEnergy > threshold && maxIteration > iteration) {\n      iteration++;\n      [maxEnergyId, maxEnergy, dEX, dEY] = highestEnergy();\n      delta = maxEnergy;\n      innerIteration = 0;\n\n      while (delta > innerThreshold && maxInnerIteration > innerIteration) {\n        innerIteration++;\n        update(maxEnergyId, dEX, dEY);\n        [delta, dEX, dEY] = energy(maxEnergyId);\n      }\n    }\n\n    i = length;\n\n    while (i--) {\n      let index = vertexIds[i];\n      let vertex = this.vertices[index];\n      vertex.position.x = arrPositionX[i];\n      vertex.position.y = arrPositionY[i];\n      vertex.positioned = true;\n      vertex.forcePositioned = true;\n    }\n  }\n  /**\r\n   * PRIVATE FUNCTION used by getBridges().\r\n   */\n\n\n  _bridgeDfs(u, visited, disc, low, parent, adj, outBridges) {\n    visited[u] = true;\n    disc[u] = low[u] = ++this._time;\n\n    for (var i = 0; i < adj[u].length; i++) {\n      let v = adj[u][i];\n\n      if (!visited[v]) {\n        parent[v] = u;\n\n        this._bridgeDfs(v, visited, disc, low, parent, adj, outBridges);\n\n        low[u] = Math.min(low[u], low[v]); // If low > disc, we have a bridge\n\n        if (low[v] > disc[u]) {\n          outBridges.push([u, v]);\n        }\n      } else if (v !== parent[u]) {\n        low[u] = Math.min(low[u], disc[v]);\n      }\n    }\n  }\n  /**\r\n   * Returns the connected components of the graph.\r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Set[]} Connected components as sets.\r\n   */\n\n\n  static getConnectedComponents(adjacencyMatrix) {\n    let length = adjacencyMatrix.length;\n    let visited = new Array(length);\n    let components = new Array();\n    let count = 0;\n    visited.fill(false);\n\n    for (var u = 0; u < length; u++) {\n      if (!visited[u]) {\n        let component = Array();\n        visited[u] = true;\n        component.push(u);\n        count++;\n\n        Graph._ccGetDfs(u, visited, adjacencyMatrix, component);\n\n        if (component.length > 1) {\n          components.push(component);\n        }\n      }\n    }\n\n    return components;\n  }\n  /**\r\n   * Returns the number of connected components for the graph. \r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Number} The number of connected components of the supplied graph.\r\n   */\n\n\n  static getConnectedComponentCount(adjacencyMatrix) {\n    let length = adjacencyMatrix.length;\n    let visited = new Array(length);\n    let count = 0;\n    visited.fill(false);\n\n    for (var u = 0; u < length; u++) {\n      if (!visited[u]) {\n        visited[u] = true;\n        count++;\n\n        Graph._ccCountDfs(u, visited, adjacencyMatrix);\n      }\n    }\n\n    return count;\n  }\n  /**\r\n   * PRIVATE FUNCTION used by getConnectedComponentCount().\r\n   */\n\n\n  static _ccCountDfs(u, visited, adjacencyMatrix) {\n    for (var v = 0; v < adjacencyMatrix[u].length; v++) {\n      let c = adjacencyMatrix[u][v];\n\n      if (!c || visited[v] || u === v) {\n        continue;\n      }\n\n      visited[v] = true;\n\n      Graph._ccCountDfs(v, visited, adjacencyMatrix);\n    }\n  }\n  /**\r\n   * PRIVATE FUNCTION used by getConnectedComponents().\r\n   */\n\n\n  static _ccGetDfs(u, visited, adjacencyMatrix, component) {\n    for (var v = 0; v < adjacencyMatrix[u].length; v++) {\n      let c = adjacencyMatrix[u][v];\n\n      if (!c || visited[v] || u === v) {\n        continue;\n      }\n\n      visited[v] = true;\n      component.push(v);\n\n      Graph._ccGetDfs(v, visited, adjacencyMatrix, component);\n    }\n  }\n\n}\n\nmodule.exports = Graph;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/smiles-drawer/src/Graph.js"],"names":["MathHelper","require","Vector2","Vertex","Edge","Ring","Atom","Graph","constructor","parseTree","isomeric","vertices","Array","edges","vertexIdsToEdgeId","_time","_init","node","order","parentVertexId","isBranch","atom","element","bond","branchBond","ringbonds","bracket","vertex","parentVertex","addVertex","setParentVertexId","value","addNeighbouringElement","addChild","id","spanningTreeChildren","push","edge","vertexId","setBondType","bondType","edgeId","addEdge","offset","ringbondCount","hcount","stereoHydrogens","chirality","isStereoCenter","i","isBracket","branches","branchCount","next","hasNext","clear","length","source","sourceId","target","targetId","isPartOfAromaticRing","bondCount","weight","getEdge","vertexIdA","vertexIdB","undefined","getEdges","edgeIds","neighbours","hasEdge","getVertexList","arr","getEdgeList","getAdjacencyMatrix","adjacencyMatrix","fill","getComponentsAdjacencyMatrix","bridges","getBridges","getSubgraphAdjacencyMatrix","vertexIds","j","getDistanceMatrix","adja","dist","Infinity","k","getSubgraphDistanceMatrix","getAdjacencyList","adjacencyList","getSubgraphAdjacencyList","visited","disc","low","parent","adj","outBridges","_bridgeDfs","traverseBF","startVertexId","callback","queue","u","shift","v","getTreeDepth","getSpanningTreeNeighbours","max","childId","d","traverseTree","maxDepth","ignoreFirst","depth","Uint8Array","getNeighbours","kkLayout","center","ring","bondLength","threshold","innerThreshold","maxIteration","maxInnerIteration","maxEnergy","edgeStrength","matDist","radius","polyCircumradius","angle","centralAngle","a","arrPositionX","Float32Array","arrPositionY","arrPositioned","positioned","x","Math","cos","y","sin","position","matLength","matStrength","pow","matEnergy","arrEnergySumX","arrEnergySumY","ux","uy","dEx","dEy","vx","vy","denom","sqrt","energy","index","highestEnergy","maxEnergyId","maxDEX","maxDEY","delta","dEX","dEY","update","dxx","dyy","dxy","arrL","arrK","l","m","dy","dx","arrE","prevEx","prevEy","iteration","innerIteration","forcePositioned","min","getConnectedComponents","components","count","component","_ccGetDfs","getConnectedComponentCount","_ccCountDfs","c","module","exports"],"mappings":"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","sourcesContent":["//@ts-check\r\nconst MathHelper = require('./MathHelper')\r\nconst Vector2 = require('./Vector2')\r\nconst Vertex = require('./Vertex')\r\nconst Edge = require('./Edge')\r\nconst Ring = require('./Ring')\r\nconst Atom = require('./Atom')\r\n\r\n/** \r\n * A class representing the molecular graph. \r\n * \r\n * @property {Vertex[]} vertices The vertices of the graph.\r\n * @property {Edge[]} edges The edges of this graph.\r\n * @property {Object} vertexIdsToEdgeId A map mapping vertex ids to the edge between the two vertices. The key is defined as vertexAId + '_' + vertexBId.\r\n * @property {Boolean} isometric A boolean indicating whether or not the SMILES associated with this graph is isometric.\r\n */\r\nclass Graph {\r\n  /**\r\n   * The constructor of the class Graph.\r\n   * \r\n   * @param {Object} parseTree A SMILES parse tree.\r\n   * @param {Boolean} [isomeric=false] A boolean specifying whether or not the SMILES is isomeric.\r\n   */\r\n  constructor(parseTree, isomeric = false) {\r\n    this.vertices = Array();\r\n    this.edges = Array();\r\n    this.vertexIdsToEdgeId = {};\r\n    this.isomeric = isomeric;\r\n\r\n    // Used for the bridge detection algorithm\r\n    this._time = 0;\r\n    this._init(parseTree);\r\n  }\r\n\r\n  /**\r\n   * PRIVATE FUNCTION. Initializing the graph from the parse tree.\r\n   *\r\n   * @param {Object} node The current node in the parse tree.\r\n   * @param {Number} parentVertexId=null The id of the previous vertex.\r\n   * @param {Boolean} isBranch=false Whether or not the bond leading to this vertex is a branch bond. Branches are represented by parentheses in smiles (e.g. CC(O)C).\r\n   */\r\n  _init(node, order = 0, parentVertexId = null, isBranch = false) {\r\n    // Create a new vertex object\r\n    let atom = new Atom(node.atom.element ? node.atom.element : node.atom, node.bond);\r\n\r\n    atom.branchBond = node.branchBond;\r\n    atom.ringbonds = node.ringbonds;\r\n    atom.bracket = node.atom.element ? node.atom : null;\r\n\r\n    let vertex = new Vertex(atom);\r\n    let parentVertex = this.vertices[parentVertexId];\r\n\r\n    this.addVertex(vertex);\r\n\r\n    // Add the id of this node to the parent as child\r\n    if (parentVertexId !== null) {\r\n      vertex.setParentVertexId(parentVertexId);\r\n      vertex.value.addNeighbouringElement(parentVertex.value.element);\r\n      parentVertex.addChild(vertex.id);\r\n      parentVertex.value.addNeighbouringElement(atom.element);\r\n\r\n      // In addition create a spanningTreeChildren property, which later will\r\n      // not contain the children added through ringbonds\r\n      parentVertex.spanningTreeChildren.push(vertex.id);\r\n\r\n      // Add edge between this node and its parent\r\n      let edge = new Edge(parentVertexId, vertex.id, 1);\r\n      let vertexId = null;\r\n\r\n      if (isBranch) {\r\n        edge.setBondType(vertex.value.branchBond || '-');\r\n        vertexId = vertex.id;\r\n        edge.setBondType(vertex.value.branchBond || '-');\r\n        vertexId = vertex.id;\r\n      } else {\r\n        edge.setBondType(parentVertex.value.bondType || '-');\r\n        vertexId = parentVertex.id;\r\n      }\r\n\r\n      let edgeId = this.addEdge(edge);\r\n    }\r\n\r\n    let offset = node.ringbondCount + 1;\r\n\r\n    if (atom.bracket) {\r\n      offset += atom.bracket.hcount;\r\n    }\r\n\r\n    let stereoHydrogens = 0;\r\n    if (atom.bracket && atom.bracket.chirality) {\r\n      atom.isStereoCenter = true;\r\n      stereoHydrogens = atom.bracket.hcount;\r\n      for (var i = 0; i < stereoHydrogens; i++) {\r\n        this._init({\r\n          atom: 'H',\r\n          isBracket: 'false',\r\n          branches: Array(),\r\n          branchCount: 0,\r\n          ringbonds: Array(),\r\n          ringbondCount: false,\r\n          next: null,\r\n          hasNext: false,\r\n          bond: '-'\r\n        }, i, vertex.id, true);\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < node.branchCount; i++) {\r\n      this._init(node.branches[i], i + offset, vertex.id, true);\r\n    }\r\n\r\n    if (node.hasNext) {\r\n      this._init(node.next, node.branchCount + offset, vertex.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears all the elements in this graph (edges and vertices).\r\n   */\r\n  clear() {\r\n    this.vertices = Array();\r\n    this.edges = Array();\r\n    this.vertexIdsToEdgeId = {};\r\n  }\r\n\r\n  /**\r\n   * Add a vertex to the graph.\r\n   *\r\n   * @param {Vertex} vertex A new vertex.\r\n   * @returns {Number} The vertex id of the new vertex.\r\n   */\r\n  addVertex(vertex) {\r\n    vertex.id = this.vertices.length;\r\n    this.vertices.push(vertex);\r\n\r\n    return vertex.id;\r\n  }\r\n\r\n  /**\r\n   * Add an edge to the graph.\r\n   *\r\n   * @param {Edge} edge A new edge.\r\n   * @returns {Number} The edge id of the new edge.\r\n   */\r\n  addEdge(edge) {\r\n    let source = this.vertices[edge.sourceId];\r\n    let target = this.vertices[edge.targetId];\r\n\r\n    edge.id = this.edges.length;\r\n    this.edges.push(edge);\r\n\r\n    this.vertexIdsToEdgeId[edge.sourceId + '_' + edge.targetId] = edge.id;\r\n    this.vertexIdsToEdgeId[edge.targetId + '_' + edge.sourceId] = edge.id;\r\n    edge.isPartOfAromaticRing = source.value.isPartOfAromaticRing && target.value.isPartOfAromaticRing;\r\n\r\n    source.value.bondCount += edge.weight;\r\n    target.value.bondCount += edge.weight;\r\n\r\n    source.edges.push(edge.id);\r\n    target.edges.push(edge.id);\r\n\r\n    return edge.id;\r\n  }\r\n\r\n  /**\r\n   * Returns the edge between two given vertices.\r\n   *\r\n   * @param {Number} vertexIdA A vertex id.\r\n   * @param {Number} vertexIdB A vertex id.\r\n   * @returns {(Edge|null)} The edge or, if no edge can be found, null.\r\n   */\r\n  getEdge(vertexIdA, vertexIdB) {\r\n    let edgeId = this.vertexIdsToEdgeId[vertexIdA + '_' + vertexIdB];\r\n\r\n    return edgeId === undefined ? null : this.edges[edgeId];\r\n  }\r\n\r\n  /**\r\n   * Returns the ids of edges connected to a vertex.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @returns {Number[]} An array containing the ids of edges connected to the vertex.\r\n   */\r\n  getEdges(vertexId) {\r\n    let edgeIds = Array();\r\n    let vertex = this.vertices[vertexId];\r\n\r\n    for (var i = 0; i < vertex.neighbours.length; i++) {\r\n      edgeIds.push(this.vertexIdsToEdgeId[vertexId + '_' + vertex.neighbours[i]]);\r\n    }\r\n\r\n    return edgeIds;\r\n  }\r\n\r\n\r\n  /**\r\n   * Check whether or not two vertices are connected by an edge.\r\n   *\r\n   * @param {Number} vertexIdA A vertex id.\r\n   * @param {Number} vertexIdB A vertex id.\r\n   * @returns {Boolean} A boolean indicating whether or not two vertices are connected by an edge.\r\n   */\r\n  hasEdge(vertexIdA, vertexIdB) {\r\n    return this.vertexIdsToEdgeId[vertexIdA + '_' + vertexIdB] !== undefined\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing the vertex ids of this graph.\r\n   * \r\n   * @returns {Number[]} An array containing all vertex ids of this graph.\r\n   */\r\n  getVertexList() {\r\n    let arr = [this.vertices.length];\r\n\r\n    for (var i = 0; i < this.vertices.length; i++) {\r\n      arr[i] = this.vertices[i].id;\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing source, target arrays of this graphs edges.\r\n   * \r\n   * @returns {Array[]} An array containing source, target arrays of this graphs edges. Example: [ [ 2, 5 ], [ 6, 9 ] ].\r\n   */\r\n  getEdgeList() {\r\n    let arr = Array(this.edges.length);\r\n\r\n    for (var i = 0; i < this.edges.length; i++) {\r\n      arr[i] = [this.edges[i].sourceId, this.edges[i].targetId];\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency matrix of the graph.\r\n   * \r\n   * @returns {Array[]} The adjancency matrix of the molecular graph.\r\n   */\r\n  getAdjacencyMatrix() {\r\n    let length = this.vertices.length;\r\n    let adjacencyMatrix = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyMatrix[i] = new Array(length);\r\n      adjacencyMatrix[i].fill(0);\r\n    }\r\n\r\n    for (var i = 0; i < this.edges.length; i++) {\r\n      let edge = this.edges[i];\r\n\r\n      adjacencyMatrix[edge.sourceId][edge.targetId] = 1;\r\n      adjacencyMatrix[edge.targetId][edge.sourceId] = 1;\r\n    }\r\n\r\n    return adjacencyMatrix;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency matrix of the graph with all bridges removed (thus the components). Thus the remaining vertices are all part of ring systems.\r\n   * \r\n   * @returns {Array[]} The adjancency matrix of the molecular graph with all bridges removed.\r\n   */\r\n  getComponentsAdjacencyMatrix() {\r\n    let length = this.vertices.length;\r\n    let adjacencyMatrix = Array(length);\r\n    let bridges = this.getBridges();\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyMatrix[i] = new Array(length);\r\n      adjacencyMatrix[i].fill(0);\r\n    }\r\n\r\n    for (var i = 0; i < this.edges.length; i++) {\r\n      let edge = this.edges[i];\r\n\r\n      adjacencyMatrix[edge.sourceId][edge.targetId] = 1;\r\n      adjacencyMatrix[edge.targetId][edge.sourceId] = 1;\r\n    }\r\n\r\n    for (var i = 0; i < bridges.length; i++) {\r\n      adjacencyMatrix[bridges[i][0]][bridges[i][1]] = 0;\r\n      adjacencyMatrix[bridges[i][1]][bridges[i][0]] = 0;\r\n    }\r\n\r\n    return adjacencyMatrix;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency matrix of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The adjancency matrix of the subgraph.\r\n   */\r\n  getSubgraphAdjacencyMatrix(vertexIds) {\r\n    let length = vertexIds.length;\r\n    let adjacencyMatrix = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyMatrix[i] = new Array(length);\r\n      adjacencyMatrix[i].fill(0);\r\n\r\n      for (var j = 0; j < length; j++) {\r\n        if (i === j) {\r\n          continue;\r\n        }\r\n\r\n        if (this.hasEdge(vertexIds[i], vertexIds[j])) {\r\n          adjacencyMatrix[i][j] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    return adjacencyMatrix;\r\n  }\r\n\r\n  /**\r\n   * Get the distance matrix of the graph.\r\n   * \r\n   * @returns {Array[]} The distance matrix of the graph.\r\n   */\r\n  getDistanceMatrix() {\r\n    let length = this.vertices.length;\r\n    let adja = this.getAdjacencyMatrix();\r\n    let dist = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      dist[i] = Array(length);\r\n      dist[i].fill(Infinity);\r\n    }\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      for (var j = 0; j < length; j++) {\r\n        if (adja[i][j] === 1) {\r\n          dist[i][j] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (var k = 0; k < length; k++) {\r\n      for (var i = 0; i < length; i++) {\r\n        for (var j = 0; j < length; j++) {\r\n          if (dist[i][j] > dist[i][k] + dist[k][j]) {\r\n            dist[i][j] = dist[i][k] + dist[k][j]\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return dist;\r\n  }\r\n\r\n  /**\r\n   * Get the distance matrix of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The distance matrix of the subgraph.\r\n   */\r\n  getSubgraphDistanceMatrix(vertexIds) {\r\n    let length = vertexIds.length;\r\n    let adja = this.getSubgraphAdjacencyMatrix(vertexIds);\r\n    let dist = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      dist[i] = Array(length);\r\n      dist[i].fill(Infinity);\r\n    }\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      for (var j = 0; j < length; j++) {\r\n        if (adja[i][j] === 1) {\r\n          dist[i][j] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (var k = 0; k < length; k++) {\r\n      for (var i = 0; i < length; i++) {\r\n        for (var j = 0; j < length; j++) {\r\n          if (dist[i][j] > dist[i][k] + dist[k][j]) {\r\n            dist[i][j] = dist[i][k] + dist[k][j]\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return dist;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency list of the graph.\r\n   * \r\n   * @returns {Array[]} The adjancency list of the graph.\r\n   */\r\n  getAdjacencyList() {\r\n    let length = this.vertices.length;\r\n    let adjacencyList = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyList[i] = [];\r\n\r\n      for (var j = 0; j < length; j++) {\r\n        if (i === j) {\r\n          continue;\r\n        }\r\n\r\n        if (this.hasEdge(this.vertices[i].id, this.vertices[j].id)) {\r\n          adjacencyList[i].push(j);\r\n        }\r\n      }\r\n    }\r\n\r\n    return adjacencyList;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency list of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The adjancency list of the subgraph.\r\n   */\r\n  getSubgraphAdjacencyList(vertexIds) {\r\n    let length = vertexIds.length;\r\n    let adjacencyList = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyList[i] = Array();\r\n\r\n      for (var j = 0; j < length; j++) {\r\n        if (i === j) {\r\n          continue;\r\n        }\r\n\r\n        if (this.hasEdge(vertexIds[i], vertexIds[j])) {\r\n          adjacencyList[i].push(j);\r\n        }\r\n      }\r\n    }\r\n\r\n    return adjacencyList;\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing the edge ids of bridges. A bridge splits the graph into multiple components when removed.\r\n   * \r\n   * @returns {Number[]} An array containing the edge ids of the bridges.\r\n   */\r\n  getBridges() {\r\n    let length = this.vertices.length;\r\n    let visited = new Array(length);\r\n    let disc = new Array(length);\r\n    let low = new Array(length);\r\n    let parent = new Array(length);\r\n    let adj = this.getAdjacencyList();\r\n    let outBridges = Array();\r\n\r\n    visited.fill(false);\r\n    parent.fill(null);\r\n    this._time = 0;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      if (!visited[i]) {\r\n        this._bridgeDfs(i, visited, disc, low, parent, adj, outBridges);\r\n      }\r\n    }\r\n\r\n    return outBridges;\r\n  }\r\n\r\n  /**\r\n   * Traverses the graph in breadth-first order.\r\n   * \r\n   * @param {Number} startVertexId The id of the starting vertex.\r\n   * @param {Function} callback The callback function to be called on every vertex.\r\n   */\r\n  traverseBF(startVertexId, callback) {\r\n    let length = this.vertices.length;\r\n    let visited = new Array(length);\r\n\r\n    visited.fill(false);\r\n\r\n    var queue = [startVertexId];\r\n\r\n    while (queue.length > 0) {\r\n      // JavaScripts shift() is O(n) ... bad JavaScript, bad!\r\n      let u = queue.shift();\r\n      let vertex = this.vertices[u];\r\n\r\n      callback(vertex);\r\n\r\n      for (var i = 0; i < vertex.neighbours.length; i++) {\r\n        let v = vertex.neighbours[i]\r\n        if (!visited[v]) {\r\n          visited[v] = true;\r\n          queue.push(v);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the depth of a subtree in the direction opposite to the vertex specified as the parent vertex.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @param {Number} parentVertexId The id of a neighbouring vertex.\r\n   * @returns {Number} The depth of the sub-tree.\r\n   */\r\n  getTreeDepth(vertexId, parentVertexId) {\r\n    if (vertexId === null || parentVertexId === null) {\r\n      return 0;\r\n    }\r\n\r\n    let neighbours = this.vertices[vertexId].getSpanningTreeNeighbours(parentVertexId);\r\n    let max = 0;\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      let childId = neighbours[i];\r\n      let d = this.getTreeDepth(childId, vertexId);\r\n\r\n      if (d > max) {\r\n        max = d;\r\n      }\r\n    }\r\n\r\n    return max + 1;\r\n  }\r\n\r\n  /**\r\n   * Traverse a sub-tree in the graph.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @param {Number} parentVertexId A neighbouring vertex.\r\n   * @param {Function} callback The callback function that is called with each visited as an argument.\r\n   * @param {Number} [maxDepth=999999] The maximum depth of the recursion.\r\n   * @param {Boolean} [ignoreFirst=false] Whether or not to ignore the starting vertex supplied as vertexId in the callback.\r\n   * @param {Number} [depth=1] The current depth in the tree.\r\n   * @param {Uint8Array} [visited=null] An array holding a flag on whether or not a node has been visited.\r\n   */\r\n  traverseTree(vertexId, parentVertexId, callback, maxDepth = 999999, ignoreFirst = false, depth = 1, visited = null) {\r\n    if (visited === null) {\r\n      visited = new Uint8Array(this.vertices.length);\r\n    }\r\n\r\n    if (depth > maxDepth + 1 || visited[vertexId] === 1) {\r\n      return;\r\n    }\r\n\r\n    visited[vertexId] = 1;\r\n\r\n    let vertex = this.vertices[vertexId];\r\n    let neighbours = vertex.getNeighbours(parentVertexId);\r\n\r\n    if (!ignoreFirst || depth > 1) {\r\n      callback(vertex);\r\n    }\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      this.traverseTree(neighbours[i], vertexId, callback, maxDepth, ignoreFirst, depth + 1, visited);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Positiones the (sub)graph using Kamada and Kawais algorithm for drawing general undirected graphs. https://pdfs.semanticscholar.org/b8d3/bca50ccc573c5cb99f7d201e8acce6618f04.pdf\r\n   * There are undocumented layout parameters. They are undocumented for a reason, so be very careful.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing vertexIds to be placed using the force based layout.\r\n   * @param {Vector2} center The center of the layout.\r\n   * @param {Number} startVertexId A vertex id. Should be the starting vertex - e.g. the first to be positioned and connected to a previously place vertex.\r\n   * @param {Ring} ring The bridged ring associated with this force-based layout.\r\n   */\r\n  kkLayout(vertexIds, center, startVertexId, ring, bondLength,\r\n    threshold = 0.1, innerThreshold = 0.1, maxIteration = 2000,\r\n    maxInnerIteration = 50, maxEnergy = 1e9) {\r\n\r\n    let edgeStrength = bondLength;\r\n\r\n    // Add vertices that are directly connected to the ring\r\n    var i = vertexIds.length;\r\n    while (i--) {\r\n      let vertex = this.vertices[vertexIds[i]];\r\n      var j = vertex.neighbours.length;\r\n    }\r\n\r\n    let matDist = this.getSubgraphDistanceMatrix(vertexIds);\r\n    let length = vertexIds.length;\r\n\r\n    // Initialize the positions. Place all vertices on a ring around the center\r\n    let radius = MathHelper.polyCircumradius(500, length);\r\n    let angle = MathHelper.centralAngle(length);\r\n    let a = 0.0;\r\n    let arrPositionX = new Float32Array(length);\r\n    let arrPositionY = new Float32Array(length);\r\n    let arrPositioned = Array(length);\r\n\r\n    i = length;\r\n    while (i--) {\r\n      let vertex = this.vertices[vertexIds[i]];\r\n      if (!vertex.positioned) {\r\n        arrPositionX[i] = center.x + Math.cos(a) * radius;\r\n        arrPositionY[i] = center.y + Math.sin(a) * radius;\r\n      } else {\r\n        arrPositionX[i] = vertex.position.x;\r\n        arrPositionY[i] = vertex.position.y;\r\n      }\r\n      arrPositioned[i] = vertex.positioned;\r\n      a += angle;\r\n    }\r\n\r\n    // Create the matrix containing the lengths\r\n    let matLength = Array(length);\r\n    i = length;\r\n    while (i--) {\r\n      matLength[i] = new Array(length);\r\n      var j = length;\r\n      while (j--) {\r\n        matLength[i][j] = bondLength * matDist[i][j];\r\n      }\r\n    }\r\n\r\n    // Create the matrix containing the spring strenghts\r\n    let matStrength = Array(length);\r\n    i = length;\r\n    while (i--) {\r\n      matStrength[i] = Array(length);\r\n      var j = length;\r\n      while (j--) {\r\n        matStrength[i][j] = edgeStrength * Math.pow(matDist[i][j], -2.0);\r\n      }\r\n    }\r\n\r\n    // Create the matrix containing the energies\r\n    let matEnergy = Array(length);\r\n    let arrEnergySumX = new Float32Array(length);\r\n    let arrEnergySumY = new Float32Array(length);\r\n    i = length;\r\n    while (i--) {\r\n      matEnergy[i] = Array(length);\r\n    }\r\n\r\n    i = length;\r\n    let ux, uy, dEx, dEy, vx, vy, denom;\r\n\r\n    while (i--) {\r\n      ux = arrPositionX[i];\r\n      uy = arrPositionY[i];\r\n      dEx = 0.0;\r\n      dEy = 0.0;\r\n      let j = length;\r\n      while (j--) {\r\n        if (i === j) {\r\n          continue;\r\n        }\r\n        vx = arrPositionX[j];\r\n        vy = arrPositionY[j];\r\n        denom = 1.0 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));\r\n        matEnergy[i][j] = [\r\n          matStrength[i][j] * ((ux - vx) - matLength[i][j] * (ux - vx) * denom),\r\n          matStrength[i][j] * ((uy - vy) - matLength[i][j] * (uy - vy) * denom)\r\n        ]\r\n        matEnergy[j][i] = matEnergy[i][j];\r\n        dEx += matEnergy[i][j][0];\r\n        dEy += matEnergy[i][j][1];\r\n      }\r\n      arrEnergySumX[i] = dEx;\r\n      arrEnergySumY[i] = dEy;\r\n    }\r\n\r\n    // Utility functions, maybe inline them later\r\n    let energy = function (index) {\r\n      return [arrEnergySumX[index] * arrEnergySumX[index] + arrEnergySumY[index] * arrEnergySumY[index], arrEnergySumX[index], arrEnergySumY[index]];\r\n    }\r\n\r\n    let highestEnergy = function () {\r\n      let maxEnergy = 0.0;\r\n      let maxEnergyId = 0;\r\n      let maxDEX = 0.0;\r\n      let maxDEY = 0.0\r\n\r\n      i = length;\r\n      while (i--) {\r\n        let [delta, dEX, dEY] = energy(i);\r\n\r\n        if (delta > maxEnergy && arrPositioned[i] === false) {\r\n          maxEnergy = delta;\r\n          maxEnergyId = i;\r\n          maxDEX = dEX;\r\n          maxDEY = dEY;\r\n        }\r\n      }\r\n\r\n      return [maxEnergyId, maxEnergy, maxDEX, maxDEY];\r\n    }\r\n\r\n    let update = function (index, dEX, dEY) {\r\n      let dxx = 0.0;\r\n      let dyy = 0.0;\r\n      let dxy = 0.0;\r\n      let ux = arrPositionX[index];\r\n      let uy = arrPositionY[index];\r\n      let arrL = matLength[index];\r\n      let arrK = matStrength[index];\r\n\r\n      i = length;\r\n      while (i--) {\r\n        if (i === index) {\r\n          continue;\r\n        }\r\n\r\n        let vx = arrPositionX[i];\r\n        let vy = arrPositionY[i];\r\n        let l = arrL[i];\r\n        let k = arrK[i];\r\n        let m = (ux - vx) * (ux - vx);\r\n        let denom = 1.0 / Math.pow(m + (uy - vy) * (uy - vy), 1.5);\r\n\r\n        dxx += k * (1 - l * (uy - vy) * (uy - vy) * denom);\r\n        dyy += k * (1 - l * m * denom);\r\n        dxy += k * (l * (ux - vx) * (uy - vy) * denom);\r\n      }\r\n\r\n      // Prevent division by zero\r\n      if (dxx === 0) {\r\n        dxx = 0.1;\r\n      }\r\n\r\n      if (dyy === 0) {\r\n        dyy = 0.1;\r\n      }\r\n\r\n      if (dxy === 0) {\r\n        dxy = 0.1;\r\n      }\r\n\r\n      let dy = (dEX / dxx + dEY / dxy);\r\n      dy /= (dxy / dxx - dyy / dxy); // had to split this onto two lines because the syntax highlighter went crazy.\r\n      let dx = -(dxy * dy + dEX) / dxx;\r\n\r\n      arrPositionX[index] += dx;\r\n      arrPositionY[index] += dy;\r\n\r\n      // Update the energies\r\n      let arrE = matEnergy[index];\r\n      dEX = 0.0;\r\n      dEY = 0.0;\r\n\r\n      ux = arrPositionX[index];\r\n      uy = arrPositionY[index];\r\n\r\n      let vx, vy, prevEx, prevEy, denom;\r\n\r\n      i = length;\r\n      while (i--) {\r\n        if (index === i) {\r\n          continue;\r\n        }\r\n        vx = arrPositionX[i];\r\n        vy = arrPositionY[i];\r\n        // Store old energies\r\n        prevEx = arrE[i][0];\r\n        prevEy = arrE[i][1];\r\n        denom = 1.0 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));\r\n        dx = arrK[i] * ((ux - vx) - arrL[i] * (ux - vx) * denom);\r\n        dy = arrK[i] * ((uy - vy) - arrL[i] * (uy - vy) * denom);\r\n\r\n        arrE[i] = [dx, dy];\r\n        dEX += dx;\r\n        dEY += dy;\r\n        arrEnergySumX[i] += dx - prevEx;\r\n        arrEnergySumY[i] += dy - prevEy;\r\n      }\r\n      arrEnergySumX[index] = dEX;\r\n      arrEnergySumY[index] = dEY;\r\n    }\r\n\r\n    // Setting up variables for the while loops\r\n    let maxEnergyId = 0;\r\n    let dEX = 0.0;\r\n    let dEY = 0.0;\r\n    let delta = 0.0;\r\n    let iteration = 0;\r\n    let innerIteration = 0;\r\n\r\n    while (maxEnergy > threshold && maxIteration > iteration) {\r\n      iteration++;\r\n      [maxEnergyId, maxEnergy, dEX, dEY] = highestEnergy();\r\n      delta = maxEnergy;\r\n      innerIteration = 0;\r\n      while (delta > innerThreshold && maxInnerIteration > innerIteration) {\r\n        innerIteration++;\r\n        update(maxEnergyId, dEX, dEY);\r\n        [delta, dEX, dEY] = energy(maxEnergyId);\r\n      }\r\n    }\r\n\r\n    i = length;\r\n    while (i--) {\r\n      let index = vertexIds[i];\r\n      let vertex = this.vertices[index];\r\n      vertex.position.x = arrPositionX[i];\r\n      vertex.position.y = arrPositionY[i];\r\n      vertex.positioned = true;\r\n      vertex.forcePositioned = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * PRIVATE FUNCTION used by getBridges().\r\n   */\r\n  _bridgeDfs(u, visited, disc, low, parent, adj, outBridges) {\r\n    visited[u] = true;\r\n    disc[u] = low[u] = ++this._time;\r\n\r\n    for (var i = 0; i < adj[u].length; i++) {\r\n      let v = adj[u][i];\r\n\r\n      if (!visited[v]) {\r\n        parent[v] = u;\r\n\r\n        this._bridgeDfs(v, visited, disc, low, parent, adj, outBridges);\r\n\r\n        low[u] = Math.min(low[u], low[v]);\r\n\r\n        // If low > disc, we have a bridge\r\n        if (low[v] > disc[u]) {\r\n          outBridges.push([u, v]);\r\n        }\r\n      } else if (v !== parent[u]) {\r\n        low[u] = Math.min(low[u], disc[v]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the connected components of the graph.\r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Set[]} Connected components as sets.\r\n   */\r\n  static getConnectedComponents(adjacencyMatrix) {\r\n    let length = adjacencyMatrix.length;\r\n    let visited = new Array(length);\r\n    let components = new Array();\r\n    let count = 0;\r\n\r\n    visited.fill(false);\r\n\r\n    for (var u = 0; u < length; u++) {\r\n      if (!visited[u]) {\r\n        let component = Array();\r\n        visited[u] = true;\r\n        component.push(u);\r\n        count++;\r\n        Graph._ccGetDfs(u, visited, adjacencyMatrix, component);\r\n        if (component.length > 1) {\r\n          components.push(component);\r\n        }\r\n      }\r\n    }\r\n\r\n    return components;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of connected components for the graph. \r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Number} The number of connected components of the supplied graph.\r\n   */\r\n  static getConnectedComponentCount(adjacencyMatrix) {\r\n    let length = adjacencyMatrix.length;\r\n    let visited = new Array(length);\r\n    let count = 0;\r\n\r\n    visited.fill(false);\r\n\r\n    for (var u = 0; u < length; u++) {\r\n      if (!visited[u]) {\r\n        visited[u] = true;\r\n        count++;\r\n        Graph._ccCountDfs(u, visited, adjacencyMatrix);\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * PRIVATE FUNCTION used by getConnectedComponentCount().\r\n   */\r\n  static _ccCountDfs(u, visited, adjacencyMatrix) {\r\n    for (var v = 0; v < adjacencyMatrix[u].length; v++) {\r\n      let c = adjacencyMatrix[u][v];\r\n\r\n      if (!c || visited[v] || u === v) {\r\n        continue;\r\n      }\r\n\r\n      visited[v] = true;\r\n      Graph._ccCountDfs(v, visited, adjacencyMatrix);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * PRIVATE FUNCTION used by getConnectedComponents().\r\n   */\r\n  static _ccGetDfs(u, visited, adjacencyMatrix, component) {\r\n    for (var v = 0; v < adjacencyMatrix[u].length; v++) {\r\n      let c = adjacencyMatrix[u][v];\r\n\r\n      if (!c || visited[v] || u === v) {\r\n        continue;\r\n      }\r\n\r\n      visited[v] = true;\r\n      component.push(v);\r\n      Graph._ccGetDfs(v, visited, adjacencyMatrix, component);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Graph"]},"metadata":{},"sourceType":"script"}