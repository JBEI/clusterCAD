{"ast":null,"code":"var _classCallCheck = require(\"/Users/sarahlafrance/LBNL/clusterCAD/static/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sarahlafrance/LBNL/clusterCAD/static/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n// we use the drawer to do all the preprocessing. then we take over the drawing\n// portion to output to svg\nvar ArrayHelper = require('./ArrayHelper');\n\nvar Atom = require('./Atom');\n\nvar Drawer = require('./Drawer');\n\nvar Graph = require('./Graph');\n\nvar Line = require('./Line');\n\nvar SvgWrapper = require('./SvgWrapper');\n\nvar ThemeManager = require('./ThemeManager');\n\nvar Vector2 = require('./Vector2');\n\nvar SvgDrawer = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function SvgDrawer(options) {\n    _classCallCheck(this, SvgDrawer);\n\n    this.preprocessor = new Drawer(options);\n  }\n  /**\r\n   * Draws the parsed smiles data to an svg element.\r\n   *\r\n   * @param {Object} data The tree returned by the smiles parser.\r\n   * @param {(String|HTMLElement)} target The id of the HTML svg element the structure is drawn to - or the element itself.\r\n   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.\r\n   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.\r\n     * @returns {Oject} The dimensions of the drawing in { width, height }\r\n   */\n\n\n  _createClass(SvgDrawer, [{\n    key: \"draw\",\n    value: function draw(data, target) {\n      var themeName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'light';\n      var infoOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var preprocessor = this.preprocessor;\n      preprocessor.initDraw(data, themeName, infoOnly);\n\n      if (!infoOnly) {\n        this.themeManager = new ThemeManager(this.preprocessor.opts.themes, themeName);\n        this.svgWrapper = new SvgWrapper(this.themeManager, target, this.preprocessor.opts);\n      }\n\n      preprocessor.processGraph(); // Set the canvas to the appropriate size\n\n      this.svgWrapper.determineDimensions(preprocessor.graph.vertices); // Do the actual drawing\n\n      this.drawEdges(preprocessor.opts.debug);\n      this.drawVertices(preprocessor.opts.debug);\n\n      if (preprocessor.opts.debug) {\n        console.log(preprocessor.graph);\n        console.log(preprocessor.rings);\n        console.log(preprocessor.ringConnections);\n      }\n\n      return this.svgWrapper.constructSvg();\n    }\n    /**\r\n     * Draws a ring inside a provided ring, indicating aromaticity.\r\n     *\r\n     * @param {Ring} ring A ring.\r\n     */\n\n  }, {\n    key: \"drawAromaticityRing\",\n    value: function drawAromaticityRing(ring) {\n      var ctx = this.ctx;\n      var radius = MathHelper.apothemFromSideLength(this.opts.bondLength, ring.getSize());\n      ctx.save();\n      ctx.strokeStyle = this.getColor('C');\n      ctx.lineWidth = this.opts.bondThickness;\n      ctx.beginPath();\n      ctx.arc(ring.center.x + this.offsetX, ring.center.y + this.offsetY, radius - this.opts.bondSpacing, 0, Math.PI * 2, true);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.restore();\n    }\n    /**\r\n     * Draw the actual edges as bonds.\r\n     *\r\n     * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n     */\n\n  }, {\n    key: \"drawEdges\",\n    value: function drawEdges(debug) {\n      var _this = this;\n\n      var preprocessor = this.preprocessor,\n          graph = preprocessor.graph,\n          rings = preprocessor.rings,\n          drawn = Array(this.preprocessor.graph.edges.length);\n      drawn.fill(false);\n      graph.traverseBF(0, function (vertex) {\n        var edges = graph.getEdges(vertex.id);\n\n        for (var i = 0; i < edges.length; i++) {\n          var edgeId = edges[i];\n\n          if (!drawn[edgeId]) {\n            drawn[edgeId] = true;\n\n            _this.drawEdge(edgeId, debug);\n          }\n        }\n      }); // Draw ring for implicitly defined aromatic rings\n\n      if (!this.bridgedRing) {\n        for (var i = 0; i < rings.length; i++) {\n          var ring = rings[i];\n\n          if (preprocessor.isRingAromatic(ring)) {\n            this.drawAromaticityRing(ring);\n          }\n        }\n      }\n    }\n    /**\r\n     * Draw the an edge as a bond.\r\n     *\r\n     * @param {Number} edgeId An edge id.\r\n     * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n     */\n\n  }, {\n    key: \"drawEdge\",\n    value: function drawEdge(edgeId, debug) {\n      var preprocessor = this.preprocessor,\n          opts = preprocessor.opts,\n          svgWrapper = this.svgWrapper,\n          edge = preprocessor.graph.edges[edgeId],\n          vertexA = preprocessor.graph.vertices[edge.sourceId],\n          vertexB = preprocessor.graph.vertices[edge.targetId],\n          elementA = vertexA.value.element,\n          elementB = vertexB.value.element;\n\n      if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && preprocessor.opts.atomVisualization === 'default') {\n        return;\n      }\n\n      var a = vertexA.position,\n          b = vertexB.position,\n          normals = preprocessor.getEdgeNormals(edge),\n          // Create a point on each side of the line\n      sides = ArrayHelper.clone(normals);\n      sides[0].multiplyScalar(10).add(a);\n      sides[1].multiplyScalar(10).add(a);\n\n      if (edge.bondType === '=' || preprocessor.getRingbondType(vertexA, vertexB) === '=' || edge.isPartOfAromaticRing && preprocessor.bridgedRing) {\n        // Always draw double bonds inside the ring\n        var inRing = preprocessor.areVerticesInSameRing(vertexA, vertexB);\n        var s = preprocessor.chooseSide(vertexA, vertexB, sides);\n\n        if (inRing) {\n          // Always draw double bonds inside a ring\n          // if the bond is shared by two rings, it is drawn in the larger\n          // problem: smaller ring is aromatic, bond is still drawn in larger -> fix this\n          var lcr = preprocessor.getLargestOrAromaticCommonRing(vertexA, vertexB);\n          var center = lcr.center;\n          normals[0].multiplyScalar(opts.bondSpacing);\n          normals[1].multiplyScalar(opts.bondSpacing); // Choose the normal that is on the same side as the center\n\n          var line = null;\n\n          if (center.sameSideAs(vertexA.position, vertexB.position, Vector2.add(a, normals[0]))) {\n            line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\n          } else {\n            line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\n          }\n\n          line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength); // The shortened edge\n\n          if (edge.isPartOfAromaticRing) {\n            // preprocessor.canvasWrapper.drawLine(line, true);\n            svgWrapper.drawLine(line, true);\n          } else {\n            // preprocessor.canvasWrapper.drawLine(line);\n            svgWrapper.drawLine(line);\n          }\n\n          svgWrapper.drawLine(new Line(a, b, elementA, elementB));\n        } else if (edge.center || vertexA.isTerminal() && vertexB.isTerminal() || s.anCount == 0 && s.bnCount > 1 || s.bnCount == 0 && s.anCount > 1) {\n          this.multiplyNormals(normals, opts.halfBondSpacing);\n          var lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB),\n              lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\n          svgWrapper.drawLine(lineA);\n          svgWrapper.drawLine(lineB);\n        } else if (s.sideCount[0] > s.sideCount[1] || s.totalSideCount[0] > s.totalSideCount[1]) {\n          this.multiplyNormals(normals, opts.bondSpacing);\n\n          var _line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\n\n          _line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\n\n          svgWrapper.drawLine(_line);\n          svgWrapper.drawLine(new Line(a, b, elementA, elementB));\n        } else if (s.sideCount[0] < s.sideCount[1] || s.totalSideCount[0] <= s.totalSideCount[1]) {\n          this.multiplyNormals(normals, opts.bondSpacing);\n\n          var _line2 = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\n\n          _line2.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\n\n          svgWrapper.drawLine(_line2);\n          svgWrapper.drawLine(new Line(a, b, elementA, elementB));\n        }\n      } else if (edge.bondType === '#') {\n        normals[0].multiplyScalar(opts.bondSpacing / 1.5);\n        normals[1].multiplyScalar(opts.bondSpacing / 1.5);\n\n        var _lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\n\n        var _lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\n\n        svgWrapper.drawLine(_lineA);\n        svgWrapper.drawLine(_lineB);\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\n      } else if (edge.bondType === '.') {// TODO: Something... maybe... version 2?\n      } else {\n        var isChiralCenterA = vertexA.value.isStereoCenter;\n        var isChiralCenterB = vertexB.value.isStereoCenter;\n\n        if (edge.wedge === 'up') {\n          svgWrapper.drawWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\n        } else if (edge.wedge === 'down') {\n          svgWrapper.drawDashedWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\n        } else {\n          svgWrapper.drawLine(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\n        }\n      }\n\n      if (debug) {\n        var midpoint = Vector2.midpoint(a, b);\n        svgWrapper.drawDebugText(midpoint.x, midpoint.y, 'e: ' + edgeId);\n      }\n    }\n    /**\r\n     * Draws the vertices representing atoms to the canvas.\r\n     *\r\n     * @param {Boolean} debug A boolean indicating whether or not to draw debug messages to the canvas.\r\n     */\n\n  }, {\n    key: \"drawVertices\",\n    value: function drawVertices(debug) {\n      var preprocessor = this.preprocessor,\n          opts = preprocessor.opts,\n          graph = preprocessor.graph,\n          rings = preprocessor.rings,\n          svgWrapper = this.svgWrapper;\n      var i = graph.vertices.length;\n\n      for (var i = 0; i < graph.vertices.length; i++) {\n        var vertex = graph.vertices[i];\n        var atom = vertex.value;\n        var charge = 0;\n        var isotope = 0;\n        var bondCount = vertex.value.bondCount;\n        var element = atom.element;\n        var hydrogens = Atom.maxBonds[element] - bondCount;\n        var dir = vertex.getTextDirection(graph.vertices);\n        var isTerminal = opts.terminalCarbons || element !== 'C' || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;\n        var isCarbon = atom.element === 'C'; // This is a HACK to remove all hydrogens from nitrogens in aromatic rings, as this\n        // should be the most common state. This has to be fixed by kekulization\n\n        if (atom.element === 'N' && atom.isPartOfAromaticRing) {\n          hydrogens = 0;\n        }\n\n        if (atom.bracket) {\n          hydrogens = atom.bracket.hcount;\n          charge = atom.bracket.charge;\n          isotope = atom.bracket.isotope;\n        }\n\n        if (opts.atomVisualization === 'allballs') {\n          svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);\n        } else if (atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements) || graph.vertices.length === 1) {\n          if (opts.atomVisualization === 'default') {\n            svgWrapper.drawText(vertex.position.x, vertex.position.y, element, hydrogens, dir, isTerminal, charge, isotope, atom.getAttachedPseudoElements());\n          } else if (opts.atomVisualization === 'balls') {\n            svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);\n          }\n        } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned == true) {\n          // If there is a carbon which bonds are in a straight line, draw a dot\n          var a = graph.vertices[vertex.neighbours[0]].position;\n          var b = graph.vertices[vertex.neighbours[1]].position;\n          var angle = Vector2.threePointangle(vertex.position, a, b);\n\n          if (Math.abs(Math.PI - angle) < 0.1) {\n            svgWrapper.drawPoint(vertex.position.x, vertex.position.y, element);\n          }\n        }\n\n        if (debug) {\n          var value = 'v: ' + vertex.id + ' ' + ArrayHelper.print(atom.ringbonds);\n          svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);\n        } else {\n          svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, vertex.value.chirality);\n        }\n      } // Draw the ring centers for debug purposes\n\n\n      if (opts.debug) {\n        for (var i = 0; i < rings.length; i++) {\n          var center = rings[i].center;\n          svgWrapper.drawDebugPoint(center.x, center.y, 'r: ' + rings[i].id);\n        }\n      }\n    }\n    /**\r\n     * Returns the total overlap score of the current molecule.\r\n     *\r\n     * @returns {Number} The overlap score.\r\n     */\n\n  }, {\n    key: \"getTotalOverlapScore\",\n    value: function getTotalOverlapScore() {\n      return this.preprocessor.getTotalOverlapScore();\n    }\n    /**\r\n     * Returns the molecular formula of the loaded molecule as a string.\r\n     *\r\n     * @returns {String} The molecular formula.\r\n     */\n\n  }, {\n    key: \"getMolecularFormula\",\n    value: function getMolecularFormula() {\n      return this.preprocessor.getMolecularFormula();\n    }\n    /**\r\n     * @param {Array} normals list of normals to multiply\r\n     * @param {Number} spacing value to multiply normals by\r\n     */\n\n  }, {\n    key: \"multiplyNormals\",\n    value: function multiplyNormals(normals, spacing) {\n      normals[0].multiplyScalar(spacing);\n      normals[1].multiplyScalar(spacing);\n    }\n  }]);\n\n  return SvgDrawer;\n}();\n\nmodule.exports = SvgDrawer;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/static/retrotideUI/node_modules/smiles-drawer/src/SvgDrawer.js"],"names":["ArrayHelper","require","Atom","Drawer","Graph","Line","SvgWrapper","ThemeManager","Vector2","SvgDrawer","options","preprocessor","data","target","themeName","infoOnly","initDraw","themeManager","opts","themes","svgWrapper","processGraph","determineDimensions","graph","vertices","drawEdges","debug","drawVertices","console","log","rings","ringConnections","constructSvg","ring","ctx","radius","MathHelper","apothemFromSideLength","bondLength","getSize","save","strokeStyle","getColor","lineWidth","bondThickness","beginPath","arc","center","x","offsetX","y","offsetY","bondSpacing","Math","PI","closePath","stroke","restore","drawn","Array","edges","length","fill","traverseBF","vertex","getEdges","id","i","edgeId","drawEdge","bridgedRing","isRingAromatic","drawAromaticityRing","edge","vertexA","sourceId","vertexB","targetId","elementA","value","element","elementB","isDrawn","atomVisualization","a","position","b","normals","getEdgeNormals","sides","clone","multiplyScalar","add","bondType","getRingbondType","isPartOfAromaticRing","inRing","areVerticesInSameRing","s","chooseSide","lcr","getLargestOrAromaticCommonRing","line","sameSideAs","shorten","shortBondLength","drawLine","isTerminal","anCount","bnCount","multiplyNormals","halfBondSpacing","lineA","lineB","sideCount","totalSideCount","isChiralCenterA","isStereoCenter","isChiralCenterB","wedge","drawWedge","drawDashedWedge","midpoint","drawDebugText","atom","charge","isotope","bondCount","hydrogens","maxBonds","dir","getTextDirection","terminalCarbons","hasAttachedPseudoElements","isCarbon","bracket","hcount","drawBall","drawExplicit","drawText","getAttachedPseudoElements","getNeighbourCount","forcePositioned","neighbours","angle","threePointangle","abs","drawPoint","print","ringbonds","chirality","drawDebugPoint","getTotalOverlapScore","getMolecularFormula","spacing","module","exports"],"mappings":"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","sourcesContent":["// we use the drawer to do all the preprocessing. then we take over the drawing\r\n// portion to output to svg\r\nconst ArrayHelper = require('./ArrayHelper');\r\nconst Atom = require('./Atom');\r\nconst Drawer = require('./Drawer');\r\nconst Graph = require('./Graph');\r\nconst Line = require('./Line');\r\nconst SvgWrapper = require('./SvgWrapper');\r\nconst ThemeManager = require('./ThemeManager');\r\nconst Vector2 = require('./Vector2');\r\n\r\nclass SvgDrawer {\r\n  constructor(options) {\r\n    this.preprocessor = new Drawer(options);\r\n  }\r\n\r\n  /**\r\n   * Draws the parsed smiles data to an svg element.\r\n   *\r\n   * @param {Object} data The tree returned by the smiles parser.\r\n   * @param {(String|HTMLElement)} target The id of the HTML svg element the structure is drawn to - or the element itself.\r\n   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.\r\n   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.\r\n\r\n   * @returns {Oject} The dimensions of the drawing in { width, height }\r\n   */\r\n  draw(data, target, themeName = 'light', infoOnly = false) {\r\n    let preprocessor = this.preprocessor;\r\n\r\n    preprocessor.initDraw(data, themeName, infoOnly);\r\n\r\n    if (!infoOnly) {\r\n      this.themeManager = new ThemeManager(this.preprocessor.opts.themes, themeName);\r\n      this.svgWrapper = new SvgWrapper(this.themeManager, target, this.preprocessor.opts);\r\n    }\r\n\r\n    preprocessor.processGraph();\r\n\r\n    // Set the canvas to the appropriate size\r\n    this.svgWrapper.determineDimensions(preprocessor.graph.vertices);\r\n\r\n    // Do the actual drawing\r\n    this.drawEdges(preprocessor.opts.debug);\r\n    this.drawVertices(preprocessor.opts.debug);\r\n\r\n    if (preprocessor.opts.debug) {\r\n      console.log(preprocessor.graph);\r\n      console.log(preprocessor.rings);\r\n      console.log(preprocessor.ringConnections);\r\n    }\r\n\r\n    return this.svgWrapper.constructSvg();\r\n  }\r\n\r\n  /**\r\n   * Draws a ring inside a provided ring, indicating aromaticity.\r\n   *\r\n   * @param {Ring} ring A ring.\r\n   */\r\n  drawAromaticityRing(ring) {\r\n    let ctx = this.ctx;\r\n    let radius = MathHelper.apothemFromSideLength(this.opts.bondLength, ring.getSize());\r\n\r\n    ctx.save();\r\n    ctx.strokeStyle = this.getColor('C');\r\n    ctx.lineWidth = this.opts.bondThickness;\r\n    ctx.beginPath();\r\n    ctx.arc(ring.center.x + this.offsetX, ring.center.y + this.offsetY,\r\n      radius - this.opts.bondSpacing, 0, Math.PI * 2, true);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Draw the actual edges as bonds.\r\n   *\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n   */\r\n  drawEdges(debug) {\r\n    let preprocessor = this.preprocessor,\r\n      graph = preprocessor.graph,\r\n      rings = preprocessor.rings,\r\n      drawn = Array(this.preprocessor.graph.edges.length);\r\n\r\n    drawn.fill(false);\r\n\r\n    graph.traverseBF(0, vertex => {\r\n      let edges = graph.getEdges(vertex.id);\r\n      for (var i = 0; i < edges.length; i++) {\r\n        let edgeId = edges[i];\r\n        if (!drawn[edgeId]) {\r\n          drawn[edgeId] = true;\r\n          this.drawEdge(edgeId, debug);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Draw ring for implicitly defined aromatic rings\r\n    if (!this.bridgedRing) {\r\n      for (var i = 0; i < rings.length; i++) {\r\n        let ring = rings[i];\r\n\r\n        if (preprocessor.isRingAromatic(ring)) {\r\n          this.drawAromaticityRing(ring);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw the an edge as a bond.\r\n   *\r\n   * @param {Number} edgeId An edge id.\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n   */\r\n  drawEdge(edgeId, debug) {\r\n    let preprocessor = this.preprocessor,\r\n      opts = preprocessor.opts,\r\n      svgWrapper = this.svgWrapper,\r\n      edge = preprocessor.graph.edges[edgeId],\r\n      vertexA = preprocessor.graph.vertices[edge.sourceId],\r\n      vertexB = preprocessor.graph.vertices[edge.targetId],\r\n      elementA = vertexA.value.element,\r\n      elementB = vertexB.value.element;\r\n\r\n    if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && preprocessor.opts.atomVisualization === 'default') {\r\n      return;\r\n    }\r\n\r\n    let a = vertexA.position,\r\n      b = vertexB.position,\r\n      normals = preprocessor.getEdgeNormals(edge),\r\n      // Create a point on each side of the line\r\n      sides = ArrayHelper.clone(normals);\r\n\r\n    sides[0].multiplyScalar(10).add(a);\r\n    sides[1].multiplyScalar(10).add(a);\r\n\r\n    if (edge.bondType === '=' || preprocessor.getRingbondType(vertexA, vertexB) === '=' ||\r\n      (edge.isPartOfAromaticRing && preprocessor.bridgedRing)) {\r\n      // Always draw double bonds inside the ring\r\n      let inRing = preprocessor.areVerticesInSameRing(vertexA, vertexB);\r\n      let s = preprocessor.chooseSide(vertexA, vertexB, sides);\r\n\r\n      if (inRing) {\r\n        // Always draw double bonds inside a ring\r\n        // if the bond is shared by two rings, it is drawn in the larger\r\n        // problem: smaller ring is aromatic, bond is still drawn in larger -> fix this\r\n        let lcr = preprocessor.getLargestOrAromaticCommonRing(vertexA, vertexB);\r\n        let center = lcr.center;\r\n\r\n        normals[0].multiplyScalar(opts.bondSpacing);\r\n        normals[1].multiplyScalar(opts.bondSpacing);\r\n\r\n        // Choose the normal that is on the same side as the center\r\n        let line = null;\r\n\r\n        if (center.sameSideAs(vertexA.position, vertexB.position, Vector2.add(a, normals[0]))) {\r\n          line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\r\n        } else {\r\n          line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\r\n        }\r\n\r\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\r\n\r\n        // The shortened edge\r\n        if (edge.isPartOfAromaticRing) {\r\n          // preprocessor.canvasWrapper.drawLine(line, true);\r\n          svgWrapper.drawLine(line, true);\r\n        } else {\r\n          // preprocessor.canvasWrapper.drawLine(line);\r\n          svgWrapper.drawLine(line);\r\n        }\r\n\r\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\r\n      } else if ((edge.center || vertexA.isTerminal() && vertexB.isTerminal()) ||\r\n        (s.anCount == 0 && s.bnCount > 1 || s.bnCount == 0 && s.anCount > 1)) {\r\n        this.multiplyNormals(normals, opts.halfBondSpacing);\r\n\r\n        let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB),\r\n          lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n        svgWrapper.drawLine(lineA);\r\n        svgWrapper.drawLine(lineB);\r\n      } else if ((s.sideCount[0] > s.sideCount[1]) ||\r\n        (s.totalSideCount[0] > s.totalSideCount[1])) {\r\n        this.multiplyNormals(normals, opts.bondSpacing);\r\n\r\n        let line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\r\n\r\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\r\n\r\n        svgWrapper.drawLine(line);\r\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\r\n      } else if ((s.sideCount[0] < s.sideCount[1]) ||\r\n        (s.totalSideCount[0] <= s.totalSideCount[1])) {\r\n        this.multiplyNormals(normals, opts.bondSpacing);\r\n\r\n        let line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\r\n        svgWrapper.drawLine(line);\r\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\r\n      }\r\n    } else if (edge.bondType === '#') {\r\n      normals[0].multiplyScalar(opts.bondSpacing / 1.5);\r\n      normals[1].multiplyScalar(opts.bondSpacing / 1.5);\r\n\r\n      let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\r\n      let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n      svgWrapper.drawLine(lineA);\r\n      svgWrapper.drawLine(lineB);\r\n      svgWrapper.drawLine(new Line(a, b, elementA, elementB));\r\n    } else if (edge.bondType === '.') {\r\n      // TODO: Something... maybe... version 2?\r\n    } else {\r\n      let isChiralCenterA = vertexA.value.isStereoCenter;\r\n      let isChiralCenterB = vertexB.value.isStereoCenter;\r\n\r\n      if (edge.wedge === 'up') {\r\n        svgWrapper.drawWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      } else if (edge.wedge === 'down') {\r\n        svgWrapper.drawDashedWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      } else {\r\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      }\r\n    }\r\n\r\n    if (debug) {\r\n      let midpoint = Vector2.midpoint(a, b);\r\n      svgWrapper.drawDebugText(midpoint.x, midpoint.y, 'e: ' + edgeId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draws the vertices representing atoms to the canvas.\r\n   *\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug messages to the canvas.\r\n   */\r\n  drawVertices(debug) {\r\n    let preprocessor = this.preprocessor,\r\n      opts = preprocessor.opts,\r\n      graph = preprocessor.graph,\r\n      rings = preprocessor.rings,\r\n      svgWrapper = this.svgWrapper;\r\n\r\n    var i = graph.vertices.length;\r\n    for (var i = 0; i < graph.vertices.length; i++) {\r\n      let vertex = graph.vertices[i];\r\n      let atom = vertex.value;\r\n      let charge = 0;\r\n      let isotope = 0;\r\n      let bondCount = vertex.value.bondCount;\r\n      let element = atom.element;\r\n      let hydrogens = Atom.maxBonds[element] - bondCount;\r\n      let dir = vertex.getTextDirection(graph.vertices);\r\n      let isTerminal = opts.terminalCarbons || element !== 'C' || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;\r\n      let isCarbon = atom.element === 'C';\r\n\r\n      // This is a HACK to remove all hydrogens from nitrogens in aromatic rings, as this\r\n      // should be the most common state. This has to be fixed by kekulization\r\n      if (atom.element === 'N' && atom.isPartOfAromaticRing) {\r\n        hydrogens = 0;\r\n      }\r\n\r\n      if (atom.bracket) {\r\n        hydrogens = atom.bracket.hcount;\r\n        charge = atom.bracket.charge;\r\n        isotope = atom.bracket.isotope;\r\n      }\r\n\r\n      if (opts.atomVisualization === 'allballs') {\r\n        svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);\r\n      } else if ((atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements)) || graph.vertices.length === 1) {\r\n        if (opts.atomVisualization === 'default') {\r\n          svgWrapper.drawText(vertex.position.x, vertex.position.y,\r\n            element, hydrogens, dir, isTerminal, charge, isotope, atom.getAttachedPseudoElements());\r\n        } else if (opts.atomVisualization === 'balls') {\r\n          svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);\r\n        }\r\n      } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned == true) {\r\n        // If there is a carbon which bonds are in a straight line, draw a dot\r\n        let a = graph.vertices[vertex.neighbours[0]].position;\r\n        let b = graph.vertices[vertex.neighbours[1]].position;\r\n        let angle = Vector2.threePointangle(vertex.position, a, b);\r\n\r\n        if (Math.abs(Math.PI - angle) < 0.1) {\r\n          svgWrapper.drawPoint(vertex.position.x, vertex.position.y, element);\r\n        }\r\n      }\r\n\r\n      if (debug) {\r\n        let value = 'v: ' + vertex.id + ' ' + ArrayHelper.print(atom.ringbonds);\r\n        svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);\r\n      } else {\r\n        svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, vertex.value.chirality);\r\n      }\r\n    }\r\n\r\n    // Draw the ring centers for debug purposes\r\n    if (opts.debug) {\r\n      for (var i = 0; i < rings.length; i++) {\r\n        let center = rings[i].center;\r\n        svgWrapper.drawDebugPoint(center.x, center.y, 'r: ' + rings[i].id);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the total overlap score of the current molecule.\r\n   *\r\n   * @returns {Number} The overlap score.\r\n   */\r\n  getTotalOverlapScore() {\r\n    return this.preprocessor.getTotalOverlapScore();\r\n  }\r\n\r\n  /**\r\n   * Returns the molecular formula of the loaded molecule as a string.\r\n   *\r\n   * @returns {String} The molecular formula.\r\n   */\r\n  getMolecularFormula() {\r\n    return this.preprocessor.getMolecularFormula();\r\n  }\r\n\r\n  /**\r\n   * @param {Array} normals list of normals to multiply\r\n   * @param {Number} spacing value to multiply normals by\r\n   */\r\n  multiplyNormals(normals, spacing) {\r\n    normals[0].multiplyScalar(spacing);\r\n    normals[1].multiplyScalar(spacing);\r\n  }\r\n}\r\n\r\nmodule.exports = SvgDrawer;"]},"metadata":{},"sourceType":"script"}