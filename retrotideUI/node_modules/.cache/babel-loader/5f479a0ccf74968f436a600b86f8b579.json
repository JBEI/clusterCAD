{"ast":null,"code":"// we use the drawer to do all the preprocessing. then we take over the drawing\n// portion to output to svg\nconst ArrayHelper = require('./ArrayHelper');\n\nconst Atom = require('./Atom');\n\nconst Drawer = require('./Drawer');\n\nconst Graph = require('./Graph');\n\nconst Line = require('./Line');\n\nconst SvgWrapper = require('./SvgWrapper');\n\nconst ThemeManager = require('./ThemeManager');\n\nconst Vector2 = require('./Vector2');\n\nclass SvgDrawer {\n  constructor(options) {\n    this.preprocessor = new Drawer(options);\n  }\n  /**\r\n   * Draws the parsed smiles data to an svg element.\r\n   *\r\n   * @param {Object} data The tree returned by the smiles parser.\r\n   * @param {(String|HTMLElement)} target The id of the HTML svg element the structure is drawn to - or the element itself.\r\n   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.\r\n   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.\r\n     * @returns {Oject} The dimensions of the drawing in { width, height }\r\n   */\n\n\n  draw(data, target, themeName = 'light', infoOnly = false) {\n    let preprocessor = this.preprocessor;\n    preprocessor.initDraw(data, themeName, infoOnly);\n\n    if (!infoOnly) {\n      this.themeManager = new ThemeManager(this.preprocessor.opts.themes, themeName);\n      this.svgWrapper = new SvgWrapper(this.themeManager, target, this.preprocessor.opts);\n    }\n\n    preprocessor.processGraph(); // Set the canvas to the appropriate size\n\n    this.svgWrapper.determineDimensions(preprocessor.graph.vertices); // Do the actual drawing\n\n    this.drawEdges(preprocessor.opts.debug);\n    this.drawVertices(preprocessor.opts.debug);\n\n    if (preprocessor.opts.debug) {\n      console.log(preprocessor.graph);\n      console.log(preprocessor.rings);\n      console.log(preprocessor.ringConnections);\n    }\n\n    return this.svgWrapper.constructSvg();\n  }\n  /**\r\n   * Draws a ring inside a provided ring, indicating aromaticity.\r\n   *\r\n   * @param {Ring} ring A ring.\r\n   */\n\n\n  drawAromaticityRing(ring) {\n    let ctx = this.ctx;\n    let radius = MathHelper.apothemFromSideLength(this.opts.bondLength, ring.getSize());\n    ctx.save();\n    ctx.strokeStyle = this.getColor('C');\n    ctx.lineWidth = this.opts.bondThickness;\n    ctx.beginPath();\n    ctx.arc(ring.center.x + this.offsetX, ring.center.y + this.offsetY, radius - this.opts.bondSpacing, 0, Math.PI * 2, true);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n  }\n  /**\r\n   * Draw the actual edges as bonds.\r\n   *\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n   */\n\n\n  drawEdges(debug) {\n    let preprocessor = this.preprocessor,\n        graph = preprocessor.graph,\n        rings = preprocessor.rings,\n        drawn = Array(this.preprocessor.graph.edges.length);\n    drawn.fill(false);\n    graph.traverseBF(0, vertex => {\n      let edges = graph.getEdges(vertex.id);\n\n      for (var i = 0; i < edges.length; i++) {\n        let edgeId = edges[i];\n\n        if (!drawn[edgeId]) {\n          drawn[edgeId] = true;\n          this.drawEdge(edgeId, debug);\n        }\n      }\n    }); // Draw ring for implicitly defined aromatic rings\n\n    if (!this.bridgedRing) {\n      for (var i = 0; i < rings.length; i++) {\n        let ring = rings[i];\n\n        if (preprocessor.isRingAromatic(ring)) {\n          this.drawAromaticityRing(ring);\n        }\n      }\n    }\n  }\n  /**\r\n   * Draw the an edge as a bond.\r\n   *\r\n   * @param {Number} edgeId An edge id.\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n   */\n\n\n  drawEdge(edgeId, debug) {\n    let preprocessor = this.preprocessor,\n        opts = preprocessor.opts,\n        svgWrapper = this.svgWrapper,\n        edge = preprocessor.graph.edges[edgeId],\n        vertexA = preprocessor.graph.vertices[edge.sourceId],\n        vertexB = preprocessor.graph.vertices[edge.targetId],\n        elementA = vertexA.value.element,\n        elementB = vertexB.value.element;\n\n    if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && preprocessor.opts.atomVisualization === 'default') {\n      return;\n    }\n\n    let a = vertexA.position,\n        b = vertexB.position,\n        normals = preprocessor.getEdgeNormals(edge),\n        // Create a point on each side of the line\n    sides = ArrayHelper.clone(normals);\n    sides[0].multiplyScalar(10).add(a);\n    sides[1].multiplyScalar(10).add(a);\n\n    if (edge.bondType === '=' || preprocessor.getRingbondType(vertexA, vertexB) === '=' || edge.isPartOfAromaticRing && preprocessor.bridgedRing) {\n      // Always draw double bonds inside the ring\n      let inRing = preprocessor.areVerticesInSameRing(vertexA, vertexB);\n      let s = preprocessor.chooseSide(vertexA, vertexB, sides);\n\n      if (inRing) {\n        // Always draw double bonds inside a ring\n        // if the bond is shared by two rings, it is drawn in the larger\n        // problem: smaller ring is aromatic, bond is still drawn in larger -> fix this\n        let lcr = preprocessor.getLargestOrAromaticCommonRing(vertexA, vertexB);\n        let center = lcr.center;\n        normals[0].multiplyScalar(opts.bondSpacing);\n        normals[1].multiplyScalar(opts.bondSpacing); // Choose the normal that is on the same side as the center\n\n        let line = null;\n\n        if (center.sameSideAs(vertexA.position, vertexB.position, Vector2.add(a, normals[0]))) {\n          line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\n        } else {\n          line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\n        }\n\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength); // The shortened edge\n\n        if (edge.isPartOfAromaticRing) {\n          // preprocessor.canvasWrapper.drawLine(line, true);\n          svgWrapper.drawLine(line, true);\n        } else {\n          // preprocessor.canvasWrapper.drawLine(line);\n          svgWrapper.drawLine(line);\n        }\n\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\n      } else if (edge.center || vertexA.isTerminal() && vertexB.isTerminal() || s.anCount == 0 && s.bnCount > 1 || s.bnCount == 0 && s.anCount > 1) {\n        this.multiplyNormals(normals, opts.halfBondSpacing);\n        let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB),\n            lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\n        svgWrapper.drawLine(lineA);\n        svgWrapper.drawLine(lineB);\n      } else if (s.sideCount[0] > s.sideCount[1] || s.totalSideCount[0] > s.totalSideCount[1]) {\n        this.multiplyNormals(normals, opts.bondSpacing);\n        let line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\n        svgWrapper.drawLine(line);\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\n      } else if (s.sideCount[0] < s.sideCount[1] || s.totalSideCount[0] <= s.totalSideCount[1]) {\n        this.multiplyNormals(normals, opts.bondSpacing);\n        let line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\n        svgWrapper.drawLine(line);\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\n      }\n    } else if (edge.bondType === '#') {\n      normals[0].multiplyScalar(opts.bondSpacing / 1.5);\n      normals[1].multiplyScalar(opts.bondSpacing / 1.5);\n      let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\n      let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\n      svgWrapper.drawLine(lineA);\n      svgWrapper.drawLine(lineB);\n      svgWrapper.drawLine(new Line(a, b, elementA, elementB));\n    } else if (edge.bondType === '.') {// TODO: Something... maybe... version 2?\n    } else {\n      let isChiralCenterA = vertexA.value.isStereoCenter;\n      let isChiralCenterB = vertexB.value.isStereoCenter;\n\n      if (edge.wedge === 'up') {\n        svgWrapper.drawWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\n      } else if (edge.wedge === 'down') {\n        svgWrapper.drawDashedWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\n      } else {\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\n      }\n    }\n\n    if (debug) {\n      let midpoint = Vector2.midpoint(a, b);\n      svgWrapper.drawDebugText(midpoint.x, midpoint.y, 'e: ' + edgeId);\n    }\n  }\n  /**\r\n   * Draws the vertices representing atoms to the canvas.\r\n   *\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug messages to the canvas.\r\n   */\n\n\n  drawVertices(debug) {\n    let preprocessor = this.preprocessor,\n        opts = preprocessor.opts,\n        graph = preprocessor.graph,\n        rings = preprocessor.rings,\n        svgWrapper = this.svgWrapper;\n    var i = graph.vertices.length;\n\n    for (var i = 0; i < graph.vertices.length; i++) {\n      let vertex = graph.vertices[i];\n      let atom = vertex.value;\n      let charge = 0;\n      let isotope = 0;\n      let bondCount = vertex.value.bondCount;\n      let element = atom.element;\n      let hydrogens = Atom.maxBonds[element] - bondCount;\n      let dir = vertex.getTextDirection(graph.vertices);\n      let isTerminal = opts.terminalCarbons || element !== 'C' || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;\n      let isCarbon = atom.element === 'C'; // This is a HACK to remove all hydrogens from nitrogens in aromatic rings, as this\n      // should be the most common state. This has to be fixed by kekulization\n\n      if (atom.element === 'N' && atom.isPartOfAromaticRing) {\n        hydrogens = 0;\n      }\n\n      if (atom.bracket) {\n        hydrogens = atom.bracket.hcount;\n        charge = atom.bracket.charge;\n        isotope = atom.bracket.isotope;\n      }\n\n      if (opts.atomVisualization === 'allballs') {\n        svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);\n      } else if (atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements) || graph.vertices.length === 1) {\n        if (opts.atomVisualization === 'default') {\n          svgWrapper.drawText(vertex.position.x, vertex.position.y, element, hydrogens, dir, isTerminal, charge, isotope, atom.getAttachedPseudoElements());\n        } else if (opts.atomVisualization === 'balls') {\n          svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);\n        }\n      } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned == true) {\n        // If there is a carbon which bonds are in a straight line, draw a dot\n        let a = graph.vertices[vertex.neighbours[0]].position;\n        let b = graph.vertices[vertex.neighbours[1]].position;\n        let angle = Vector2.threePointangle(vertex.position, a, b);\n\n        if (Math.abs(Math.PI - angle) < 0.1) {\n          svgWrapper.drawPoint(vertex.position.x, vertex.position.y, element);\n        }\n      }\n\n      if (debug) {\n        let value = 'v: ' + vertex.id + ' ' + ArrayHelper.print(atom.ringbonds);\n        svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);\n      } else {\n        svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, vertex.value.chirality);\n      }\n    } // Draw the ring centers for debug purposes\n\n\n    if (opts.debug) {\n      for (var i = 0; i < rings.length; i++) {\n        let center = rings[i].center;\n        svgWrapper.drawDebugPoint(center.x, center.y, 'r: ' + rings[i].id);\n      }\n    }\n  }\n  /**\r\n   * Returns the total overlap score of the current molecule.\r\n   *\r\n   * @returns {Number} The overlap score.\r\n   */\n\n\n  getTotalOverlapScore() {\n    return this.preprocessor.getTotalOverlapScore();\n  }\n  /**\r\n   * Returns the molecular formula of the loaded molecule as a string.\r\n   *\r\n   * @returns {String} The molecular formula.\r\n   */\n\n\n  getMolecularFormula() {\n    return this.preprocessor.getMolecularFormula();\n  }\n  /**\r\n   * @param {Array} normals list of normals to multiply\r\n   * @param {Number} spacing value to multiply normals by\r\n   */\n\n\n  multiplyNormals(normals, spacing) {\n    normals[0].multiplyScalar(spacing);\n    normals[1].multiplyScalar(spacing);\n  }\n\n}\n\nmodule.exports = SvgDrawer;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/smiles-drawer/src/SvgDrawer.js"],"names":["ArrayHelper","require","Atom","Drawer","Graph","Line","SvgWrapper","ThemeManager","Vector2","SvgDrawer","constructor","options","preprocessor","draw","data","target","themeName","infoOnly","initDraw","themeManager","opts","themes","svgWrapper","processGraph","determineDimensions","graph","vertices","drawEdges","debug","drawVertices","console","log","rings","ringConnections","constructSvg","drawAromaticityRing","ring","ctx","radius","MathHelper","apothemFromSideLength","bondLength","getSize","save","strokeStyle","getColor","lineWidth","bondThickness","beginPath","arc","center","x","offsetX","y","offsetY","bondSpacing","Math","PI","closePath","stroke","restore","drawn","Array","edges","length","fill","traverseBF","vertex","getEdges","id","i","edgeId","drawEdge","bridgedRing","isRingAromatic","edge","vertexA","sourceId","vertexB","targetId","elementA","value","element","elementB","isDrawn","atomVisualization","a","position","b","normals","getEdgeNormals","sides","clone","multiplyScalar","add","bondType","getRingbondType","isPartOfAromaticRing","inRing","areVerticesInSameRing","s","chooseSide","lcr","getLargestOrAromaticCommonRing","line","sameSideAs","shorten","shortBondLength","drawLine","isTerminal","anCount","bnCount","multiplyNormals","halfBondSpacing","lineA","lineB","sideCount","totalSideCount","isChiralCenterA","isStereoCenter","isChiralCenterB","wedge","drawWedge","drawDashedWedge","midpoint","drawDebugText","atom","charge","isotope","bondCount","hydrogens","maxBonds","dir","getTextDirection","terminalCarbons","hasAttachedPseudoElements","isCarbon","bracket","hcount","drawBall","drawExplicit","drawText","getAttachedPseudoElements","getNeighbourCount","forcePositioned","neighbours","angle","threePointangle","abs","drawPoint","print","ringbonds","chirality","drawDebugPoint","getTotalOverlapScore","getMolecularFormula","spacing","module","exports"],"mappings":"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","sourcesContent":["// we use the drawer to do all the preprocessing. then we take over the drawing\r\n// portion to output to svg\r\nconst ArrayHelper = require('./ArrayHelper');\r\nconst Atom = require('./Atom');\r\nconst Drawer = require('./Drawer');\r\nconst Graph = require('./Graph');\r\nconst Line = require('./Line');\r\nconst SvgWrapper = require('./SvgWrapper');\r\nconst ThemeManager = require('./ThemeManager');\r\nconst Vector2 = require('./Vector2');\r\n\r\nclass SvgDrawer {\r\n  constructor(options) {\r\n    this.preprocessor = new Drawer(options);\r\n  }\r\n\r\n  /**\r\n   * Draws the parsed smiles data to an svg element.\r\n   *\r\n   * @param {Object} data The tree returned by the smiles parser.\r\n   * @param {(String|HTMLElement)} target The id of the HTML svg element the structure is drawn to - or the element itself.\r\n   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.\r\n   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.\r\n\r\n   * @returns {Oject} The dimensions of the drawing in { width, height }\r\n   */\r\n  draw(data, target, themeName = 'light', infoOnly = false) {\r\n    let preprocessor = this.preprocessor;\r\n\r\n    preprocessor.initDraw(data, themeName, infoOnly);\r\n\r\n    if (!infoOnly) {\r\n      this.themeManager = new ThemeManager(this.preprocessor.opts.themes, themeName);\r\n      this.svgWrapper = new SvgWrapper(this.themeManager, target, this.preprocessor.opts);\r\n    }\r\n\r\n    preprocessor.processGraph();\r\n\r\n    // Set the canvas to the appropriate size\r\n    this.svgWrapper.determineDimensions(preprocessor.graph.vertices);\r\n\r\n    // Do the actual drawing\r\n    this.drawEdges(preprocessor.opts.debug);\r\n    this.drawVertices(preprocessor.opts.debug);\r\n\r\n    if (preprocessor.opts.debug) {\r\n      console.log(preprocessor.graph);\r\n      console.log(preprocessor.rings);\r\n      console.log(preprocessor.ringConnections);\r\n    }\r\n\r\n    return this.svgWrapper.constructSvg();\r\n  }\r\n\r\n  /**\r\n   * Draws a ring inside a provided ring, indicating aromaticity.\r\n   *\r\n   * @param {Ring} ring A ring.\r\n   */\r\n  drawAromaticityRing(ring) {\r\n    let ctx = this.ctx;\r\n    let radius = MathHelper.apothemFromSideLength(this.opts.bondLength, ring.getSize());\r\n\r\n    ctx.save();\r\n    ctx.strokeStyle = this.getColor('C');\r\n    ctx.lineWidth = this.opts.bondThickness;\r\n    ctx.beginPath();\r\n    ctx.arc(ring.center.x + this.offsetX, ring.center.y + this.offsetY,\r\n      radius - this.opts.bondSpacing, 0, Math.PI * 2, true);\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Draw the actual edges as bonds.\r\n   *\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n   */\r\n  drawEdges(debug) {\r\n    let preprocessor = this.preprocessor,\r\n      graph = preprocessor.graph,\r\n      rings = preprocessor.rings,\r\n      drawn = Array(this.preprocessor.graph.edges.length);\r\n\r\n    drawn.fill(false);\r\n\r\n    graph.traverseBF(0, vertex => {\r\n      let edges = graph.getEdges(vertex.id);\r\n      for (var i = 0; i < edges.length; i++) {\r\n        let edgeId = edges[i];\r\n        if (!drawn[edgeId]) {\r\n          drawn[edgeId] = true;\r\n          this.drawEdge(edgeId, debug);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Draw ring for implicitly defined aromatic rings\r\n    if (!this.bridgedRing) {\r\n      for (var i = 0; i < rings.length; i++) {\r\n        let ring = rings[i];\r\n\r\n        if (preprocessor.isRingAromatic(ring)) {\r\n          this.drawAromaticityRing(ring);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw the an edge as a bond.\r\n   *\r\n   * @param {Number} edgeId An edge id.\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.\r\n   */\r\n  drawEdge(edgeId, debug) {\r\n    let preprocessor = this.preprocessor,\r\n      opts = preprocessor.opts,\r\n      svgWrapper = this.svgWrapper,\r\n      edge = preprocessor.graph.edges[edgeId],\r\n      vertexA = preprocessor.graph.vertices[edge.sourceId],\r\n      vertexB = preprocessor.graph.vertices[edge.targetId],\r\n      elementA = vertexA.value.element,\r\n      elementB = vertexB.value.element;\r\n\r\n    if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && preprocessor.opts.atomVisualization === 'default') {\r\n      return;\r\n    }\r\n\r\n    let a = vertexA.position,\r\n      b = vertexB.position,\r\n      normals = preprocessor.getEdgeNormals(edge),\r\n      // Create a point on each side of the line\r\n      sides = ArrayHelper.clone(normals);\r\n\r\n    sides[0].multiplyScalar(10).add(a);\r\n    sides[1].multiplyScalar(10).add(a);\r\n\r\n    if (edge.bondType === '=' || preprocessor.getRingbondType(vertexA, vertexB) === '=' ||\r\n      (edge.isPartOfAromaticRing && preprocessor.bridgedRing)) {\r\n      // Always draw double bonds inside the ring\r\n      let inRing = preprocessor.areVerticesInSameRing(vertexA, vertexB);\r\n      let s = preprocessor.chooseSide(vertexA, vertexB, sides);\r\n\r\n      if (inRing) {\r\n        // Always draw double bonds inside a ring\r\n        // if the bond is shared by two rings, it is drawn in the larger\r\n        // problem: smaller ring is aromatic, bond is still drawn in larger -> fix this\r\n        let lcr = preprocessor.getLargestOrAromaticCommonRing(vertexA, vertexB);\r\n        let center = lcr.center;\r\n\r\n        normals[0].multiplyScalar(opts.bondSpacing);\r\n        normals[1].multiplyScalar(opts.bondSpacing);\r\n\r\n        // Choose the normal that is on the same side as the center\r\n        let line = null;\r\n\r\n        if (center.sameSideAs(vertexA.position, vertexB.position, Vector2.add(a, normals[0]))) {\r\n          line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\r\n        } else {\r\n          line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\r\n        }\r\n\r\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\r\n\r\n        // The shortened edge\r\n        if (edge.isPartOfAromaticRing) {\r\n          // preprocessor.canvasWrapper.drawLine(line, true);\r\n          svgWrapper.drawLine(line, true);\r\n        } else {\r\n          // preprocessor.canvasWrapper.drawLine(line);\r\n          svgWrapper.drawLine(line);\r\n        }\r\n\r\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\r\n      } else if ((edge.center || vertexA.isTerminal() && vertexB.isTerminal()) ||\r\n        (s.anCount == 0 && s.bnCount > 1 || s.bnCount == 0 && s.anCount > 1)) {\r\n        this.multiplyNormals(normals, opts.halfBondSpacing);\r\n\r\n        let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB),\r\n          lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n        svgWrapper.drawLine(lineA);\r\n        svgWrapper.drawLine(lineB);\r\n      } else if ((s.sideCount[0] > s.sideCount[1]) ||\r\n        (s.totalSideCount[0] > s.totalSideCount[1])) {\r\n        this.multiplyNormals(normals, opts.bondSpacing);\r\n\r\n        let line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\r\n\r\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\r\n\r\n        svgWrapper.drawLine(line);\r\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\r\n      } else if ((s.sideCount[0] < s.sideCount[1]) ||\r\n        (s.totalSideCount[0] <= s.totalSideCount[1])) {\r\n        this.multiplyNormals(normals, opts.bondSpacing);\r\n\r\n        let line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);\r\n        svgWrapper.drawLine(line);\r\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB));\r\n      }\r\n    } else if (edge.bondType === '#') {\r\n      normals[0].multiplyScalar(opts.bondSpacing / 1.5);\r\n      normals[1].multiplyScalar(opts.bondSpacing / 1.5);\r\n\r\n      let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);\r\n      let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);\r\n\r\n      svgWrapper.drawLine(lineA);\r\n      svgWrapper.drawLine(lineB);\r\n      svgWrapper.drawLine(new Line(a, b, elementA, elementB));\r\n    } else if (edge.bondType === '.') {\r\n      // TODO: Something... maybe... version 2?\r\n    } else {\r\n      let isChiralCenterA = vertexA.value.isStereoCenter;\r\n      let isChiralCenterB = vertexB.value.isStereoCenter;\r\n\r\n      if (edge.wedge === 'up') {\r\n        svgWrapper.drawWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      } else if (edge.wedge === 'down') {\r\n        svgWrapper.drawDashedWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      } else {\r\n        svgWrapper.drawLine(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));\r\n      }\r\n    }\r\n\r\n    if (debug) {\r\n      let midpoint = Vector2.midpoint(a, b);\r\n      svgWrapper.drawDebugText(midpoint.x, midpoint.y, 'e: ' + edgeId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draws the vertices representing atoms to the canvas.\r\n   *\r\n   * @param {Boolean} debug A boolean indicating whether or not to draw debug messages to the canvas.\r\n   */\r\n  drawVertices(debug) {\r\n    let preprocessor = this.preprocessor,\r\n      opts = preprocessor.opts,\r\n      graph = preprocessor.graph,\r\n      rings = preprocessor.rings,\r\n      svgWrapper = this.svgWrapper;\r\n\r\n    var i = graph.vertices.length;\r\n    for (var i = 0; i < graph.vertices.length; i++) {\r\n      let vertex = graph.vertices[i];\r\n      let atom = vertex.value;\r\n      let charge = 0;\r\n      let isotope = 0;\r\n      let bondCount = vertex.value.bondCount;\r\n      let element = atom.element;\r\n      let hydrogens = Atom.maxBonds[element] - bondCount;\r\n      let dir = vertex.getTextDirection(graph.vertices);\r\n      let isTerminal = opts.terminalCarbons || element !== 'C' || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;\r\n      let isCarbon = atom.element === 'C';\r\n\r\n      // This is a HACK to remove all hydrogens from nitrogens in aromatic rings, as this\r\n      // should be the most common state. This has to be fixed by kekulization\r\n      if (atom.element === 'N' && atom.isPartOfAromaticRing) {\r\n        hydrogens = 0;\r\n      }\r\n\r\n      if (atom.bracket) {\r\n        hydrogens = atom.bracket.hcount;\r\n        charge = atom.bracket.charge;\r\n        isotope = atom.bracket.isotope;\r\n      }\r\n\r\n      if (opts.atomVisualization === 'allballs') {\r\n        svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);\r\n      } else if ((atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements)) || graph.vertices.length === 1) {\r\n        if (opts.atomVisualization === 'default') {\r\n          svgWrapper.drawText(vertex.position.x, vertex.position.y,\r\n            element, hydrogens, dir, isTerminal, charge, isotope, atom.getAttachedPseudoElements());\r\n        } else if (opts.atomVisualization === 'balls') {\r\n          svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);\r\n        }\r\n      } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned == true) {\r\n        // If there is a carbon which bonds are in a straight line, draw a dot\r\n        let a = graph.vertices[vertex.neighbours[0]].position;\r\n        let b = graph.vertices[vertex.neighbours[1]].position;\r\n        let angle = Vector2.threePointangle(vertex.position, a, b);\r\n\r\n        if (Math.abs(Math.PI - angle) < 0.1) {\r\n          svgWrapper.drawPoint(vertex.position.x, vertex.position.y, element);\r\n        }\r\n      }\r\n\r\n      if (debug) {\r\n        let value = 'v: ' + vertex.id + ' ' + ArrayHelper.print(atom.ringbonds);\r\n        svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);\r\n      } else {\r\n        svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, vertex.value.chirality);\r\n      }\r\n    }\r\n\r\n    // Draw the ring centers for debug purposes\r\n    if (opts.debug) {\r\n      for (var i = 0; i < rings.length; i++) {\r\n        let center = rings[i].center;\r\n        svgWrapper.drawDebugPoint(center.x, center.y, 'r: ' + rings[i].id);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the total overlap score of the current molecule.\r\n   *\r\n   * @returns {Number} The overlap score.\r\n   */\r\n  getTotalOverlapScore() {\r\n    return this.preprocessor.getTotalOverlapScore();\r\n  }\r\n\r\n  /**\r\n   * Returns the molecular formula of the loaded molecule as a string.\r\n   *\r\n   * @returns {String} The molecular formula.\r\n   */\r\n  getMolecularFormula() {\r\n    return this.preprocessor.getMolecularFormula();\r\n  }\r\n\r\n  /**\r\n   * @param {Array} normals list of normals to multiply\r\n   * @param {Number} spacing value to multiply normals by\r\n   */\r\n  multiplyNormals(normals, spacing) {\r\n    normals[0].multiplyScalar(spacing);\r\n    normals[1].multiplyScalar(spacing);\r\n  }\r\n}\r\n\r\nmodule.exports = SvgDrawer;"]},"metadata":{},"sourceType":"script"}