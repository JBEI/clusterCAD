{"ast":null,"code":"var _slicedToArray = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n//@ts-check\nvar MathHelper = require('./MathHelper');\n\nvar Vector2 = require('./Vector2');\n\nvar Vertex = require('./Vertex');\n\nvar Edge = require('./Edge');\n\nvar Ring = require('./Ring');\n\nvar Atom = require('./Atom');\n/** \r\n * A class representing the molecular graph. \r\n * \r\n * @property {Vertex[]} vertices The vertices of the graph.\r\n * @property {Edge[]} edges The edges of this graph.\r\n * @property {Object} vertexIdsToEdgeId A map mapping vertex ids to the edge between the two vertices. The key is defined as vertexAId + '_' + vertexBId.\r\n * @property {Boolean} isometric A boolean indicating whether or not the SMILES associated with this graph is isometric.\r\n */\n\n\nvar Graph = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\r\n   * The constructor of the class Graph.\r\n   * \r\n   * @param {Object} parseTree A SMILES parse tree.\r\n   * @param {Boolean} [isomeric=false] A boolean specifying whether or not the SMILES is isomeric.\r\n   */\n  function Graph(parseTree) {\n    var isomeric = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, Graph);\n\n    this.vertices = Array();\n    this.edges = Array();\n    this.vertexIdsToEdgeId = {};\n    this.isomeric = isomeric; // Used for the bridge detection algorithm\n\n    this._time = 0;\n\n    this._init(parseTree);\n  }\n  /**\r\n   * PRIVATE FUNCTION. Initializing the graph from the parse tree.\r\n   *\r\n   * @param {Object} node The current node in the parse tree.\r\n   * @param {Number} parentVertexId=null The id of the previous vertex.\r\n   * @param {Boolean} isBranch=false Whether or not the bond leading to this vertex is a branch bond. Branches are represented by parentheses in smiles (e.g. CC(O)C).\r\n   */\n\n\n  _createClass(Graph, [{\n    key: \"_init\",\n    value: function _init(node) {\n      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var parentVertexId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var isBranch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      // Create a new vertex object\n      var atom = new Atom(node.atom.element ? node.atom.element : node.atom, node.bond);\n      atom.branchBond = node.branchBond;\n      atom.ringbonds = node.ringbonds;\n      atom.bracket = node.atom.element ? node.atom : null;\n      var vertex = new Vertex(atom);\n      var parentVertex = this.vertices[parentVertexId];\n      this.addVertex(vertex); // Add the id of this node to the parent as child\n\n      if (parentVertexId !== null) {\n        vertex.setParentVertexId(parentVertexId);\n        vertex.value.addNeighbouringElement(parentVertex.value.element);\n        parentVertex.addChild(vertex.id);\n        parentVertex.value.addNeighbouringElement(atom.element); // In addition create a spanningTreeChildren property, which later will\n        // not contain the children added through ringbonds\n\n        parentVertex.spanningTreeChildren.push(vertex.id); // Add edge between this node and its parent\n\n        var edge = new Edge(parentVertexId, vertex.id, 1);\n        var vertexId = null;\n\n        if (isBranch) {\n          edge.setBondType(vertex.value.branchBond || '-');\n          vertexId = vertex.id;\n          edge.setBondType(vertex.value.branchBond || '-');\n          vertexId = vertex.id;\n        } else {\n          edge.setBondType(parentVertex.value.bondType || '-');\n          vertexId = parentVertex.id;\n        }\n\n        var edgeId = this.addEdge(edge);\n      }\n\n      var offset = node.ringbondCount + 1;\n\n      if (atom.bracket) {\n        offset += atom.bracket.hcount;\n      }\n\n      var stereoHydrogens = 0;\n\n      if (atom.bracket && atom.bracket.chirality) {\n        atom.isStereoCenter = true;\n        stereoHydrogens = atom.bracket.hcount;\n\n        for (var i = 0; i < stereoHydrogens; i++) {\n          this._init({\n            atom: 'H',\n            isBracket: 'false',\n            branches: Array(),\n            branchCount: 0,\n            ringbonds: Array(),\n            ringbondCount: false,\n            next: null,\n            hasNext: false,\n            bond: '-'\n          }, i, vertex.id, true);\n        }\n      }\n\n      for (var i = 0; i < node.branchCount; i++) {\n        this._init(node.branches[i], i + offset, vertex.id, true);\n      }\n\n      if (node.hasNext) {\n        this._init(node.next, node.branchCount + offset, vertex.id);\n      }\n    }\n    /**\r\n     * Clears all the elements in this graph (edges and vertices).\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.vertices = Array();\n      this.edges = Array();\n      this.vertexIdsToEdgeId = {};\n    }\n    /**\r\n     * Add a vertex to the graph.\r\n     *\r\n     * @param {Vertex} vertex A new vertex.\r\n     * @returns {Number} The vertex id of the new vertex.\r\n     */\n\n  }, {\n    key: \"addVertex\",\n    value: function addVertex(vertex) {\n      vertex.id = this.vertices.length;\n      this.vertices.push(vertex);\n      return vertex.id;\n    }\n    /**\r\n     * Add an edge to the graph.\r\n     *\r\n     * @param {Edge} edge A new edge.\r\n     * @returns {Number} The edge id of the new edge.\r\n     */\n\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(edge) {\n      var source = this.vertices[edge.sourceId];\n      var target = this.vertices[edge.targetId];\n      edge.id = this.edges.length;\n      this.edges.push(edge);\n      this.vertexIdsToEdgeId[edge.sourceId + '_' + edge.targetId] = edge.id;\n      this.vertexIdsToEdgeId[edge.targetId + '_' + edge.sourceId] = edge.id;\n      edge.isPartOfAromaticRing = source.value.isPartOfAromaticRing && target.value.isPartOfAromaticRing;\n      source.value.bondCount += edge.weight;\n      target.value.bondCount += edge.weight;\n      source.edges.push(edge.id);\n      target.edges.push(edge.id);\n      return edge.id;\n    }\n    /**\r\n     * Returns the edge between two given vertices.\r\n     *\r\n     * @param {Number} vertexIdA A vertex id.\r\n     * @param {Number} vertexIdB A vertex id.\r\n     * @returns {(Edge|null)} The edge or, if no edge can be found, null.\r\n     */\n\n  }, {\n    key: \"getEdge\",\n    value: function getEdge(vertexIdA, vertexIdB) {\n      var edgeId = this.vertexIdsToEdgeId[vertexIdA + '_' + vertexIdB];\n      return edgeId === undefined ? null : this.edges[edgeId];\n    }\n    /**\r\n     * Returns the ids of edges connected to a vertex.\r\n     *\r\n     * @param {Number} vertexId A vertex id.\r\n     * @returns {Number[]} An array containing the ids of edges connected to the vertex.\r\n     */\n\n  }, {\n    key: \"getEdges\",\n    value: function getEdges(vertexId) {\n      var edgeIds = Array();\n      var vertex = this.vertices[vertexId];\n\n      for (var i = 0; i < vertex.neighbours.length; i++) {\n        edgeIds.push(this.vertexIdsToEdgeId[vertexId + '_' + vertex.neighbours[i]]);\n      }\n\n      return edgeIds;\n    }\n    /**\r\n     * Check whether or not two vertices are connected by an edge.\r\n     *\r\n     * @param {Number} vertexIdA A vertex id.\r\n     * @param {Number} vertexIdB A vertex id.\r\n     * @returns {Boolean} A boolean indicating whether or not two vertices are connected by an edge.\r\n     */\n\n  }, {\n    key: \"hasEdge\",\n    value: function hasEdge(vertexIdA, vertexIdB) {\n      return this.vertexIdsToEdgeId[vertexIdA + '_' + vertexIdB] !== undefined;\n    }\n    /**\r\n     * Returns an array containing the vertex ids of this graph.\r\n     * \r\n     * @returns {Number[]} An array containing all vertex ids of this graph.\r\n     */\n\n  }, {\n    key: \"getVertexList\",\n    value: function getVertexList() {\n      var arr = [this.vertices.length];\n\n      for (var i = 0; i < this.vertices.length; i++) {\n        arr[i] = this.vertices[i].id;\n      }\n\n      return arr;\n    }\n    /**\r\n     * Returns an array containing source, target arrays of this graphs edges.\r\n     * \r\n     * @returns {Array[]} An array containing source, target arrays of this graphs edges. Example: [ [ 2, 5 ], [ 6, 9 ] ].\r\n     */\n\n  }, {\n    key: \"getEdgeList\",\n    value: function getEdgeList() {\n      var arr = Array(this.edges.length);\n\n      for (var i = 0; i < this.edges.length; i++) {\n        arr[i] = [this.edges[i].sourceId, this.edges[i].targetId];\n      }\n\n      return arr;\n    }\n    /**\r\n     * Get the adjacency matrix of the graph.\r\n     * \r\n     * @returns {Array[]} The adjancency matrix of the molecular graph.\r\n     */\n\n  }, {\n    key: \"getAdjacencyMatrix\",\n    value: function getAdjacencyMatrix() {\n      var length = this.vertices.length;\n      var adjacencyMatrix = Array(length);\n\n      for (var i = 0; i < length; i++) {\n        adjacencyMatrix[i] = new Array(length);\n        adjacencyMatrix[i].fill(0);\n      }\n\n      for (var i = 0; i < this.edges.length; i++) {\n        var edge = this.edges[i];\n        adjacencyMatrix[edge.sourceId][edge.targetId] = 1;\n        adjacencyMatrix[edge.targetId][edge.sourceId] = 1;\n      }\n\n      return adjacencyMatrix;\n    }\n    /**\r\n     * Get the adjacency matrix of the graph with all bridges removed (thus the components). Thus the remaining vertices are all part of ring systems.\r\n     * \r\n     * @returns {Array[]} The adjancency matrix of the molecular graph with all bridges removed.\r\n     */\n\n  }, {\n    key: \"getComponentsAdjacencyMatrix\",\n    value: function getComponentsAdjacencyMatrix() {\n      var length = this.vertices.length;\n      var adjacencyMatrix = Array(length);\n      var bridges = this.getBridges();\n\n      for (var i = 0; i < length; i++) {\n        adjacencyMatrix[i] = new Array(length);\n        adjacencyMatrix[i].fill(0);\n      }\n\n      for (var i = 0; i < this.edges.length; i++) {\n        var edge = this.edges[i];\n        adjacencyMatrix[edge.sourceId][edge.targetId] = 1;\n        adjacencyMatrix[edge.targetId][edge.sourceId] = 1;\n      }\n\n      for (var i = 0; i < bridges.length; i++) {\n        adjacencyMatrix[bridges[i][0]][bridges[i][1]] = 0;\n        adjacencyMatrix[bridges[i][1]][bridges[i][0]] = 0;\n      }\n\n      return adjacencyMatrix;\n    }\n    /**\r\n     * Get the adjacency matrix of a subgraph.\r\n     * \r\n     * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n     * @returns {Array[]} The adjancency matrix of the subgraph.\r\n     */\n\n  }, {\n    key: \"getSubgraphAdjacencyMatrix\",\n    value: function getSubgraphAdjacencyMatrix(vertexIds) {\n      var length = vertexIds.length;\n      var adjacencyMatrix = Array(length);\n\n      for (var i = 0; i < length; i++) {\n        adjacencyMatrix[i] = new Array(length);\n        adjacencyMatrix[i].fill(0);\n\n        for (var j = 0; j < length; j++) {\n          if (i === j) {\n            continue;\n          }\n\n          if (this.hasEdge(vertexIds[i], vertexIds[j])) {\n            adjacencyMatrix[i][j] = 1;\n          }\n        }\n      }\n\n      return adjacencyMatrix;\n    }\n    /**\r\n     * Get the distance matrix of the graph.\r\n     * \r\n     * @returns {Array[]} The distance matrix of the graph.\r\n     */\n\n  }, {\n    key: \"getDistanceMatrix\",\n    value: function getDistanceMatrix() {\n      var length = this.vertices.length;\n      var adja = this.getAdjacencyMatrix();\n      var dist = Array(length);\n\n      for (var i = 0; i < length; i++) {\n        dist[i] = Array(length);\n        dist[i].fill(Infinity);\n      }\n\n      for (var i = 0; i < length; i++) {\n        for (var j = 0; j < length; j++) {\n          if (adja[i][j] === 1) {\n            dist[i][j] = 1;\n          }\n        }\n      }\n\n      for (var k = 0; k < length; k++) {\n        for (var i = 0; i < length; i++) {\n          for (var j = 0; j < length; j++) {\n            if (dist[i][j] > dist[i][k] + dist[k][j]) {\n              dist[i][j] = dist[i][k] + dist[k][j];\n            }\n          }\n        }\n      }\n\n      return dist;\n    }\n    /**\r\n     * Get the distance matrix of a subgraph.\r\n     * \r\n     * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n     * @returns {Array[]} The distance matrix of the subgraph.\r\n     */\n\n  }, {\n    key: \"getSubgraphDistanceMatrix\",\n    value: function getSubgraphDistanceMatrix(vertexIds) {\n      var length = vertexIds.length;\n      var adja = this.getSubgraphAdjacencyMatrix(vertexIds);\n      var dist = Array(length);\n\n      for (var i = 0; i < length; i++) {\n        dist[i] = Array(length);\n        dist[i].fill(Infinity);\n      }\n\n      for (var i = 0; i < length; i++) {\n        for (var j = 0; j < length; j++) {\n          if (adja[i][j] === 1) {\n            dist[i][j] = 1;\n          }\n        }\n      }\n\n      for (var k = 0; k < length; k++) {\n        for (var i = 0; i < length; i++) {\n          for (var j = 0; j < length; j++) {\n            if (dist[i][j] > dist[i][k] + dist[k][j]) {\n              dist[i][j] = dist[i][k] + dist[k][j];\n            }\n          }\n        }\n      }\n\n      return dist;\n    }\n    /**\r\n     * Get the adjacency list of the graph.\r\n     * \r\n     * @returns {Array[]} The adjancency list of the graph.\r\n     */\n\n  }, {\n    key: \"getAdjacencyList\",\n    value: function getAdjacencyList() {\n      var length = this.vertices.length;\n      var adjacencyList = Array(length);\n\n      for (var i = 0; i < length; i++) {\n        adjacencyList[i] = [];\n\n        for (var j = 0; j < length; j++) {\n          if (i === j) {\n            continue;\n          }\n\n          if (this.hasEdge(this.vertices[i].id, this.vertices[j].id)) {\n            adjacencyList[i].push(j);\n          }\n        }\n      }\n\n      return adjacencyList;\n    }\n    /**\r\n     * Get the adjacency list of a subgraph.\r\n     * \r\n     * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n     * @returns {Array[]} The adjancency list of the subgraph.\r\n     */\n\n  }, {\n    key: \"getSubgraphAdjacencyList\",\n    value: function getSubgraphAdjacencyList(vertexIds) {\n      var length = vertexIds.length;\n      var adjacencyList = Array(length);\n\n      for (var i = 0; i < length; i++) {\n        adjacencyList[i] = Array();\n\n        for (var j = 0; j < length; j++) {\n          if (i === j) {\n            continue;\n          }\n\n          if (this.hasEdge(vertexIds[i], vertexIds[j])) {\n            adjacencyList[i].push(j);\n          }\n        }\n      }\n\n      return adjacencyList;\n    }\n    /**\r\n     * Returns an array containing the edge ids of bridges. A bridge splits the graph into multiple components when removed.\r\n     * \r\n     * @returns {Number[]} An array containing the edge ids of the bridges.\r\n     */\n\n  }, {\n    key: \"getBridges\",\n    value: function getBridges() {\n      var length = this.vertices.length;\n      var visited = new Array(length);\n      var disc = new Array(length);\n      var low = new Array(length);\n      var parent = new Array(length);\n      var adj = this.getAdjacencyList();\n      var outBridges = Array();\n      visited.fill(false);\n      parent.fill(null);\n      this._time = 0;\n\n      for (var i = 0; i < length; i++) {\n        if (!visited[i]) {\n          this._bridgeDfs(i, visited, disc, low, parent, adj, outBridges);\n        }\n      }\n\n      return outBridges;\n    }\n    /**\r\n     * Traverses the graph in breadth-first order.\r\n     * \r\n     * @param {Number} startVertexId The id of the starting vertex.\r\n     * @param {Function} callback The callback function to be called on every vertex.\r\n     */\n\n  }, {\n    key: \"traverseBF\",\n    value: function traverseBF(startVertexId, callback) {\n      var length = this.vertices.length;\n      var visited = new Array(length);\n      visited.fill(false);\n      var queue = [startVertexId];\n\n      while (queue.length > 0) {\n        // JavaScripts shift() is O(n) ... bad JavaScript, bad!\n        var u = queue.shift();\n        var vertex = this.vertices[u];\n        callback(vertex);\n\n        for (var i = 0; i < vertex.neighbours.length; i++) {\n          var v = vertex.neighbours[i];\n\n          if (!visited[v]) {\n            visited[v] = true;\n            queue.push(v);\n          }\n        }\n      }\n    }\n    /**\r\n     * Get the depth of a subtree in the direction opposite to the vertex specified as the parent vertex.\r\n     *\r\n     * @param {Number} vertexId A vertex id.\r\n     * @param {Number} parentVertexId The id of a neighbouring vertex.\r\n     * @returns {Number} The depth of the sub-tree.\r\n     */\n\n  }, {\n    key: \"getTreeDepth\",\n    value: function getTreeDepth(vertexId, parentVertexId) {\n      if (vertexId === null || parentVertexId === null) {\n        return 0;\n      }\n\n      var neighbours = this.vertices[vertexId].getSpanningTreeNeighbours(parentVertexId);\n      var max = 0;\n\n      for (var i = 0; i < neighbours.length; i++) {\n        var childId = neighbours[i];\n        var d = this.getTreeDepth(childId, vertexId);\n\n        if (d > max) {\n          max = d;\n        }\n      }\n\n      return max + 1;\n    }\n    /**\r\n     * Traverse a sub-tree in the graph.\r\n     *\r\n     * @param {Number} vertexId A vertex id.\r\n     * @param {Number} parentVertexId A neighbouring vertex.\r\n     * @param {Function} callback The callback function that is called with each visited as an argument.\r\n     * @param {Number} [maxDepth=999999] The maximum depth of the recursion.\r\n     * @param {Boolean} [ignoreFirst=false] Whether or not to ignore the starting vertex supplied as vertexId in the callback.\r\n     * @param {Number} [depth=1] The current depth in the tree.\r\n     * @param {Uint8Array} [visited=null] An array holding a flag on whether or not a node has been visited.\r\n     */\n\n  }, {\n    key: \"traverseTree\",\n    value: function traverseTree(vertexId, parentVertexId, callback) {\n      var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 999999;\n      var ignoreFirst = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var depth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n      var visited = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n      if (visited === null) {\n        visited = new Uint8Array(this.vertices.length);\n      }\n\n      if (depth > maxDepth + 1 || visited[vertexId] === 1) {\n        return;\n      }\n\n      visited[vertexId] = 1;\n      var vertex = this.vertices[vertexId];\n      var neighbours = vertex.getNeighbours(parentVertexId);\n\n      if (!ignoreFirst || depth > 1) {\n        callback(vertex);\n      }\n\n      for (var i = 0; i < neighbours.length; i++) {\n        this.traverseTree(neighbours[i], vertexId, callback, maxDepth, ignoreFirst, depth + 1, visited);\n      }\n    }\n    /**\r\n     * Positiones the (sub)graph using Kamada and Kawais algorithm for drawing general undirected graphs. https://pdfs.semanticscholar.org/b8d3/bca50ccc573c5cb99f7d201e8acce6618f04.pdf\r\n     * There are undocumented layout parameters. They are undocumented for a reason, so be very careful.\r\n     * \r\n     * @param {Number[]} vertexIds An array containing vertexIds to be placed using the force based layout.\r\n     * @param {Vector2} center The center of the layout.\r\n     * @param {Number} startVertexId A vertex id. Should be the starting vertex - e.g. the first to be positioned and connected to a previously place vertex.\r\n     * @param {Ring} ring The bridged ring associated with this force-based layout.\r\n     */\n\n  }, {\n    key: \"kkLayout\",\n    value: function kkLayout(vertexIds, center, startVertexId, ring, bondLength) {\n      var threshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.1;\n      var innerThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0.1;\n      var maxIteration = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 2000;\n      var maxInnerIteration = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 50;\n      var maxEnergy = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 1e9;\n      var edgeStrength = bondLength; // Add vertices that are directly connected to the ring\n\n      var i = vertexIds.length;\n\n      while (i--) {\n        var vertex = this.vertices[vertexIds[i]];\n        var j = vertex.neighbours.length;\n      }\n\n      var matDist = this.getSubgraphDistanceMatrix(vertexIds);\n      var length = vertexIds.length; // Initialize the positions. Place all vertices on a ring around the center\n\n      var radius = MathHelper.polyCircumradius(500, length);\n      var angle = MathHelper.centralAngle(length);\n      var a = 0.0;\n      var arrPositionX = new Float32Array(length);\n      var arrPositionY = new Float32Array(length);\n      var arrPositioned = Array(length);\n      i = length;\n\n      while (i--) {\n        var _vertex = this.vertices[vertexIds[i]];\n\n        if (!_vertex.positioned) {\n          arrPositionX[i] = center.x + Math.cos(a) * radius;\n          arrPositionY[i] = center.y + Math.sin(a) * radius;\n        } else {\n          arrPositionX[i] = _vertex.position.x;\n          arrPositionY[i] = _vertex.position.y;\n        }\n\n        arrPositioned[i] = _vertex.positioned;\n        a += angle;\n      } // Create the matrix containing the lengths\n\n\n      var matLength = Array(length);\n      i = length;\n\n      while (i--) {\n        matLength[i] = new Array(length);\n        var j = length;\n\n        while (j--) {\n          matLength[i][j] = bondLength * matDist[i][j];\n        }\n      } // Create the matrix containing the spring strenghts\n\n\n      var matStrength = Array(length);\n      i = length;\n\n      while (i--) {\n        matStrength[i] = Array(length);\n        var j = length;\n\n        while (j--) {\n          matStrength[i][j] = edgeStrength * Math.pow(matDist[i][j], -2.0);\n        }\n      } // Create the matrix containing the energies\n\n\n      var matEnergy = Array(length);\n      var arrEnergySumX = new Float32Array(length);\n      var arrEnergySumY = new Float32Array(length);\n      i = length;\n\n      while (i--) {\n        matEnergy[i] = Array(length);\n      }\n\n      i = length;\n      var ux, uy, dEx, dEy, vx, vy, denom;\n\n      while (i--) {\n        ux = arrPositionX[i];\n        uy = arrPositionY[i];\n        dEx = 0.0;\n        dEy = 0.0;\n        var _j = length;\n\n        while (_j--) {\n          if (i === _j) {\n            continue;\n          }\n\n          vx = arrPositionX[_j];\n          vy = arrPositionY[_j];\n          denom = 1.0 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));\n          matEnergy[i][_j] = [matStrength[i][_j] * (ux - vx - matLength[i][_j] * (ux - vx) * denom), matStrength[i][_j] * (uy - vy - matLength[i][_j] * (uy - vy) * denom)];\n          matEnergy[_j][i] = matEnergy[i][_j];\n          dEx += matEnergy[i][_j][0];\n          dEy += matEnergy[i][_j][1];\n        }\n\n        arrEnergySumX[i] = dEx;\n        arrEnergySumY[i] = dEy;\n      } // Utility functions, maybe inline them later\n\n\n      var energy = function energy(index) {\n        return [arrEnergySumX[index] * arrEnergySumX[index] + arrEnergySumY[index] * arrEnergySumY[index], arrEnergySumX[index], arrEnergySumY[index]];\n      };\n\n      var highestEnergy = function highestEnergy() {\n        var maxEnergy = 0.0;\n        var maxEnergyId = 0;\n        var maxDEX = 0.0;\n        var maxDEY = 0.0;\n        i = length;\n\n        while (i--) {\n          var _energy = energy(i),\n              _energy2 = _slicedToArray(_energy, 3),\n              _delta = _energy2[0],\n              _dEX = _energy2[1],\n              _dEY = _energy2[2];\n\n          if (_delta > maxEnergy && arrPositioned[i] === false) {\n            maxEnergy = _delta;\n            maxEnergyId = i;\n            maxDEX = _dEX;\n            maxDEY = _dEY;\n          }\n        }\n\n        return [maxEnergyId, maxEnergy, maxDEX, maxDEY];\n      };\n\n      var update = function update(index, dEX, dEY) {\n        var dxx = 0.0;\n        var dyy = 0.0;\n        var dxy = 0.0;\n        var ux = arrPositionX[index];\n        var uy = arrPositionY[index];\n        var arrL = matLength[index];\n        var arrK = matStrength[index];\n        i = length;\n\n        while (i--) {\n          if (i === index) {\n            continue;\n          }\n\n          var _vx = arrPositionX[i];\n          var _vy = arrPositionY[i];\n          var l = arrL[i];\n          var k = arrK[i];\n          var m = (ux - _vx) * (ux - _vx);\n\n          var _denom = 1.0 / Math.pow(m + (uy - _vy) * (uy - _vy), 1.5);\n\n          dxx += k * (1 - l * (uy - _vy) * (uy - _vy) * _denom);\n          dyy += k * (1 - l * m * _denom);\n          dxy += k * (l * (ux - _vx) * (uy - _vy) * _denom);\n        } // Prevent division by zero\n\n\n        if (dxx === 0) {\n          dxx = 0.1;\n        }\n\n        if (dyy === 0) {\n          dyy = 0.1;\n        }\n\n        if (dxy === 0) {\n          dxy = 0.1;\n        }\n\n        var dy = dEX / dxx + dEY / dxy;\n        dy /= dxy / dxx - dyy / dxy; // had to split this onto two lines because the syntax highlighter went crazy.\n\n        var dx = -(dxy * dy + dEX) / dxx;\n        arrPositionX[index] += dx;\n        arrPositionY[index] += dy; // Update the energies\n\n        var arrE = matEnergy[index];\n        dEX = 0.0;\n        dEY = 0.0;\n        ux = arrPositionX[index];\n        uy = arrPositionY[index];\n        var vx, vy, prevEx, prevEy, denom;\n        i = length;\n\n        while (i--) {\n          if (index === i) {\n            continue;\n          }\n\n          vx = arrPositionX[i];\n          vy = arrPositionY[i]; // Store old energies\n\n          prevEx = arrE[i][0];\n          prevEy = arrE[i][1];\n          denom = 1.0 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));\n          dx = arrK[i] * (ux - vx - arrL[i] * (ux - vx) * denom);\n          dy = arrK[i] * (uy - vy - arrL[i] * (uy - vy) * denom);\n          arrE[i] = [dx, dy];\n          dEX += dx;\n          dEY += dy;\n          arrEnergySumX[i] += dx - prevEx;\n          arrEnergySumY[i] += dy - prevEy;\n        }\n\n        arrEnergySumX[index] = dEX;\n        arrEnergySumY[index] = dEY;\n      }; // Setting up variables for the while loops\n\n\n      var maxEnergyId = 0;\n      var dEX = 0.0;\n      var dEY = 0.0;\n      var delta = 0.0;\n      var iteration = 0;\n      var innerIteration = 0;\n\n      while (maxEnergy > threshold && maxIteration > iteration) {\n        iteration++;\n\n        var _highestEnergy = highestEnergy();\n\n        var _highestEnergy2 = _slicedToArray(_highestEnergy, 4);\n\n        maxEnergyId = _highestEnergy2[0];\n        maxEnergy = _highestEnergy2[1];\n        dEX = _highestEnergy2[2];\n        dEY = _highestEnergy2[3];\n        delta = maxEnergy;\n        innerIteration = 0;\n\n        while (delta > innerThreshold && maxInnerIteration > innerIteration) {\n          innerIteration++;\n          update(maxEnergyId, dEX, dEY);\n\n          var _energy3 = energy(maxEnergyId);\n\n          var _energy4 = _slicedToArray(_energy3, 3);\n\n          delta = _energy4[0];\n          dEX = _energy4[1];\n          dEY = _energy4[2];\n        }\n      }\n\n      i = length;\n\n      while (i--) {\n        var index = vertexIds[i];\n        var _vertex2 = this.vertices[index];\n        _vertex2.position.x = arrPositionX[i];\n        _vertex2.position.y = arrPositionY[i];\n        _vertex2.positioned = true;\n        _vertex2.forcePositioned = true;\n      }\n    }\n    /**\r\n     * PRIVATE FUNCTION used by getBridges().\r\n     */\n\n  }, {\n    key: \"_bridgeDfs\",\n    value: function _bridgeDfs(u, visited, disc, low, parent, adj, outBridges) {\n      visited[u] = true;\n      disc[u] = low[u] = ++this._time;\n\n      for (var i = 0; i < adj[u].length; i++) {\n        var v = adj[u][i];\n\n        if (!visited[v]) {\n          parent[v] = u;\n\n          this._bridgeDfs(v, visited, disc, low, parent, adj, outBridges);\n\n          low[u] = Math.min(low[u], low[v]); // If low > disc, we have a bridge\n\n          if (low[v] > disc[u]) {\n            outBridges.push([u, v]);\n          }\n        } else if (v !== parent[u]) {\n          low[u] = Math.min(low[u], disc[v]);\n        }\n      }\n    }\n    /**\r\n     * Returns the connected components of the graph.\r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Set[]} Connected components as sets.\r\n     */\n\n  }], [{\n    key: \"getConnectedComponents\",\n    value: function getConnectedComponents(adjacencyMatrix) {\n      var length = adjacencyMatrix.length;\n      var visited = new Array(length);\n      var components = new Array();\n      var count = 0;\n      visited.fill(false);\n\n      for (var u = 0; u < length; u++) {\n        if (!visited[u]) {\n          var component = Array();\n          visited[u] = true;\n          component.push(u);\n          count++;\n\n          Graph._ccGetDfs(u, visited, adjacencyMatrix, component);\n\n          if (component.length > 1) {\n            components.push(component);\n          }\n        }\n      }\n\n      return components;\n    }\n    /**\r\n     * Returns the number of connected components for the graph. \r\n     * \r\n     * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n     * @returns {Number} The number of connected components of the supplied graph.\r\n     */\n\n  }, {\n    key: \"getConnectedComponentCount\",\n    value: function getConnectedComponentCount(adjacencyMatrix) {\n      var length = adjacencyMatrix.length;\n      var visited = new Array(length);\n      var count = 0;\n      visited.fill(false);\n\n      for (var u = 0; u < length; u++) {\n        if (!visited[u]) {\n          visited[u] = true;\n          count++;\n\n          Graph._ccCountDfs(u, visited, adjacencyMatrix);\n        }\n      }\n\n      return count;\n    }\n    /**\r\n     * PRIVATE FUNCTION used by getConnectedComponentCount().\r\n     */\n\n  }, {\n    key: \"_ccCountDfs\",\n    value: function _ccCountDfs(u, visited, adjacencyMatrix) {\n      for (var v = 0; v < adjacencyMatrix[u].length; v++) {\n        var c = adjacencyMatrix[u][v];\n\n        if (!c || visited[v] || u === v) {\n          continue;\n        }\n\n        visited[v] = true;\n\n        Graph._ccCountDfs(v, visited, adjacencyMatrix);\n      }\n    }\n    /**\r\n     * PRIVATE FUNCTION used by getConnectedComponents().\r\n     */\n\n  }, {\n    key: \"_ccGetDfs\",\n    value: function _ccGetDfs(u, visited, adjacencyMatrix, component) {\n      for (var v = 0; v < adjacencyMatrix[u].length; v++) {\n        var c = adjacencyMatrix[u][v];\n\n        if (!c || visited[v] || u === v) {\n          continue;\n        }\n\n        visited[v] = true;\n        component.push(v);\n\n        Graph._ccGetDfs(v, visited, adjacencyMatrix, component);\n      }\n    }\n  }]);\n\n  return Graph;\n}();\n\nmodule.exports = Graph;","map":{"version":3,"sources":["/Users/sarahlafrance/LBNL/clusterCAD/retrotideUI/node_modules/smiles-drawer/src/Graph.js"],"names":["MathHelper","require","Vector2","Vertex","Edge","Ring","Atom","Graph","parseTree","isomeric","vertices","Array","edges","vertexIdsToEdgeId","_time","_init","node","order","parentVertexId","isBranch","atom","element","bond","branchBond","ringbonds","bracket","vertex","parentVertex","addVertex","setParentVertexId","value","addNeighbouringElement","addChild","id","spanningTreeChildren","push","edge","vertexId","setBondType","bondType","edgeId","addEdge","offset","ringbondCount","hcount","stereoHydrogens","chirality","isStereoCenter","i","isBracket","branches","branchCount","next","hasNext","length","source","sourceId","target","targetId","isPartOfAromaticRing","bondCount","weight","vertexIdA","vertexIdB","undefined","edgeIds","neighbours","arr","adjacencyMatrix","fill","bridges","getBridges","vertexIds","j","hasEdge","adja","getAdjacencyMatrix","dist","Infinity","k","getSubgraphAdjacencyMatrix","adjacencyList","visited","disc","low","parent","adj","getAdjacencyList","outBridges","_bridgeDfs","startVertexId","callback","queue","u","shift","v","getSpanningTreeNeighbours","max","childId","d","getTreeDepth","maxDepth","ignoreFirst","depth","Uint8Array","getNeighbours","traverseTree","center","ring","bondLength","threshold","innerThreshold","maxIteration","maxInnerIteration","maxEnergy","edgeStrength","matDist","getSubgraphDistanceMatrix","radius","polyCircumradius","angle","centralAngle","a","arrPositionX","Float32Array","arrPositionY","arrPositioned","positioned","x","Math","cos","y","sin","position","matLength","matStrength","pow","matEnergy","arrEnergySumX","arrEnergySumY","ux","uy","dEx","dEy","vx","vy","denom","sqrt","energy","index","highestEnergy","maxEnergyId","maxDEX","maxDEY","delta","dEX","dEY","update","dxx","dyy","dxy","arrL","arrK","l","m","dy","dx","arrE","prevEx","prevEy","iteration","innerIteration","forcePositioned","min","components","count","component","_ccGetDfs","_ccCountDfs","c","module","exports"],"mappings":";;;;;;AAAA;AACA,IAAMA,UAAU,GAAGC,OAAO,CAAC,cAAD,CAA1B;;AACA,IAAMC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAME,MAAM,GAAGF,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAMG,IAAI,GAAGH,OAAO,CAAC,QAAD,CAApB;;AACA,IAAMI,IAAI,GAAGJ,OAAO,CAAC,QAAD,CAApB;;AACA,IAAMK,IAAI,GAAGL,OAAO,CAAC,QAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACMM,K;;;AACJ;AACF;AACA;AACA;AACA;AACA;AACE,iBAAYC,SAAZ,EAAyC;AAAA,QAAlBC,QAAkB,uEAAP,KAAO;;AAAA;;AACvC,SAAKC,QAAL,GAAgBC,KAAK,EAArB;AACA,SAAKC,KAAL,GAAaD,KAAK,EAAlB;AACA,SAAKE,iBAAL,GAAyB,EAAzB;AACA,SAAKJ,QAAL,GAAgBA,QAAhB,CAJuC,CAMvC;;AACA,SAAKK,KAAL,GAAa,CAAb;;AACA,SAAKC,KAAL,CAAWP,SAAX;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;;WACE,eAAMQ,IAAN,EAAgE;AAAA,UAApDC,KAAoD,uEAA5C,CAA4C;AAAA,UAAzCC,cAAyC,uEAAxB,IAAwB;AAAA,UAAlBC,QAAkB,uEAAP,KAAO;AAC9D;AACA,UAAIC,IAAI,GAAG,IAAId,IAAJ,CAASU,IAAI,CAACI,IAAL,CAAUC,OAAV,GAAoBL,IAAI,CAACI,IAAL,CAAUC,OAA9B,GAAwCL,IAAI,CAACI,IAAtD,EAA4DJ,IAAI,CAACM,IAAjE,CAAX;AAEAF,MAAAA,IAAI,CAACG,UAAL,GAAkBP,IAAI,CAACO,UAAvB;AACAH,MAAAA,IAAI,CAACI,SAAL,GAAiBR,IAAI,CAACQ,SAAtB;AACAJ,MAAAA,IAAI,CAACK,OAAL,GAAeT,IAAI,CAACI,IAAL,CAAUC,OAAV,GAAoBL,IAAI,CAACI,IAAzB,GAAgC,IAA/C;AAEA,UAAIM,MAAM,GAAG,IAAIvB,MAAJ,CAAWiB,IAAX,CAAb;AACA,UAAIO,YAAY,GAAG,KAAKjB,QAAL,CAAcQ,cAAd,CAAnB;AAEA,WAAKU,SAAL,CAAeF,MAAf,EAX8D,CAa9D;;AACA,UAAIR,cAAc,KAAK,IAAvB,EAA6B;AAC3BQ,QAAAA,MAAM,CAACG,iBAAP,CAAyBX,cAAzB;AACAQ,QAAAA,MAAM,CAACI,KAAP,CAAaC,sBAAb,CAAoCJ,YAAY,CAACG,KAAb,CAAmBT,OAAvD;AACAM,QAAAA,YAAY,CAACK,QAAb,CAAsBN,MAAM,CAACO,EAA7B;AACAN,QAAAA,YAAY,CAACG,KAAb,CAAmBC,sBAAnB,CAA0CX,IAAI,CAACC,OAA/C,EAJ2B,CAM3B;AACA;;AACAM,QAAAA,YAAY,CAACO,oBAAb,CAAkCC,IAAlC,CAAuCT,MAAM,CAACO,EAA9C,EAR2B,CAU3B;;AACA,YAAIG,IAAI,GAAG,IAAIhC,IAAJ,CAASc,cAAT,EAAyBQ,MAAM,CAACO,EAAhC,EAAoC,CAApC,CAAX;AACA,YAAII,QAAQ,GAAG,IAAf;;AAEA,YAAIlB,QAAJ,EAAc;AACZiB,UAAAA,IAAI,CAACE,WAAL,CAAiBZ,MAAM,CAACI,KAAP,CAAaP,UAAb,IAA2B,GAA5C;AACAc,UAAAA,QAAQ,GAAGX,MAAM,CAACO,EAAlB;AACAG,UAAAA,IAAI,CAACE,WAAL,CAAiBZ,MAAM,CAACI,KAAP,CAAaP,UAAb,IAA2B,GAA5C;AACAc,UAAAA,QAAQ,GAAGX,MAAM,CAACO,EAAlB;AACD,SALD,MAKO;AACLG,UAAAA,IAAI,CAACE,WAAL,CAAiBX,YAAY,CAACG,KAAb,CAAmBS,QAAnB,IAA+B,GAAhD;AACAF,UAAAA,QAAQ,GAAGV,YAAY,CAACM,EAAxB;AACD;;AAED,YAAIO,MAAM,GAAG,KAAKC,OAAL,CAAaL,IAAb,CAAb;AACD;;AAED,UAAIM,MAAM,GAAG1B,IAAI,CAAC2B,aAAL,GAAqB,CAAlC;;AAEA,UAAIvB,IAAI,CAACK,OAAT,EAAkB;AAChBiB,QAAAA,MAAM,IAAItB,IAAI,CAACK,OAAL,CAAamB,MAAvB;AACD;;AAED,UAAIC,eAAe,GAAG,CAAtB;;AACA,UAAIzB,IAAI,CAACK,OAAL,IAAgBL,IAAI,CAACK,OAAL,CAAaqB,SAAjC,EAA4C;AAC1C1B,QAAAA,IAAI,CAAC2B,cAAL,GAAsB,IAAtB;AACAF,QAAAA,eAAe,GAAGzB,IAAI,CAACK,OAAL,CAAamB,MAA/B;;AACA,aAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,eAApB,EAAqCG,CAAC,EAAtC,EAA0C;AACxC,eAAKjC,KAAL,CAAW;AACTK,YAAAA,IAAI,EAAE,GADG;AAET6B,YAAAA,SAAS,EAAE,OAFF;AAGTC,YAAAA,QAAQ,EAAEvC,KAAK,EAHN;AAITwC,YAAAA,WAAW,EAAE,CAJJ;AAKT3B,YAAAA,SAAS,EAAEb,KAAK,EALP;AAMTgC,YAAAA,aAAa,EAAE,KANN;AAOTS,YAAAA,IAAI,EAAE,IAPG;AAQTC,YAAAA,OAAO,EAAE,KARA;AAST/B,YAAAA,IAAI,EAAE;AATG,WAAX,EAUG0B,CAVH,EAUMtB,MAAM,CAACO,EAVb,EAUiB,IAVjB;AAWD;AACF;;AAED,WAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,IAAI,CAACmC,WAAzB,EAAsCH,CAAC,EAAvC,EAA2C;AACzC,aAAKjC,KAAL,CAAWC,IAAI,CAACkC,QAAL,CAAcF,CAAd,CAAX,EAA6BA,CAAC,GAAGN,MAAjC,EAAyChB,MAAM,CAACO,EAAhD,EAAoD,IAApD;AACD;;AAED,UAAIjB,IAAI,CAACqC,OAAT,EAAkB;AAChB,aAAKtC,KAAL,CAAWC,IAAI,CAACoC,IAAhB,EAAsBpC,IAAI,CAACmC,WAAL,GAAmBT,MAAzC,EAAiDhB,MAAM,CAACO,EAAxD;AACD;AACF;AAED;AACF;AACA;;;;WACE,iBAAQ;AACN,WAAKvB,QAAL,GAAgBC,KAAK,EAArB;AACA,WAAKC,KAAL,GAAaD,KAAK,EAAlB;AACA,WAAKE,iBAAL,GAAyB,EAAzB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,mBAAUa,MAAV,EAAkB;AAChBA,MAAAA,MAAM,CAACO,EAAP,GAAY,KAAKvB,QAAL,CAAc4C,MAA1B;AACA,WAAK5C,QAAL,CAAcyB,IAAd,CAAmBT,MAAnB;AAEA,aAAOA,MAAM,CAACO,EAAd;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,iBAAQG,IAAR,EAAc;AACZ,UAAImB,MAAM,GAAG,KAAK7C,QAAL,CAAc0B,IAAI,CAACoB,QAAnB,CAAb;AACA,UAAIC,MAAM,GAAG,KAAK/C,QAAL,CAAc0B,IAAI,CAACsB,QAAnB,CAAb;AAEAtB,MAAAA,IAAI,CAACH,EAAL,GAAU,KAAKrB,KAAL,CAAW0C,MAArB;AACA,WAAK1C,KAAL,CAAWuB,IAAX,CAAgBC,IAAhB;AAEA,WAAKvB,iBAAL,CAAuBuB,IAAI,CAACoB,QAAL,GAAgB,GAAhB,GAAsBpB,IAAI,CAACsB,QAAlD,IAA8DtB,IAAI,CAACH,EAAnE;AACA,WAAKpB,iBAAL,CAAuBuB,IAAI,CAACsB,QAAL,GAAgB,GAAhB,GAAsBtB,IAAI,CAACoB,QAAlD,IAA8DpB,IAAI,CAACH,EAAnE;AACAG,MAAAA,IAAI,CAACuB,oBAAL,GAA4BJ,MAAM,CAACzB,KAAP,CAAa6B,oBAAb,IAAqCF,MAAM,CAAC3B,KAAP,CAAa6B,oBAA9E;AAEAJ,MAAAA,MAAM,CAACzB,KAAP,CAAa8B,SAAb,IAA0BxB,IAAI,CAACyB,MAA/B;AACAJ,MAAAA,MAAM,CAAC3B,KAAP,CAAa8B,SAAb,IAA0BxB,IAAI,CAACyB,MAA/B;AAEAN,MAAAA,MAAM,CAAC3C,KAAP,CAAauB,IAAb,CAAkBC,IAAI,CAACH,EAAvB;AACAwB,MAAAA,MAAM,CAAC7C,KAAP,CAAauB,IAAb,CAAkBC,IAAI,CAACH,EAAvB;AAEA,aAAOG,IAAI,CAACH,EAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,iBAAQ6B,SAAR,EAAmBC,SAAnB,EAA8B;AAC5B,UAAIvB,MAAM,GAAG,KAAK3B,iBAAL,CAAuBiD,SAAS,GAAG,GAAZ,GAAkBC,SAAzC,CAAb;AAEA,aAAOvB,MAAM,KAAKwB,SAAX,GAAuB,IAAvB,GAA8B,KAAKpD,KAAL,CAAW4B,MAAX,CAArC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,kBAASH,QAAT,EAAmB;AACjB,UAAI4B,OAAO,GAAGtD,KAAK,EAAnB;AACA,UAAIe,MAAM,GAAG,KAAKhB,QAAL,CAAc2B,QAAd,CAAb;;AAEA,WAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,MAAM,CAACwC,UAAP,CAAkBZ,MAAtC,EAA8CN,CAAC,EAA/C,EAAmD;AACjDiB,QAAAA,OAAO,CAAC9B,IAAR,CAAa,KAAKtB,iBAAL,CAAuBwB,QAAQ,GAAG,GAAX,GAAiBX,MAAM,CAACwC,UAAP,CAAkBlB,CAAlB,CAAxC,CAAb;AACD;;AAED,aAAOiB,OAAP;AACD;AAGD;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,iBAAQH,SAAR,EAAmBC,SAAnB,EAA8B;AAC5B,aAAO,KAAKlD,iBAAL,CAAuBiD,SAAS,GAAG,GAAZ,GAAkBC,SAAzC,MAAwDC,SAA/D;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,yBAAgB;AACd,UAAIG,GAAG,GAAG,CAAC,KAAKzD,QAAL,CAAc4C,MAAf,CAAV;;AAEA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKtC,QAAL,CAAc4C,MAAlC,EAA0CN,CAAC,EAA3C,EAA+C;AAC7CmB,QAAAA,GAAG,CAACnB,CAAD,CAAH,GAAS,KAAKtC,QAAL,CAAcsC,CAAd,EAAiBf,EAA1B;AACD;;AAED,aAAOkC,GAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,uBAAc;AACZ,UAAIA,GAAG,GAAGxD,KAAK,CAAC,KAAKC,KAAL,CAAW0C,MAAZ,CAAf;;AAEA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKpC,KAAL,CAAW0C,MAA/B,EAAuCN,CAAC,EAAxC,EAA4C;AAC1CmB,QAAAA,GAAG,CAACnB,CAAD,CAAH,GAAS,CAAC,KAAKpC,KAAL,CAAWoC,CAAX,EAAcQ,QAAf,EAAyB,KAAK5C,KAAL,CAAWoC,CAAX,EAAcU,QAAvC,CAAT;AACD;;AAED,aAAOS,GAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,8BAAqB;AACnB,UAAIb,MAAM,GAAG,KAAK5C,QAAL,CAAc4C,MAA3B;AACA,UAAIc,eAAe,GAAGzD,KAAK,CAAC2C,MAAD,CAA3B;;AAEA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/BoB,QAAAA,eAAe,CAACpB,CAAD,CAAf,GAAqB,IAAIrC,KAAJ,CAAU2C,MAAV,CAArB;AACAc,QAAAA,eAAe,CAACpB,CAAD,CAAf,CAAmBqB,IAAnB,CAAwB,CAAxB;AACD;;AAED,WAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKpC,KAAL,CAAW0C,MAA/B,EAAuCN,CAAC,EAAxC,EAA4C;AAC1C,YAAIZ,IAAI,GAAG,KAAKxB,KAAL,CAAWoC,CAAX,CAAX;AAEAoB,QAAAA,eAAe,CAAChC,IAAI,CAACoB,QAAN,CAAf,CAA+BpB,IAAI,CAACsB,QAApC,IAAgD,CAAhD;AACAU,QAAAA,eAAe,CAAChC,IAAI,CAACsB,QAAN,CAAf,CAA+BtB,IAAI,CAACoB,QAApC,IAAgD,CAAhD;AACD;;AAED,aAAOY,eAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,wCAA+B;AAC7B,UAAId,MAAM,GAAG,KAAK5C,QAAL,CAAc4C,MAA3B;AACA,UAAIc,eAAe,GAAGzD,KAAK,CAAC2C,MAAD,CAA3B;AACA,UAAIgB,OAAO,GAAG,KAAKC,UAAL,EAAd;;AAEA,WAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/BoB,QAAAA,eAAe,CAACpB,CAAD,CAAf,GAAqB,IAAIrC,KAAJ,CAAU2C,MAAV,CAArB;AACAc,QAAAA,eAAe,CAACpB,CAAD,CAAf,CAAmBqB,IAAnB,CAAwB,CAAxB;AACD;;AAED,WAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKpC,KAAL,CAAW0C,MAA/B,EAAuCN,CAAC,EAAxC,EAA4C;AAC1C,YAAIZ,IAAI,GAAG,KAAKxB,KAAL,CAAWoC,CAAX,CAAX;AAEAoB,QAAAA,eAAe,CAAChC,IAAI,CAACoB,QAAN,CAAf,CAA+BpB,IAAI,CAACsB,QAApC,IAAgD,CAAhD;AACAU,QAAAA,eAAe,CAAChC,IAAI,CAACsB,QAAN,CAAf,CAA+BtB,IAAI,CAACoB,QAApC,IAAgD,CAAhD;AACD;;AAED,WAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsB,OAAO,CAAChB,MAA5B,EAAoCN,CAAC,EAArC,EAAyC;AACvCoB,QAAAA,eAAe,CAACE,OAAO,CAACtB,CAAD,CAAP,CAAW,CAAX,CAAD,CAAf,CAA+BsB,OAAO,CAACtB,CAAD,CAAP,CAAW,CAAX,CAA/B,IAAgD,CAAhD;AACAoB,QAAAA,eAAe,CAACE,OAAO,CAACtB,CAAD,CAAP,CAAW,CAAX,CAAD,CAAf,CAA+BsB,OAAO,CAACtB,CAAD,CAAP,CAAW,CAAX,CAA/B,IAAgD,CAAhD;AACD;;AAED,aAAOoB,eAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,oCAA2BI,SAA3B,EAAsC;AACpC,UAAIlB,MAAM,GAAGkB,SAAS,CAAClB,MAAvB;AACA,UAAIc,eAAe,GAAGzD,KAAK,CAAC2C,MAAD,CAA3B;;AAEA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/BoB,QAAAA,eAAe,CAACpB,CAAD,CAAf,GAAqB,IAAIrC,KAAJ,CAAU2C,MAAV,CAArB;AACAc,QAAAA,eAAe,CAACpB,CAAD,CAAf,CAAmBqB,IAAnB,CAAwB,CAAxB;;AAEA,aAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAApB,EAA4BmB,CAAC,EAA7B,EAAiC;AAC/B,cAAIzB,CAAC,KAAKyB,CAAV,EAAa;AACX;AACD;;AAED,cAAI,KAAKC,OAAL,CAAaF,SAAS,CAACxB,CAAD,CAAtB,EAA2BwB,SAAS,CAACC,CAAD,CAApC,CAAJ,EAA8C;AAC5CL,YAAAA,eAAe,CAACpB,CAAD,CAAf,CAAmByB,CAAnB,IAAwB,CAAxB;AACD;AACF;AACF;;AAED,aAAOL,eAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,6BAAoB;AAClB,UAAId,MAAM,GAAG,KAAK5C,QAAL,CAAc4C,MAA3B;AACA,UAAIqB,IAAI,GAAG,KAAKC,kBAAL,EAAX;AACA,UAAIC,IAAI,GAAGlE,KAAK,CAAC2C,MAAD,CAAhB;;AAEA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/B6B,QAAAA,IAAI,CAAC7B,CAAD,CAAJ,GAAUrC,KAAK,CAAC2C,MAAD,CAAf;AACAuB,QAAAA,IAAI,CAAC7B,CAAD,CAAJ,CAAQqB,IAAR,CAAaS,QAAb;AACD;;AAED,WAAK,IAAI9B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/B,aAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAApB,EAA4BmB,CAAC,EAA7B,EAAiC;AAC/B,cAAIE,IAAI,CAAC3B,CAAD,CAAJ,CAAQyB,CAAR,MAAe,CAAnB,EAAsB;AACpBI,YAAAA,IAAI,CAAC7B,CAAD,CAAJ,CAAQyB,CAAR,IAAa,CAAb;AACD;AACF;AACF;;AAED,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,MAApB,EAA4ByB,CAAC,EAA7B,EAAiC;AAC/B,aAAK,IAAI/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/B,eAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAApB,EAA4BmB,CAAC,EAA7B,EAAiC;AAC/B,gBAAII,IAAI,CAAC7B,CAAD,CAAJ,CAAQyB,CAAR,IAAaI,IAAI,CAAC7B,CAAD,CAAJ,CAAQ+B,CAAR,IAAaF,IAAI,CAACE,CAAD,CAAJ,CAAQN,CAAR,CAA9B,EAA0C;AACxCI,cAAAA,IAAI,CAAC7B,CAAD,CAAJ,CAAQyB,CAAR,IAAaI,IAAI,CAAC7B,CAAD,CAAJ,CAAQ+B,CAAR,IAAaF,IAAI,CAACE,CAAD,CAAJ,CAAQN,CAAR,CAA1B;AACD;AACF;AACF;AACF;;AAED,aAAOI,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,mCAA0BL,SAA1B,EAAqC;AACnC,UAAIlB,MAAM,GAAGkB,SAAS,CAAClB,MAAvB;AACA,UAAIqB,IAAI,GAAG,KAAKK,0BAAL,CAAgCR,SAAhC,CAAX;AACA,UAAIK,IAAI,GAAGlE,KAAK,CAAC2C,MAAD,CAAhB;;AAEA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/B6B,QAAAA,IAAI,CAAC7B,CAAD,CAAJ,GAAUrC,KAAK,CAAC2C,MAAD,CAAf;AACAuB,QAAAA,IAAI,CAAC7B,CAAD,CAAJ,CAAQqB,IAAR,CAAaS,QAAb;AACD;;AAED,WAAK,IAAI9B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/B,aAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAApB,EAA4BmB,CAAC,EAA7B,EAAiC;AAC/B,cAAIE,IAAI,CAAC3B,CAAD,CAAJ,CAAQyB,CAAR,MAAe,CAAnB,EAAsB;AACpBI,YAAAA,IAAI,CAAC7B,CAAD,CAAJ,CAAQyB,CAAR,IAAa,CAAb;AACD;AACF;AACF;;AAED,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzB,MAApB,EAA4ByB,CAAC,EAA7B,EAAiC;AAC/B,aAAK,IAAI/B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/B,eAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAApB,EAA4BmB,CAAC,EAA7B,EAAiC;AAC/B,gBAAII,IAAI,CAAC7B,CAAD,CAAJ,CAAQyB,CAAR,IAAaI,IAAI,CAAC7B,CAAD,CAAJ,CAAQ+B,CAAR,IAAaF,IAAI,CAACE,CAAD,CAAJ,CAAQN,CAAR,CAA9B,EAA0C;AACxCI,cAAAA,IAAI,CAAC7B,CAAD,CAAJ,CAAQyB,CAAR,IAAaI,IAAI,CAAC7B,CAAD,CAAJ,CAAQ+B,CAAR,IAAaF,IAAI,CAACE,CAAD,CAAJ,CAAQN,CAAR,CAA1B;AACD;AACF;AACF;AACF;;AAED,aAAOI,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,4BAAmB;AACjB,UAAIvB,MAAM,GAAG,KAAK5C,QAAL,CAAc4C,MAA3B;AACA,UAAI2B,aAAa,GAAGtE,KAAK,CAAC2C,MAAD,CAAzB;;AAEA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/BiC,QAAAA,aAAa,CAACjC,CAAD,CAAb,GAAmB,EAAnB;;AAEA,aAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAApB,EAA4BmB,CAAC,EAA7B,EAAiC;AAC/B,cAAIzB,CAAC,KAAKyB,CAAV,EAAa;AACX;AACD;;AAED,cAAI,KAAKC,OAAL,CAAa,KAAKhE,QAAL,CAAcsC,CAAd,EAAiBf,EAA9B,EAAkC,KAAKvB,QAAL,CAAc+D,CAAd,EAAiBxC,EAAnD,CAAJ,EAA4D;AAC1DgD,YAAAA,aAAa,CAACjC,CAAD,CAAb,CAAiBb,IAAjB,CAAsBsC,CAAtB;AACD;AACF;AACF;;AAED,aAAOQ,aAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,kCAAyBT,SAAzB,EAAoC;AAClC,UAAIlB,MAAM,GAAGkB,SAAS,CAAClB,MAAvB;AACA,UAAI2B,aAAa,GAAGtE,KAAK,CAAC2C,MAAD,CAAzB;;AAEA,WAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/BiC,QAAAA,aAAa,CAACjC,CAAD,CAAb,GAAmBrC,KAAK,EAAxB;;AAEA,aAAK,IAAI8D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAApB,EAA4BmB,CAAC,EAA7B,EAAiC;AAC/B,cAAIzB,CAAC,KAAKyB,CAAV,EAAa;AACX;AACD;;AAED,cAAI,KAAKC,OAAL,CAAaF,SAAS,CAACxB,CAAD,CAAtB,EAA2BwB,SAAS,CAACC,CAAD,CAApC,CAAJ,EAA8C;AAC5CQ,YAAAA,aAAa,CAACjC,CAAD,CAAb,CAAiBb,IAAjB,CAAsBsC,CAAtB;AACD;AACF;AACF;;AAED,aAAOQ,aAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;WACE,sBAAa;AACX,UAAI3B,MAAM,GAAG,KAAK5C,QAAL,CAAc4C,MAA3B;AACA,UAAI4B,OAAO,GAAG,IAAIvE,KAAJ,CAAU2C,MAAV,CAAd;AACA,UAAI6B,IAAI,GAAG,IAAIxE,KAAJ,CAAU2C,MAAV,CAAX;AACA,UAAI8B,GAAG,GAAG,IAAIzE,KAAJ,CAAU2C,MAAV,CAAV;AACA,UAAI+B,MAAM,GAAG,IAAI1E,KAAJ,CAAU2C,MAAV,CAAb;AACA,UAAIgC,GAAG,GAAG,KAAKC,gBAAL,EAAV;AACA,UAAIC,UAAU,GAAG7E,KAAK,EAAtB;AAEAuE,MAAAA,OAAO,CAACb,IAAR,CAAa,KAAb;AACAgB,MAAAA,MAAM,CAAChB,IAAP,CAAY,IAAZ;AACA,WAAKvD,KAAL,GAAa,CAAb;;AAEA,WAAK,IAAIkC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,MAApB,EAA4BN,CAAC,EAA7B,EAAiC;AAC/B,YAAI,CAACkC,OAAO,CAAClC,CAAD,CAAZ,EAAiB;AACf,eAAKyC,UAAL,CAAgBzC,CAAhB,EAAmBkC,OAAnB,EAA4BC,IAA5B,EAAkCC,GAAlC,EAAuCC,MAAvC,EAA+CC,GAA/C,EAAoDE,UAApD;AACD;AACF;;AAED,aAAOA,UAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,oBAAWE,aAAX,EAA0BC,QAA1B,EAAoC;AAClC,UAAIrC,MAAM,GAAG,KAAK5C,QAAL,CAAc4C,MAA3B;AACA,UAAI4B,OAAO,GAAG,IAAIvE,KAAJ,CAAU2C,MAAV,CAAd;AAEA4B,MAAAA,OAAO,CAACb,IAAR,CAAa,KAAb;AAEA,UAAIuB,KAAK,GAAG,CAACF,aAAD,CAAZ;;AAEA,aAAOE,KAAK,CAACtC,MAAN,GAAe,CAAtB,EAAyB;AACvB;AACA,YAAIuC,CAAC,GAAGD,KAAK,CAACE,KAAN,EAAR;AACA,YAAIpE,MAAM,GAAG,KAAKhB,QAAL,CAAcmF,CAAd,CAAb;AAEAF,QAAAA,QAAQ,CAACjE,MAAD,CAAR;;AAEA,aAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,MAAM,CAACwC,UAAP,CAAkBZ,MAAtC,EAA8CN,CAAC,EAA/C,EAAmD;AACjD,cAAI+C,CAAC,GAAGrE,MAAM,CAACwC,UAAP,CAAkBlB,CAAlB,CAAR;;AACA,cAAI,CAACkC,OAAO,CAACa,CAAD,CAAZ,EAAiB;AACfb,YAAAA,OAAO,CAACa,CAAD,CAAP,GAAa,IAAb;AACAH,YAAAA,KAAK,CAACzD,IAAN,CAAW4D,CAAX;AACD;AACF;AACF;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;;WACE,sBAAa1D,QAAb,EAAuBnB,cAAvB,EAAuC;AACrC,UAAImB,QAAQ,KAAK,IAAb,IAAqBnB,cAAc,KAAK,IAA5C,EAAkD;AAChD,eAAO,CAAP;AACD;;AAED,UAAIgD,UAAU,GAAG,KAAKxD,QAAL,CAAc2B,QAAd,EAAwB2D,yBAAxB,CAAkD9E,cAAlD,CAAjB;AACA,UAAI+E,GAAG,GAAG,CAAV;;AAEA,WAAK,IAAIjD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkB,UAAU,CAACZ,MAA/B,EAAuCN,CAAC,EAAxC,EAA4C;AAC1C,YAAIkD,OAAO,GAAGhC,UAAU,CAAClB,CAAD,CAAxB;AACA,YAAImD,CAAC,GAAG,KAAKC,YAAL,CAAkBF,OAAlB,EAA2B7D,QAA3B,CAAR;;AAEA,YAAI8D,CAAC,GAAGF,GAAR,EAAa;AACXA,UAAAA,GAAG,GAAGE,CAAN;AACD;AACF;;AAED,aAAOF,GAAG,GAAG,CAAb;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,sBAAa5D,QAAb,EAAuBnB,cAAvB,EAAuCyE,QAAvC,EAAoH;AAAA,UAAnEU,QAAmE,uEAAxD,MAAwD;AAAA,UAAhDC,WAAgD,uEAAlC,KAAkC;AAAA,UAA3BC,KAA2B,uEAAnB,CAAmB;AAAA,UAAhBrB,OAAgB,uEAAN,IAAM;;AAClH,UAAIA,OAAO,KAAK,IAAhB,EAAsB;AACpBA,QAAAA,OAAO,GAAG,IAAIsB,UAAJ,CAAe,KAAK9F,QAAL,CAAc4C,MAA7B,CAAV;AACD;;AAED,UAAIiD,KAAK,GAAGF,QAAQ,GAAG,CAAnB,IAAwBnB,OAAO,CAAC7C,QAAD,CAAP,KAAsB,CAAlD,EAAqD;AACnD;AACD;;AAED6C,MAAAA,OAAO,CAAC7C,QAAD,CAAP,GAAoB,CAApB;AAEA,UAAIX,MAAM,GAAG,KAAKhB,QAAL,CAAc2B,QAAd,CAAb;AACA,UAAI6B,UAAU,GAAGxC,MAAM,CAAC+E,aAAP,CAAqBvF,cAArB,CAAjB;;AAEA,UAAI,CAACoF,WAAD,IAAgBC,KAAK,GAAG,CAA5B,EAA+B;AAC7BZ,QAAAA,QAAQ,CAACjE,MAAD,CAAR;AACD;;AAED,WAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkB,UAAU,CAACZ,MAA/B,EAAuCN,CAAC,EAAxC,EAA4C;AAC1C,aAAK0D,YAAL,CAAkBxC,UAAU,CAAClB,CAAD,CAA5B,EAAiCX,QAAjC,EAA2CsD,QAA3C,EAAqDU,QAArD,EAA+DC,WAA/D,EAA4EC,KAAK,GAAG,CAApF,EAAuFrB,OAAvF;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,kBAASV,SAAT,EAAoBmC,MAApB,EAA4BjB,aAA5B,EAA2CkB,IAA3C,EAAiDC,UAAjD,EAE2C;AAAA,UADzCC,SACyC,uEAD7B,GAC6B;AAAA,UADxBC,cACwB,uEADP,GACO;AAAA,UADFC,YACE,uEADa,IACb;AAAA,UAAzCC,iBAAyC,uEAArB,EAAqB;AAAA,UAAjBC,SAAiB,uEAAL,GAAK;AAEzC,UAAIC,YAAY,GAAGN,UAAnB,CAFyC,CAIzC;;AACA,UAAI7D,CAAC,GAAGwB,SAAS,CAAClB,MAAlB;;AACA,aAAON,CAAC,EAAR,EAAY;AACV,YAAItB,MAAM,GAAG,KAAKhB,QAAL,CAAc8D,SAAS,CAACxB,CAAD,CAAvB,CAAb;AACA,YAAIyB,CAAC,GAAG/C,MAAM,CAACwC,UAAP,CAAkBZ,MAA1B;AACD;;AAED,UAAI8D,OAAO,GAAG,KAAKC,yBAAL,CAA+B7C,SAA/B,CAAd;AACA,UAAIlB,MAAM,GAAGkB,SAAS,CAAClB,MAAvB,CAZyC,CAczC;;AACA,UAAIgE,MAAM,GAAGtH,UAAU,CAACuH,gBAAX,CAA4B,GAA5B,EAAiCjE,MAAjC,CAAb;AACA,UAAIkE,KAAK,GAAGxH,UAAU,CAACyH,YAAX,CAAwBnE,MAAxB,CAAZ;AACA,UAAIoE,CAAC,GAAG,GAAR;AACA,UAAIC,YAAY,GAAG,IAAIC,YAAJ,CAAiBtE,MAAjB,CAAnB;AACA,UAAIuE,YAAY,GAAG,IAAID,YAAJ,CAAiBtE,MAAjB,CAAnB;AACA,UAAIwE,aAAa,GAAGnH,KAAK,CAAC2C,MAAD,CAAzB;AAEAN,MAAAA,CAAC,GAAGM,MAAJ;;AACA,aAAON,CAAC,EAAR,EAAY;AACV,YAAItB,OAAM,GAAG,KAAKhB,QAAL,CAAc8D,SAAS,CAACxB,CAAD,CAAvB,CAAb;;AACA,YAAI,CAACtB,OAAM,CAACqG,UAAZ,EAAwB;AACtBJ,UAAAA,YAAY,CAAC3E,CAAD,CAAZ,GAAkB2D,MAAM,CAACqB,CAAP,GAAWC,IAAI,CAACC,GAAL,CAASR,CAAT,IAAcJ,MAA3C;AACAO,UAAAA,YAAY,CAAC7E,CAAD,CAAZ,GAAkB2D,MAAM,CAACwB,CAAP,GAAWF,IAAI,CAACG,GAAL,CAASV,CAAT,IAAcJ,MAA3C;AACD,SAHD,MAGO;AACLK,UAAAA,YAAY,CAAC3E,CAAD,CAAZ,GAAkBtB,OAAM,CAAC2G,QAAP,CAAgBL,CAAlC;AACAH,UAAAA,YAAY,CAAC7E,CAAD,CAAZ,GAAkBtB,OAAM,CAAC2G,QAAP,CAAgBF,CAAlC;AACD;;AACDL,QAAAA,aAAa,CAAC9E,CAAD,CAAb,GAAmBtB,OAAM,CAACqG,UAA1B;AACAL,QAAAA,CAAC,IAAIF,KAAL;AACD,OAlCwC,CAoCzC;;;AACA,UAAIc,SAAS,GAAG3H,KAAK,CAAC2C,MAAD,CAArB;AACAN,MAAAA,CAAC,GAAGM,MAAJ;;AACA,aAAON,CAAC,EAAR,EAAY;AACVsF,QAAAA,SAAS,CAACtF,CAAD,CAAT,GAAe,IAAIrC,KAAJ,CAAU2C,MAAV,CAAf;AACA,YAAImB,CAAC,GAAGnB,MAAR;;AACA,eAAOmB,CAAC,EAAR,EAAY;AACV6D,UAAAA,SAAS,CAACtF,CAAD,CAAT,CAAayB,CAAb,IAAkBoC,UAAU,GAAGO,OAAO,CAACpE,CAAD,CAAP,CAAWyB,CAAX,CAA/B;AACD;AACF,OA7CwC,CA+CzC;;;AACA,UAAI8D,WAAW,GAAG5H,KAAK,CAAC2C,MAAD,CAAvB;AACAN,MAAAA,CAAC,GAAGM,MAAJ;;AACA,aAAON,CAAC,EAAR,EAAY;AACVuF,QAAAA,WAAW,CAACvF,CAAD,CAAX,GAAiBrC,KAAK,CAAC2C,MAAD,CAAtB;AACA,YAAImB,CAAC,GAAGnB,MAAR;;AACA,eAAOmB,CAAC,EAAR,EAAY;AACV8D,UAAAA,WAAW,CAACvF,CAAD,CAAX,CAAeyB,CAAf,IAAoB0C,YAAY,GAAGc,IAAI,CAACO,GAAL,CAASpB,OAAO,CAACpE,CAAD,CAAP,CAAWyB,CAAX,CAAT,EAAwB,CAAC,GAAzB,CAAnC;AACD;AACF,OAxDwC,CA0DzC;;;AACA,UAAIgE,SAAS,GAAG9H,KAAK,CAAC2C,MAAD,CAArB;AACA,UAAIoF,aAAa,GAAG,IAAId,YAAJ,CAAiBtE,MAAjB,CAApB;AACA,UAAIqF,aAAa,GAAG,IAAIf,YAAJ,CAAiBtE,MAAjB,CAApB;AACAN,MAAAA,CAAC,GAAGM,MAAJ;;AACA,aAAON,CAAC,EAAR,EAAY;AACVyF,QAAAA,SAAS,CAACzF,CAAD,CAAT,GAAerC,KAAK,CAAC2C,MAAD,CAApB;AACD;;AAEDN,MAAAA,CAAC,GAAGM,MAAJ;AACA,UAAIsF,EAAJ,EAAQC,EAAR,EAAYC,GAAZ,EAAiBC,GAAjB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BC,KAA9B;;AAEA,aAAOlG,CAAC,EAAR,EAAY;AACV4F,QAAAA,EAAE,GAAGjB,YAAY,CAAC3E,CAAD,CAAjB;AACA6F,QAAAA,EAAE,GAAGhB,YAAY,CAAC7E,CAAD,CAAjB;AACA8F,QAAAA,GAAG,GAAG,GAAN;AACAC,QAAAA,GAAG,GAAG,GAAN;AACA,YAAItE,EAAC,GAAGnB,MAAR;;AACA,eAAOmB,EAAC,EAAR,EAAY;AACV,cAAIzB,CAAC,KAAKyB,EAAV,EAAa;AACX;AACD;;AACDuE,UAAAA,EAAE,GAAGrB,YAAY,CAAClD,EAAD,CAAjB;AACAwE,UAAAA,EAAE,GAAGpB,YAAY,CAACpD,EAAD,CAAjB;AACAyE,UAAAA,KAAK,GAAG,MAAMjB,IAAI,CAACkB,IAAL,CAAU,CAACP,EAAE,GAAGI,EAAN,KAAaJ,EAAE,GAAGI,EAAlB,IAAwB,CAACH,EAAE,GAAGI,EAAN,KAAaJ,EAAE,GAAGI,EAAlB,CAAlC,CAAd;AACAR,UAAAA,SAAS,CAACzF,CAAD,CAAT,CAAayB,EAAb,IAAkB,CAChB8D,WAAW,CAACvF,CAAD,CAAX,CAAeyB,EAAf,KAAsBmE,EAAE,GAAGI,EAAN,GAAYV,SAAS,CAACtF,CAAD,CAAT,CAAayB,EAAb,KAAmBmE,EAAE,GAAGI,EAAxB,IAA8BE,KAA/D,CADgB,EAEhBX,WAAW,CAACvF,CAAD,CAAX,CAAeyB,EAAf,KAAsBoE,EAAE,GAAGI,EAAN,GAAYX,SAAS,CAACtF,CAAD,CAAT,CAAayB,EAAb,KAAmBoE,EAAE,GAAGI,EAAxB,IAA8BC,KAA/D,CAFgB,CAAlB;AAIAT,UAAAA,SAAS,CAAChE,EAAD,CAAT,CAAazB,CAAb,IAAkByF,SAAS,CAACzF,CAAD,CAAT,CAAayB,EAAb,CAAlB;AACAqE,UAAAA,GAAG,IAAIL,SAAS,CAACzF,CAAD,CAAT,CAAayB,EAAb,EAAgB,CAAhB,CAAP;AACAsE,UAAAA,GAAG,IAAIN,SAAS,CAACzF,CAAD,CAAT,CAAayB,EAAb,EAAgB,CAAhB,CAAP;AACD;;AACDiE,QAAAA,aAAa,CAAC1F,CAAD,CAAb,GAAmB8F,GAAnB;AACAH,QAAAA,aAAa,CAAC3F,CAAD,CAAb,GAAmB+F,GAAnB;AACD,OA7FwC,CA+FzC;;;AACA,UAAIK,MAAM,GAAG,SAATA,MAAS,CAAUC,KAAV,EAAiB;AAC5B,eAAO,CAACX,aAAa,CAACW,KAAD,CAAb,GAAuBX,aAAa,CAACW,KAAD,CAApC,GAA8CV,aAAa,CAACU,KAAD,CAAb,GAAuBV,aAAa,CAACU,KAAD,CAAnF,EAA4FX,aAAa,CAACW,KAAD,CAAzG,EAAkHV,aAAa,CAACU,KAAD,CAA/H,CAAP;AACD,OAFD;;AAIA,UAAIC,aAAa,GAAG,SAAhBA,aAAgB,GAAY;AAC9B,YAAIpC,SAAS,GAAG,GAAhB;AACA,YAAIqC,WAAW,GAAG,CAAlB;AACA,YAAIC,MAAM,GAAG,GAAb;AACA,YAAIC,MAAM,GAAG,GAAb;AAEAzG,QAAAA,CAAC,GAAGM,MAAJ;;AACA,eAAON,CAAC,EAAR,EAAY;AAAA,wBACcoG,MAAM,CAACpG,CAAD,CADpB;AAAA;AAAA,cACL0G,MADK;AAAA,cACEC,IADF;AAAA,cACOC,IADP;;AAGV,cAAIF,MAAK,GAAGxC,SAAR,IAAqBY,aAAa,CAAC9E,CAAD,CAAb,KAAqB,KAA9C,EAAqD;AACnDkE,YAAAA,SAAS,GAAGwC,MAAZ;AACAH,YAAAA,WAAW,GAAGvG,CAAd;AACAwG,YAAAA,MAAM,GAAGG,IAAT;AACAF,YAAAA,MAAM,GAAGG,IAAT;AACD;AACF;;AAED,eAAO,CAACL,WAAD,EAAcrC,SAAd,EAAyBsC,MAAzB,EAAiCC,MAAjC,CAAP;AACD,OAnBD;;AAqBA,UAAII,MAAM,GAAG,SAATA,MAAS,CAAUR,KAAV,EAAiBM,GAAjB,EAAsBC,GAAtB,EAA2B;AACtC,YAAIE,GAAG,GAAG,GAAV;AACA,YAAIC,GAAG,GAAG,GAAV;AACA,YAAIC,GAAG,GAAG,GAAV;AACA,YAAIpB,EAAE,GAAGjB,YAAY,CAAC0B,KAAD,CAArB;AACA,YAAIR,EAAE,GAAGhB,YAAY,CAACwB,KAAD,CAArB;AACA,YAAIY,IAAI,GAAG3B,SAAS,CAACe,KAAD,CAApB;AACA,YAAIa,IAAI,GAAG3B,WAAW,CAACc,KAAD,CAAtB;AAEArG,QAAAA,CAAC,GAAGM,MAAJ;;AACA,eAAON,CAAC,EAAR,EAAY;AACV,cAAIA,CAAC,KAAKqG,KAAV,EAAiB;AACf;AACD;;AAED,cAAIL,GAAE,GAAGrB,YAAY,CAAC3E,CAAD,CAArB;AACA,cAAIiG,GAAE,GAAGpB,YAAY,CAAC7E,CAAD,CAArB;AACA,cAAImH,CAAC,GAAGF,IAAI,CAACjH,CAAD,CAAZ;AACA,cAAI+B,CAAC,GAAGmF,IAAI,CAAClH,CAAD,CAAZ;AACA,cAAIoH,CAAC,GAAG,CAACxB,EAAE,GAAGI,GAAN,KAAaJ,EAAE,GAAGI,GAAlB,CAAR;;AACA,cAAIE,MAAK,GAAG,MAAMjB,IAAI,CAACO,GAAL,CAAS4B,CAAC,GAAG,CAACvB,EAAE,GAAGI,GAAN,KAAaJ,EAAE,GAAGI,GAAlB,CAAb,EAAoC,GAApC,CAAlB;;AAEAa,UAAAA,GAAG,IAAI/E,CAAC,IAAI,IAAIoF,CAAC,IAAItB,EAAE,GAAGI,GAAT,CAAD,IAAiBJ,EAAE,GAAGI,GAAtB,IAA4BC,MAApC,CAAR;AACAa,UAAAA,GAAG,IAAIhF,CAAC,IAAI,IAAIoF,CAAC,GAAGC,CAAJ,GAAQlB,MAAhB,CAAR;AACAc,UAAAA,GAAG,IAAIjF,CAAC,IAAIoF,CAAC,IAAIvB,EAAE,GAAGI,GAAT,CAAD,IAAiBH,EAAE,GAAGI,GAAtB,IAA4BC,MAAhC,CAAR;AACD,SAzBqC,CA2BtC;;;AACA,YAAIY,GAAG,KAAK,CAAZ,EAAe;AACbA,UAAAA,GAAG,GAAG,GAAN;AACD;;AAED,YAAIC,GAAG,KAAK,CAAZ,EAAe;AACbA,UAAAA,GAAG,GAAG,GAAN;AACD;;AAED,YAAIC,GAAG,KAAK,CAAZ,EAAe;AACbA,UAAAA,GAAG,GAAG,GAAN;AACD;;AAED,YAAIK,EAAE,GAAIV,GAAG,GAAGG,GAAN,GAAYF,GAAG,GAAGI,GAA5B;AACAK,QAAAA,EAAE,IAAKL,GAAG,GAAGF,GAAN,GAAYC,GAAG,GAAGC,GAAzB,CAzCsC,CAyCP;;AAC/B,YAAIM,EAAE,GAAG,EAAEN,GAAG,GAAGK,EAAN,GAAWV,GAAb,IAAoBG,GAA7B;AAEAnC,QAAAA,YAAY,CAAC0B,KAAD,CAAZ,IAAuBiB,EAAvB;AACAzC,QAAAA,YAAY,CAACwB,KAAD,CAAZ,IAAuBgB,EAAvB,CA7CsC,CA+CtC;;AACA,YAAIE,IAAI,GAAG9B,SAAS,CAACY,KAAD,CAApB;AACAM,QAAAA,GAAG,GAAG,GAAN;AACAC,QAAAA,GAAG,GAAG,GAAN;AAEAhB,QAAAA,EAAE,GAAGjB,YAAY,CAAC0B,KAAD,CAAjB;AACAR,QAAAA,EAAE,GAAGhB,YAAY,CAACwB,KAAD,CAAjB;AAEA,YAAIL,EAAJ,EAAQC,EAAR,EAAYuB,MAAZ,EAAoBC,MAApB,EAA4BvB,KAA5B;AAEAlG,QAAAA,CAAC,GAAGM,MAAJ;;AACA,eAAON,CAAC,EAAR,EAAY;AACV,cAAIqG,KAAK,KAAKrG,CAAd,EAAiB;AACf;AACD;;AACDgG,UAAAA,EAAE,GAAGrB,YAAY,CAAC3E,CAAD,CAAjB;AACAiG,UAAAA,EAAE,GAAGpB,YAAY,CAAC7E,CAAD,CAAjB,CALU,CAMV;;AACAwH,UAAAA,MAAM,GAAGD,IAAI,CAACvH,CAAD,CAAJ,CAAQ,CAAR,CAAT;AACAyH,UAAAA,MAAM,GAAGF,IAAI,CAACvH,CAAD,CAAJ,CAAQ,CAAR,CAAT;AACAkG,UAAAA,KAAK,GAAG,MAAMjB,IAAI,CAACkB,IAAL,CAAU,CAACP,EAAE,GAAGI,EAAN,KAAaJ,EAAE,GAAGI,EAAlB,IAAwB,CAACH,EAAE,GAAGI,EAAN,KAAaJ,EAAE,GAAGI,EAAlB,CAAlC,CAAd;AACAqB,UAAAA,EAAE,GAAGJ,IAAI,CAAClH,CAAD,CAAJ,IAAY4F,EAAE,GAAGI,EAAN,GAAYiB,IAAI,CAACjH,CAAD,CAAJ,IAAW4F,EAAE,GAAGI,EAAhB,IAAsBE,KAA7C,CAAL;AACAmB,UAAAA,EAAE,GAAGH,IAAI,CAAClH,CAAD,CAAJ,IAAY6F,EAAE,GAAGI,EAAN,GAAYgB,IAAI,CAACjH,CAAD,CAAJ,IAAW6F,EAAE,GAAGI,EAAhB,IAAsBC,KAA7C,CAAL;AAEAqB,UAAAA,IAAI,CAACvH,CAAD,CAAJ,GAAU,CAACsH,EAAD,EAAKD,EAAL,CAAV;AACAV,UAAAA,GAAG,IAAIW,EAAP;AACAV,UAAAA,GAAG,IAAIS,EAAP;AACA3B,UAAAA,aAAa,CAAC1F,CAAD,CAAb,IAAoBsH,EAAE,GAAGE,MAAzB;AACA7B,UAAAA,aAAa,CAAC3F,CAAD,CAAb,IAAoBqH,EAAE,GAAGI,MAAzB;AACD;;AACD/B,QAAAA,aAAa,CAACW,KAAD,CAAb,GAAuBM,GAAvB;AACAhB,QAAAA,aAAa,CAACU,KAAD,CAAb,GAAuBO,GAAvB;AACD,OA/ED,CAzHyC,CA0MzC;;;AACA,UAAIL,WAAW,GAAG,CAAlB;AACA,UAAII,GAAG,GAAG,GAAV;AACA,UAAIC,GAAG,GAAG,GAAV;AACA,UAAIF,KAAK,GAAG,GAAZ;AACA,UAAIgB,SAAS,GAAG,CAAhB;AACA,UAAIC,cAAc,GAAG,CAArB;;AAEA,aAAOzD,SAAS,GAAGJ,SAAZ,IAAyBE,YAAY,GAAG0D,SAA/C,EAA0D;AACxDA,QAAAA,SAAS;;AAD+C,6BAEnBpB,aAAa,EAFM;;AAAA;;AAEvDC,QAAAA,WAFuD;AAE1CrC,QAAAA,SAF0C;AAE/ByC,QAAAA,GAF+B;AAE1BC,QAAAA,GAF0B;AAGxDF,QAAAA,KAAK,GAAGxC,SAAR;AACAyD,QAAAA,cAAc,GAAG,CAAjB;;AACA,eAAOjB,KAAK,GAAG3C,cAAR,IAA0BE,iBAAiB,GAAG0D,cAArD,EAAqE;AACnEA,UAAAA,cAAc;AACdd,UAAAA,MAAM,CAACN,WAAD,EAAcI,GAAd,EAAmBC,GAAnB,CAAN;;AAFmE,yBAG/CR,MAAM,CAACG,WAAD,CAHyC;;AAAA;;AAGlEG,UAAAA,KAHkE;AAG3DC,UAAAA,GAH2D;AAGtDC,UAAAA,GAHsD;AAIpE;AACF;;AAED5G,MAAAA,CAAC,GAAGM,MAAJ;;AACA,aAAON,CAAC,EAAR,EAAY;AACV,YAAIqG,KAAK,GAAG7E,SAAS,CAACxB,CAAD,CAArB;AACA,YAAItB,QAAM,GAAG,KAAKhB,QAAL,CAAc2I,KAAd,CAAb;AACA3H,QAAAA,QAAM,CAAC2G,QAAP,CAAgBL,CAAhB,GAAoBL,YAAY,CAAC3E,CAAD,CAAhC;AACAtB,QAAAA,QAAM,CAAC2G,QAAP,CAAgBF,CAAhB,GAAoBN,YAAY,CAAC7E,CAAD,CAAhC;AACAtB,QAAAA,QAAM,CAACqG,UAAP,GAAoB,IAApB;AACArG,QAAAA,QAAM,CAACkJ,eAAP,GAAyB,IAAzB;AACD;AACF;AAED;AACF;AACA;;;;WACE,oBAAW/E,CAAX,EAAcX,OAAd,EAAuBC,IAAvB,EAA6BC,GAA7B,EAAkCC,MAAlC,EAA0CC,GAA1C,EAA+CE,UAA/C,EAA2D;AACzDN,MAAAA,OAAO,CAACW,CAAD,CAAP,GAAa,IAAb;AACAV,MAAAA,IAAI,CAACU,CAAD,CAAJ,GAAUT,GAAG,CAACS,CAAD,CAAH,GAAS,EAAE,KAAK/E,KAA1B;;AAEA,WAAK,IAAIkC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,GAAG,CAACO,CAAD,CAAH,CAAOvC,MAA3B,EAAmCN,CAAC,EAApC,EAAwC;AACtC,YAAI+C,CAAC,GAAGT,GAAG,CAACO,CAAD,CAAH,CAAO7C,CAAP,CAAR;;AAEA,YAAI,CAACkC,OAAO,CAACa,CAAD,CAAZ,EAAiB;AACfV,UAAAA,MAAM,CAACU,CAAD,CAAN,GAAYF,CAAZ;;AAEA,eAAKJ,UAAL,CAAgBM,CAAhB,EAAmBb,OAAnB,EAA4BC,IAA5B,EAAkCC,GAAlC,EAAuCC,MAAvC,EAA+CC,GAA/C,EAAoDE,UAApD;;AAEAJ,UAAAA,GAAG,CAACS,CAAD,CAAH,GAASoC,IAAI,CAAC4C,GAAL,CAASzF,GAAG,CAACS,CAAD,CAAZ,EAAiBT,GAAG,CAACW,CAAD,CAApB,CAAT,CALe,CAOf;;AACA,cAAIX,GAAG,CAACW,CAAD,CAAH,GAASZ,IAAI,CAACU,CAAD,CAAjB,EAAsB;AACpBL,YAAAA,UAAU,CAACrD,IAAX,CAAgB,CAAC0D,CAAD,EAAIE,CAAJ,CAAhB;AACD;AACF,SAXD,MAWO,IAAIA,CAAC,KAAKV,MAAM,CAACQ,CAAD,CAAhB,EAAqB;AAC1BT,UAAAA,GAAG,CAACS,CAAD,CAAH,GAASoC,IAAI,CAAC4C,GAAL,CAASzF,GAAG,CAACS,CAAD,CAAZ,EAAiBV,IAAI,CAACY,CAAD,CAArB,CAAT;AACD;AACF;AACF;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,gCAA8B3B,eAA9B,EAA+C;AAC7C,UAAId,MAAM,GAAGc,eAAe,CAACd,MAA7B;AACA,UAAI4B,OAAO,GAAG,IAAIvE,KAAJ,CAAU2C,MAAV,CAAd;AACA,UAAIwH,UAAU,GAAG,IAAInK,KAAJ,EAAjB;AACA,UAAIoK,KAAK,GAAG,CAAZ;AAEA7F,MAAAA,OAAO,CAACb,IAAR,CAAa,KAAb;;AAEA,WAAK,IAAIwB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvC,MAApB,EAA4BuC,CAAC,EAA7B,EAAiC;AAC/B,YAAI,CAACX,OAAO,CAACW,CAAD,CAAZ,EAAiB;AACf,cAAImF,SAAS,GAAGrK,KAAK,EAArB;AACAuE,UAAAA,OAAO,CAACW,CAAD,CAAP,GAAa,IAAb;AACAmF,UAAAA,SAAS,CAAC7I,IAAV,CAAe0D,CAAf;AACAkF,UAAAA,KAAK;;AACLxK,UAAAA,KAAK,CAAC0K,SAAN,CAAgBpF,CAAhB,EAAmBX,OAAnB,EAA4Bd,eAA5B,EAA6C4G,SAA7C;;AACA,cAAIA,SAAS,CAAC1H,MAAV,GAAmB,CAAvB,EAA0B;AACxBwH,YAAAA,UAAU,CAAC3I,IAAX,CAAgB6I,SAAhB;AACD;AACF;AACF;;AAED,aAAOF,UAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;;WACE,oCAAkC1G,eAAlC,EAAmD;AACjD,UAAId,MAAM,GAAGc,eAAe,CAACd,MAA7B;AACA,UAAI4B,OAAO,GAAG,IAAIvE,KAAJ,CAAU2C,MAAV,CAAd;AACA,UAAIyH,KAAK,GAAG,CAAZ;AAEA7F,MAAAA,OAAO,CAACb,IAAR,CAAa,KAAb;;AAEA,WAAK,IAAIwB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvC,MAApB,EAA4BuC,CAAC,EAA7B,EAAiC;AAC/B,YAAI,CAACX,OAAO,CAACW,CAAD,CAAZ,EAAiB;AACfX,UAAAA,OAAO,CAACW,CAAD,CAAP,GAAa,IAAb;AACAkF,UAAAA,KAAK;;AACLxK,UAAAA,KAAK,CAAC2K,WAAN,CAAkBrF,CAAlB,EAAqBX,OAArB,EAA8Bd,eAA9B;AACD;AACF;;AAED,aAAO2G,KAAP;AACD;AAED;AACF;AACA;;;;WACE,qBAAmBlF,CAAnB,EAAsBX,OAAtB,EAA+Bd,eAA/B,EAAgD;AAC9C,WAAK,IAAI2B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3B,eAAe,CAACyB,CAAD,CAAf,CAAmBvC,MAAvC,EAA+CyC,CAAC,EAAhD,EAAoD;AAClD,YAAIoF,CAAC,GAAG/G,eAAe,CAACyB,CAAD,CAAf,CAAmBE,CAAnB,CAAR;;AAEA,YAAI,CAACoF,CAAD,IAAMjG,OAAO,CAACa,CAAD,CAAb,IAAoBF,CAAC,KAAKE,CAA9B,EAAiC;AAC/B;AACD;;AAEDb,QAAAA,OAAO,CAACa,CAAD,CAAP,GAAa,IAAb;;AACAxF,QAAAA,KAAK,CAAC2K,WAAN,CAAkBnF,CAAlB,EAAqBb,OAArB,EAA8Bd,eAA9B;AACD;AACF;AAED;AACF;AACA;;;;WACE,mBAAiByB,CAAjB,EAAoBX,OAApB,EAA6Bd,eAA7B,EAA8C4G,SAA9C,EAAyD;AACvD,WAAK,IAAIjF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3B,eAAe,CAACyB,CAAD,CAAf,CAAmBvC,MAAvC,EAA+CyC,CAAC,EAAhD,EAAoD;AAClD,YAAIoF,CAAC,GAAG/G,eAAe,CAACyB,CAAD,CAAf,CAAmBE,CAAnB,CAAR;;AAEA,YAAI,CAACoF,CAAD,IAAMjG,OAAO,CAACa,CAAD,CAAb,IAAoBF,CAAC,KAAKE,CAA9B,EAAiC;AAC/B;AACD;;AAEDb,QAAAA,OAAO,CAACa,CAAD,CAAP,GAAa,IAAb;AACAiF,QAAAA,SAAS,CAAC7I,IAAV,CAAe4D,CAAf;;AACAxF,QAAAA,KAAK,CAAC0K,SAAN,CAAgBlF,CAAhB,EAAmBb,OAAnB,EAA4Bd,eAA5B,EAA6C4G,SAA7C;AACD;AACF;;;;;;AAGHI,MAAM,CAACC,OAAP,GAAiB9K,KAAjB","sourcesContent":["//@ts-check\r\nconst MathHelper = require('./MathHelper')\r\nconst Vector2 = require('./Vector2')\r\nconst Vertex = require('./Vertex')\r\nconst Edge = require('./Edge')\r\nconst Ring = require('./Ring')\r\nconst Atom = require('./Atom')\r\n\r\n/** \r\n * A class representing the molecular graph. \r\n * \r\n * @property {Vertex[]} vertices The vertices of the graph.\r\n * @property {Edge[]} edges The edges of this graph.\r\n * @property {Object} vertexIdsToEdgeId A map mapping vertex ids to the edge between the two vertices. The key is defined as vertexAId + '_' + vertexBId.\r\n * @property {Boolean} isometric A boolean indicating whether or not the SMILES associated with this graph is isometric.\r\n */\r\nclass Graph {\r\n  /**\r\n   * The constructor of the class Graph.\r\n   * \r\n   * @param {Object} parseTree A SMILES parse tree.\r\n   * @param {Boolean} [isomeric=false] A boolean specifying whether or not the SMILES is isomeric.\r\n   */\r\n  constructor(parseTree, isomeric = false) {\r\n    this.vertices = Array();\r\n    this.edges = Array();\r\n    this.vertexIdsToEdgeId = {};\r\n    this.isomeric = isomeric;\r\n\r\n    // Used for the bridge detection algorithm\r\n    this._time = 0;\r\n    this._init(parseTree);\r\n  }\r\n\r\n  /**\r\n   * PRIVATE FUNCTION. Initializing the graph from the parse tree.\r\n   *\r\n   * @param {Object} node The current node in the parse tree.\r\n   * @param {Number} parentVertexId=null The id of the previous vertex.\r\n   * @param {Boolean} isBranch=false Whether or not the bond leading to this vertex is a branch bond. Branches are represented by parentheses in smiles (e.g. CC(O)C).\r\n   */\r\n  _init(node, order = 0, parentVertexId = null, isBranch = false) {\r\n    // Create a new vertex object\r\n    let atom = new Atom(node.atom.element ? node.atom.element : node.atom, node.bond);\r\n\r\n    atom.branchBond = node.branchBond;\r\n    atom.ringbonds = node.ringbonds;\r\n    atom.bracket = node.atom.element ? node.atom : null;\r\n\r\n    let vertex = new Vertex(atom);\r\n    let parentVertex = this.vertices[parentVertexId];\r\n\r\n    this.addVertex(vertex);\r\n\r\n    // Add the id of this node to the parent as child\r\n    if (parentVertexId !== null) {\r\n      vertex.setParentVertexId(parentVertexId);\r\n      vertex.value.addNeighbouringElement(parentVertex.value.element);\r\n      parentVertex.addChild(vertex.id);\r\n      parentVertex.value.addNeighbouringElement(atom.element);\r\n\r\n      // In addition create a spanningTreeChildren property, which later will\r\n      // not contain the children added through ringbonds\r\n      parentVertex.spanningTreeChildren.push(vertex.id);\r\n\r\n      // Add edge between this node and its parent\r\n      let edge = new Edge(parentVertexId, vertex.id, 1);\r\n      let vertexId = null;\r\n\r\n      if (isBranch) {\r\n        edge.setBondType(vertex.value.branchBond || '-');\r\n        vertexId = vertex.id;\r\n        edge.setBondType(vertex.value.branchBond || '-');\r\n        vertexId = vertex.id;\r\n      } else {\r\n        edge.setBondType(parentVertex.value.bondType || '-');\r\n        vertexId = parentVertex.id;\r\n      }\r\n\r\n      let edgeId = this.addEdge(edge);\r\n    }\r\n\r\n    let offset = node.ringbondCount + 1;\r\n\r\n    if (atom.bracket) {\r\n      offset += atom.bracket.hcount;\r\n    }\r\n\r\n    let stereoHydrogens = 0;\r\n    if (atom.bracket && atom.bracket.chirality) {\r\n      atom.isStereoCenter = true;\r\n      stereoHydrogens = atom.bracket.hcount;\r\n      for (var i = 0; i < stereoHydrogens; i++) {\r\n        this._init({\r\n          atom: 'H',\r\n          isBracket: 'false',\r\n          branches: Array(),\r\n          branchCount: 0,\r\n          ringbonds: Array(),\r\n          ringbondCount: false,\r\n          next: null,\r\n          hasNext: false,\r\n          bond: '-'\r\n        }, i, vertex.id, true);\r\n      }\r\n    }\r\n\r\n    for (var i = 0; i < node.branchCount; i++) {\r\n      this._init(node.branches[i], i + offset, vertex.id, true);\r\n    }\r\n\r\n    if (node.hasNext) {\r\n      this._init(node.next, node.branchCount + offset, vertex.id);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears all the elements in this graph (edges and vertices).\r\n   */\r\n  clear() {\r\n    this.vertices = Array();\r\n    this.edges = Array();\r\n    this.vertexIdsToEdgeId = {};\r\n  }\r\n\r\n  /**\r\n   * Add a vertex to the graph.\r\n   *\r\n   * @param {Vertex} vertex A new vertex.\r\n   * @returns {Number} The vertex id of the new vertex.\r\n   */\r\n  addVertex(vertex) {\r\n    vertex.id = this.vertices.length;\r\n    this.vertices.push(vertex);\r\n\r\n    return vertex.id;\r\n  }\r\n\r\n  /**\r\n   * Add an edge to the graph.\r\n   *\r\n   * @param {Edge} edge A new edge.\r\n   * @returns {Number} The edge id of the new edge.\r\n   */\r\n  addEdge(edge) {\r\n    let source = this.vertices[edge.sourceId];\r\n    let target = this.vertices[edge.targetId];\r\n\r\n    edge.id = this.edges.length;\r\n    this.edges.push(edge);\r\n\r\n    this.vertexIdsToEdgeId[edge.sourceId + '_' + edge.targetId] = edge.id;\r\n    this.vertexIdsToEdgeId[edge.targetId + '_' + edge.sourceId] = edge.id;\r\n    edge.isPartOfAromaticRing = source.value.isPartOfAromaticRing && target.value.isPartOfAromaticRing;\r\n\r\n    source.value.bondCount += edge.weight;\r\n    target.value.bondCount += edge.weight;\r\n\r\n    source.edges.push(edge.id);\r\n    target.edges.push(edge.id);\r\n\r\n    return edge.id;\r\n  }\r\n\r\n  /**\r\n   * Returns the edge between two given vertices.\r\n   *\r\n   * @param {Number} vertexIdA A vertex id.\r\n   * @param {Number} vertexIdB A vertex id.\r\n   * @returns {(Edge|null)} The edge or, if no edge can be found, null.\r\n   */\r\n  getEdge(vertexIdA, vertexIdB) {\r\n    let edgeId = this.vertexIdsToEdgeId[vertexIdA + '_' + vertexIdB];\r\n\r\n    return edgeId === undefined ? null : this.edges[edgeId];\r\n  }\r\n\r\n  /**\r\n   * Returns the ids of edges connected to a vertex.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @returns {Number[]} An array containing the ids of edges connected to the vertex.\r\n   */\r\n  getEdges(vertexId) {\r\n    let edgeIds = Array();\r\n    let vertex = this.vertices[vertexId];\r\n\r\n    for (var i = 0; i < vertex.neighbours.length; i++) {\r\n      edgeIds.push(this.vertexIdsToEdgeId[vertexId + '_' + vertex.neighbours[i]]);\r\n    }\r\n\r\n    return edgeIds;\r\n  }\r\n\r\n\r\n  /**\r\n   * Check whether or not two vertices are connected by an edge.\r\n   *\r\n   * @param {Number} vertexIdA A vertex id.\r\n   * @param {Number} vertexIdB A vertex id.\r\n   * @returns {Boolean} A boolean indicating whether or not two vertices are connected by an edge.\r\n   */\r\n  hasEdge(vertexIdA, vertexIdB) {\r\n    return this.vertexIdsToEdgeId[vertexIdA + '_' + vertexIdB] !== undefined\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing the vertex ids of this graph.\r\n   * \r\n   * @returns {Number[]} An array containing all vertex ids of this graph.\r\n   */\r\n  getVertexList() {\r\n    let arr = [this.vertices.length];\r\n\r\n    for (var i = 0; i < this.vertices.length; i++) {\r\n      arr[i] = this.vertices[i].id;\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing source, target arrays of this graphs edges.\r\n   * \r\n   * @returns {Array[]} An array containing source, target arrays of this graphs edges. Example: [ [ 2, 5 ], [ 6, 9 ] ].\r\n   */\r\n  getEdgeList() {\r\n    let arr = Array(this.edges.length);\r\n\r\n    for (var i = 0; i < this.edges.length; i++) {\r\n      arr[i] = [this.edges[i].sourceId, this.edges[i].targetId];\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency matrix of the graph.\r\n   * \r\n   * @returns {Array[]} The adjancency matrix of the molecular graph.\r\n   */\r\n  getAdjacencyMatrix() {\r\n    let length = this.vertices.length;\r\n    let adjacencyMatrix = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyMatrix[i] = new Array(length);\r\n      adjacencyMatrix[i].fill(0);\r\n    }\r\n\r\n    for (var i = 0; i < this.edges.length; i++) {\r\n      let edge = this.edges[i];\r\n\r\n      adjacencyMatrix[edge.sourceId][edge.targetId] = 1;\r\n      adjacencyMatrix[edge.targetId][edge.sourceId] = 1;\r\n    }\r\n\r\n    return adjacencyMatrix;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency matrix of the graph with all bridges removed (thus the components). Thus the remaining vertices are all part of ring systems.\r\n   * \r\n   * @returns {Array[]} The adjancency matrix of the molecular graph with all bridges removed.\r\n   */\r\n  getComponentsAdjacencyMatrix() {\r\n    let length = this.vertices.length;\r\n    let adjacencyMatrix = Array(length);\r\n    let bridges = this.getBridges();\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyMatrix[i] = new Array(length);\r\n      adjacencyMatrix[i].fill(0);\r\n    }\r\n\r\n    for (var i = 0; i < this.edges.length; i++) {\r\n      let edge = this.edges[i];\r\n\r\n      adjacencyMatrix[edge.sourceId][edge.targetId] = 1;\r\n      adjacencyMatrix[edge.targetId][edge.sourceId] = 1;\r\n    }\r\n\r\n    for (var i = 0; i < bridges.length; i++) {\r\n      adjacencyMatrix[bridges[i][0]][bridges[i][1]] = 0;\r\n      adjacencyMatrix[bridges[i][1]][bridges[i][0]] = 0;\r\n    }\r\n\r\n    return adjacencyMatrix;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency matrix of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The adjancency matrix of the subgraph.\r\n   */\r\n  getSubgraphAdjacencyMatrix(vertexIds) {\r\n    let length = vertexIds.length;\r\n    let adjacencyMatrix = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyMatrix[i] = new Array(length);\r\n      adjacencyMatrix[i].fill(0);\r\n\r\n      for (var j = 0; j < length; j++) {\r\n        if (i === j) {\r\n          continue;\r\n        }\r\n\r\n        if (this.hasEdge(vertexIds[i], vertexIds[j])) {\r\n          adjacencyMatrix[i][j] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    return adjacencyMatrix;\r\n  }\r\n\r\n  /**\r\n   * Get the distance matrix of the graph.\r\n   * \r\n   * @returns {Array[]} The distance matrix of the graph.\r\n   */\r\n  getDistanceMatrix() {\r\n    let length = this.vertices.length;\r\n    let adja = this.getAdjacencyMatrix();\r\n    let dist = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      dist[i] = Array(length);\r\n      dist[i].fill(Infinity);\r\n    }\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      for (var j = 0; j < length; j++) {\r\n        if (adja[i][j] === 1) {\r\n          dist[i][j] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (var k = 0; k < length; k++) {\r\n      for (var i = 0; i < length; i++) {\r\n        for (var j = 0; j < length; j++) {\r\n          if (dist[i][j] > dist[i][k] + dist[k][j]) {\r\n            dist[i][j] = dist[i][k] + dist[k][j]\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return dist;\r\n  }\r\n\r\n  /**\r\n   * Get the distance matrix of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The distance matrix of the subgraph.\r\n   */\r\n  getSubgraphDistanceMatrix(vertexIds) {\r\n    let length = vertexIds.length;\r\n    let adja = this.getSubgraphAdjacencyMatrix(vertexIds);\r\n    let dist = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      dist[i] = Array(length);\r\n      dist[i].fill(Infinity);\r\n    }\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      for (var j = 0; j < length; j++) {\r\n        if (adja[i][j] === 1) {\r\n          dist[i][j] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (var k = 0; k < length; k++) {\r\n      for (var i = 0; i < length; i++) {\r\n        for (var j = 0; j < length; j++) {\r\n          if (dist[i][j] > dist[i][k] + dist[k][j]) {\r\n            dist[i][j] = dist[i][k] + dist[k][j]\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return dist;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency list of the graph.\r\n   * \r\n   * @returns {Array[]} The adjancency list of the graph.\r\n   */\r\n  getAdjacencyList() {\r\n    let length = this.vertices.length;\r\n    let adjacencyList = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyList[i] = [];\r\n\r\n      for (var j = 0; j < length; j++) {\r\n        if (i === j) {\r\n          continue;\r\n        }\r\n\r\n        if (this.hasEdge(this.vertices[i].id, this.vertices[j].id)) {\r\n          adjacencyList[i].push(j);\r\n        }\r\n      }\r\n    }\r\n\r\n    return adjacencyList;\r\n  }\r\n\r\n  /**\r\n   * Get the adjacency list of a subgraph.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.\r\n   * @returns {Array[]} The adjancency list of the subgraph.\r\n   */\r\n  getSubgraphAdjacencyList(vertexIds) {\r\n    let length = vertexIds.length;\r\n    let adjacencyList = Array(length);\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      adjacencyList[i] = Array();\r\n\r\n      for (var j = 0; j < length; j++) {\r\n        if (i === j) {\r\n          continue;\r\n        }\r\n\r\n        if (this.hasEdge(vertexIds[i], vertexIds[j])) {\r\n          adjacencyList[i].push(j);\r\n        }\r\n      }\r\n    }\r\n\r\n    return adjacencyList;\r\n  }\r\n\r\n  /**\r\n   * Returns an array containing the edge ids of bridges. A bridge splits the graph into multiple components when removed.\r\n   * \r\n   * @returns {Number[]} An array containing the edge ids of the bridges.\r\n   */\r\n  getBridges() {\r\n    let length = this.vertices.length;\r\n    let visited = new Array(length);\r\n    let disc = new Array(length);\r\n    let low = new Array(length);\r\n    let parent = new Array(length);\r\n    let adj = this.getAdjacencyList();\r\n    let outBridges = Array();\r\n\r\n    visited.fill(false);\r\n    parent.fill(null);\r\n    this._time = 0;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      if (!visited[i]) {\r\n        this._bridgeDfs(i, visited, disc, low, parent, adj, outBridges);\r\n      }\r\n    }\r\n\r\n    return outBridges;\r\n  }\r\n\r\n  /**\r\n   * Traverses the graph in breadth-first order.\r\n   * \r\n   * @param {Number} startVertexId The id of the starting vertex.\r\n   * @param {Function} callback The callback function to be called on every vertex.\r\n   */\r\n  traverseBF(startVertexId, callback) {\r\n    let length = this.vertices.length;\r\n    let visited = new Array(length);\r\n\r\n    visited.fill(false);\r\n\r\n    var queue = [startVertexId];\r\n\r\n    while (queue.length > 0) {\r\n      // JavaScripts shift() is O(n) ... bad JavaScript, bad!\r\n      let u = queue.shift();\r\n      let vertex = this.vertices[u];\r\n\r\n      callback(vertex);\r\n\r\n      for (var i = 0; i < vertex.neighbours.length; i++) {\r\n        let v = vertex.neighbours[i]\r\n        if (!visited[v]) {\r\n          visited[v] = true;\r\n          queue.push(v);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the depth of a subtree in the direction opposite to the vertex specified as the parent vertex.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @param {Number} parentVertexId The id of a neighbouring vertex.\r\n   * @returns {Number} The depth of the sub-tree.\r\n   */\r\n  getTreeDepth(vertexId, parentVertexId) {\r\n    if (vertexId === null || parentVertexId === null) {\r\n      return 0;\r\n    }\r\n\r\n    let neighbours = this.vertices[vertexId].getSpanningTreeNeighbours(parentVertexId);\r\n    let max = 0;\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      let childId = neighbours[i];\r\n      let d = this.getTreeDepth(childId, vertexId);\r\n\r\n      if (d > max) {\r\n        max = d;\r\n      }\r\n    }\r\n\r\n    return max + 1;\r\n  }\r\n\r\n  /**\r\n   * Traverse a sub-tree in the graph.\r\n   *\r\n   * @param {Number} vertexId A vertex id.\r\n   * @param {Number} parentVertexId A neighbouring vertex.\r\n   * @param {Function} callback The callback function that is called with each visited as an argument.\r\n   * @param {Number} [maxDepth=999999] The maximum depth of the recursion.\r\n   * @param {Boolean} [ignoreFirst=false] Whether or not to ignore the starting vertex supplied as vertexId in the callback.\r\n   * @param {Number} [depth=1] The current depth in the tree.\r\n   * @param {Uint8Array} [visited=null] An array holding a flag on whether or not a node has been visited.\r\n   */\r\n  traverseTree(vertexId, parentVertexId, callback, maxDepth = 999999, ignoreFirst = false, depth = 1, visited = null) {\r\n    if (visited === null) {\r\n      visited = new Uint8Array(this.vertices.length);\r\n    }\r\n\r\n    if (depth > maxDepth + 1 || visited[vertexId] === 1) {\r\n      return;\r\n    }\r\n\r\n    visited[vertexId] = 1;\r\n\r\n    let vertex = this.vertices[vertexId];\r\n    let neighbours = vertex.getNeighbours(parentVertexId);\r\n\r\n    if (!ignoreFirst || depth > 1) {\r\n      callback(vertex);\r\n    }\r\n\r\n    for (var i = 0; i < neighbours.length; i++) {\r\n      this.traverseTree(neighbours[i], vertexId, callback, maxDepth, ignoreFirst, depth + 1, visited);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Positiones the (sub)graph using Kamada and Kawais algorithm for drawing general undirected graphs. https://pdfs.semanticscholar.org/b8d3/bca50ccc573c5cb99f7d201e8acce6618f04.pdf\r\n   * There are undocumented layout parameters. They are undocumented for a reason, so be very careful.\r\n   * \r\n   * @param {Number[]} vertexIds An array containing vertexIds to be placed using the force based layout.\r\n   * @param {Vector2} center The center of the layout.\r\n   * @param {Number} startVertexId A vertex id. Should be the starting vertex - e.g. the first to be positioned and connected to a previously place vertex.\r\n   * @param {Ring} ring The bridged ring associated with this force-based layout.\r\n   */\r\n  kkLayout(vertexIds, center, startVertexId, ring, bondLength,\r\n    threshold = 0.1, innerThreshold = 0.1, maxIteration = 2000,\r\n    maxInnerIteration = 50, maxEnergy = 1e9) {\r\n\r\n    let edgeStrength = bondLength;\r\n\r\n    // Add vertices that are directly connected to the ring\r\n    var i = vertexIds.length;\r\n    while (i--) {\r\n      let vertex = this.vertices[vertexIds[i]];\r\n      var j = vertex.neighbours.length;\r\n    }\r\n\r\n    let matDist = this.getSubgraphDistanceMatrix(vertexIds);\r\n    let length = vertexIds.length;\r\n\r\n    // Initialize the positions. Place all vertices on a ring around the center\r\n    let radius = MathHelper.polyCircumradius(500, length);\r\n    let angle = MathHelper.centralAngle(length);\r\n    let a = 0.0;\r\n    let arrPositionX = new Float32Array(length);\r\n    let arrPositionY = new Float32Array(length);\r\n    let arrPositioned = Array(length);\r\n\r\n    i = length;\r\n    while (i--) {\r\n      let vertex = this.vertices[vertexIds[i]];\r\n      if (!vertex.positioned) {\r\n        arrPositionX[i] = center.x + Math.cos(a) * radius;\r\n        arrPositionY[i] = center.y + Math.sin(a) * radius;\r\n      } else {\r\n        arrPositionX[i] = vertex.position.x;\r\n        arrPositionY[i] = vertex.position.y;\r\n      }\r\n      arrPositioned[i] = vertex.positioned;\r\n      a += angle;\r\n    }\r\n\r\n    // Create the matrix containing the lengths\r\n    let matLength = Array(length);\r\n    i = length;\r\n    while (i--) {\r\n      matLength[i] = new Array(length);\r\n      var j = length;\r\n      while (j--) {\r\n        matLength[i][j] = bondLength * matDist[i][j];\r\n      }\r\n    }\r\n\r\n    // Create the matrix containing the spring strenghts\r\n    let matStrength = Array(length);\r\n    i = length;\r\n    while (i--) {\r\n      matStrength[i] = Array(length);\r\n      var j = length;\r\n      while (j--) {\r\n        matStrength[i][j] = edgeStrength * Math.pow(matDist[i][j], -2.0);\r\n      }\r\n    }\r\n\r\n    // Create the matrix containing the energies\r\n    let matEnergy = Array(length);\r\n    let arrEnergySumX = new Float32Array(length);\r\n    let arrEnergySumY = new Float32Array(length);\r\n    i = length;\r\n    while (i--) {\r\n      matEnergy[i] = Array(length);\r\n    }\r\n\r\n    i = length;\r\n    let ux, uy, dEx, dEy, vx, vy, denom;\r\n\r\n    while (i--) {\r\n      ux = arrPositionX[i];\r\n      uy = arrPositionY[i];\r\n      dEx = 0.0;\r\n      dEy = 0.0;\r\n      let j = length;\r\n      while (j--) {\r\n        if (i === j) {\r\n          continue;\r\n        }\r\n        vx = arrPositionX[j];\r\n        vy = arrPositionY[j];\r\n        denom = 1.0 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));\r\n        matEnergy[i][j] = [\r\n          matStrength[i][j] * ((ux - vx) - matLength[i][j] * (ux - vx) * denom),\r\n          matStrength[i][j] * ((uy - vy) - matLength[i][j] * (uy - vy) * denom)\r\n        ]\r\n        matEnergy[j][i] = matEnergy[i][j];\r\n        dEx += matEnergy[i][j][0];\r\n        dEy += matEnergy[i][j][1];\r\n      }\r\n      arrEnergySumX[i] = dEx;\r\n      arrEnergySumY[i] = dEy;\r\n    }\r\n\r\n    // Utility functions, maybe inline them later\r\n    let energy = function (index) {\r\n      return [arrEnergySumX[index] * arrEnergySumX[index] + arrEnergySumY[index] * arrEnergySumY[index], arrEnergySumX[index], arrEnergySumY[index]];\r\n    }\r\n\r\n    let highestEnergy = function () {\r\n      let maxEnergy = 0.0;\r\n      let maxEnergyId = 0;\r\n      let maxDEX = 0.0;\r\n      let maxDEY = 0.0\r\n\r\n      i = length;\r\n      while (i--) {\r\n        let [delta, dEX, dEY] = energy(i);\r\n\r\n        if (delta > maxEnergy && arrPositioned[i] === false) {\r\n          maxEnergy = delta;\r\n          maxEnergyId = i;\r\n          maxDEX = dEX;\r\n          maxDEY = dEY;\r\n        }\r\n      }\r\n\r\n      return [maxEnergyId, maxEnergy, maxDEX, maxDEY];\r\n    }\r\n\r\n    let update = function (index, dEX, dEY) {\r\n      let dxx = 0.0;\r\n      let dyy = 0.0;\r\n      let dxy = 0.0;\r\n      let ux = arrPositionX[index];\r\n      let uy = arrPositionY[index];\r\n      let arrL = matLength[index];\r\n      let arrK = matStrength[index];\r\n\r\n      i = length;\r\n      while (i--) {\r\n        if (i === index) {\r\n          continue;\r\n        }\r\n\r\n        let vx = arrPositionX[i];\r\n        let vy = arrPositionY[i];\r\n        let l = arrL[i];\r\n        let k = arrK[i];\r\n        let m = (ux - vx) * (ux - vx);\r\n        let denom = 1.0 / Math.pow(m + (uy - vy) * (uy - vy), 1.5);\r\n\r\n        dxx += k * (1 - l * (uy - vy) * (uy - vy) * denom);\r\n        dyy += k * (1 - l * m * denom);\r\n        dxy += k * (l * (ux - vx) * (uy - vy) * denom);\r\n      }\r\n\r\n      // Prevent division by zero\r\n      if (dxx === 0) {\r\n        dxx = 0.1;\r\n      }\r\n\r\n      if (dyy === 0) {\r\n        dyy = 0.1;\r\n      }\r\n\r\n      if (dxy === 0) {\r\n        dxy = 0.1;\r\n      }\r\n\r\n      let dy = (dEX / dxx + dEY / dxy);\r\n      dy /= (dxy / dxx - dyy / dxy); // had to split this onto two lines because the syntax highlighter went crazy.\r\n      let dx = -(dxy * dy + dEX) / dxx;\r\n\r\n      arrPositionX[index] += dx;\r\n      arrPositionY[index] += dy;\r\n\r\n      // Update the energies\r\n      let arrE = matEnergy[index];\r\n      dEX = 0.0;\r\n      dEY = 0.0;\r\n\r\n      ux = arrPositionX[index];\r\n      uy = arrPositionY[index];\r\n\r\n      let vx, vy, prevEx, prevEy, denom;\r\n\r\n      i = length;\r\n      while (i--) {\r\n        if (index === i) {\r\n          continue;\r\n        }\r\n        vx = arrPositionX[i];\r\n        vy = arrPositionY[i];\r\n        // Store old energies\r\n        prevEx = arrE[i][0];\r\n        prevEy = arrE[i][1];\r\n        denom = 1.0 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));\r\n        dx = arrK[i] * ((ux - vx) - arrL[i] * (ux - vx) * denom);\r\n        dy = arrK[i] * ((uy - vy) - arrL[i] * (uy - vy) * denom);\r\n\r\n        arrE[i] = [dx, dy];\r\n        dEX += dx;\r\n        dEY += dy;\r\n        arrEnergySumX[i] += dx - prevEx;\r\n        arrEnergySumY[i] += dy - prevEy;\r\n      }\r\n      arrEnergySumX[index] = dEX;\r\n      arrEnergySumY[index] = dEY;\r\n    }\r\n\r\n    // Setting up variables for the while loops\r\n    let maxEnergyId = 0;\r\n    let dEX = 0.0;\r\n    let dEY = 0.0;\r\n    let delta = 0.0;\r\n    let iteration = 0;\r\n    let innerIteration = 0;\r\n\r\n    while (maxEnergy > threshold && maxIteration > iteration) {\r\n      iteration++;\r\n      [maxEnergyId, maxEnergy, dEX, dEY] = highestEnergy();\r\n      delta = maxEnergy;\r\n      innerIteration = 0;\r\n      while (delta > innerThreshold && maxInnerIteration > innerIteration) {\r\n        innerIteration++;\r\n        update(maxEnergyId, dEX, dEY);\r\n        [delta, dEX, dEY] = energy(maxEnergyId);\r\n      }\r\n    }\r\n\r\n    i = length;\r\n    while (i--) {\r\n      let index = vertexIds[i];\r\n      let vertex = this.vertices[index];\r\n      vertex.position.x = arrPositionX[i];\r\n      vertex.position.y = arrPositionY[i];\r\n      vertex.positioned = true;\r\n      vertex.forcePositioned = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * PRIVATE FUNCTION used by getBridges().\r\n   */\r\n  _bridgeDfs(u, visited, disc, low, parent, adj, outBridges) {\r\n    visited[u] = true;\r\n    disc[u] = low[u] = ++this._time;\r\n\r\n    for (var i = 0; i < adj[u].length; i++) {\r\n      let v = adj[u][i];\r\n\r\n      if (!visited[v]) {\r\n        parent[v] = u;\r\n\r\n        this._bridgeDfs(v, visited, disc, low, parent, adj, outBridges);\r\n\r\n        low[u] = Math.min(low[u], low[v]);\r\n\r\n        // If low > disc, we have a bridge\r\n        if (low[v] > disc[u]) {\r\n          outBridges.push([u, v]);\r\n        }\r\n      } else if (v !== parent[u]) {\r\n        low[u] = Math.min(low[u], disc[v]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the connected components of the graph.\r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Set[]} Connected components as sets.\r\n   */\r\n  static getConnectedComponents(adjacencyMatrix) {\r\n    let length = adjacencyMatrix.length;\r\n    let visited = new Array(length);\r\n    let components = new Array();\r\n    let count = 0;\r\n\r\n    visited.fill(false);\r\n\r\n    for (var u = 0; u < length; u++) {\r\n      if (!visited[u]) {\r\n        let component = Array();\r\n        visited[u] = true;\r\n        component.push(u);\r\n        count++;\r\n        Graph._ccGetDfs(u, visited, adjacencyMatrix, component);\r\n        if (component.length > 1) {\r\n          components.push(component);\r\n        }\r\n      }\r\n    }\r\n\r\n    return components;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of connected components for the graph. \r\n   * \r\n   * @param {Array[]} adjacencyMatrix An adjacency matrix.\r\n   * @returns {Number} The number of connected components of the supplied graph.\r\n   */\r\n  static getConnectedComponentCount(adjacencyMatrix) {\r\n    let length = adjacencyMatrix.length;\r\n    let visited = new Array(length);\r\n    let count = 0;\r\n\r\n    visited.fill(false);\r\n\r\n    for (var u = 0; u < length; u++) {\r\n      if (!visited[u]) {\r\n        visited[u] = true;\r\n        count++;\r\n        Graph._ccCountDfs(u, visited, adjacencyMatrix);\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * PRIVATE FUNCTION used by getConnectedComponentCount().\r\n   */\r\n  static _ccCountDfs(u, visited, adjacencyMatrix) {\r\n    for (var v = 0; v < adjacencyMatrix[u].length; v++) {\r\n      let c = adjacencyMatrix[u][v];\r\n\r\n      if (!c || visited[v] || u === v) {\r\n        continue;\r\n      }\r\n\r\n      visited[v] = true;\r\n      Graph._ccCountDfs(v, visited, adjacencyMatrix);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * PRIVATE FUNCTION used by getConnectedComponents().\r\n   */\r\n  static _ccGetDfs(u, visited, adjacencyMatrix, component) {\r\n    for (var v = 0; v < adjacencyMatrix[u].length; v++) {\r\n      let c = adjacencyMatrix[u][v];\r\n\r\n      if (!c || visited[v] || u === v) {\r\n        continue;\r\n      }\r\n\r\n      visited[v] = true;\r\n      component.push(v);\r\n      Graph._ccGetDfs(v, visited, adjacencyMatrix, component);\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Graph"]},"metadata":{},"sourceType":"script"}